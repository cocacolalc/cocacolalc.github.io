<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>js调用exe</title>
    <url>/2021/03/18/js%E8%B0%83%E7%94%A8exe/</url>
    <content><![CDATA[<h5 id="1-使用记事本（或其他文本编辑器）创建一个protocal-reg文件，并写入以下内容"><a href="#1-使用记事本（或其他文本编辑器）创建一个protocal-reg文件，并写入以下内容" class="headerlink" title="1.使用记事本（或其他文本编辑器）创建一个protocal.reg文件，并写入以下内容"></a>1.使用记事本（或其他文本编辑器）创建一个protocal.reg文件，并写入以下内容</h5><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">Windows Registry Editor Version <span class="hljs-number">5.00</span><br>[HKEY_CLASSES_ROOT\Webshell]<br>@=<span class="hljs-string">&quot;URL:Webshell Protocol Handler&quot;</span><br><span class="hljs-string">&quot;URL Protocol&quot;</span>=<span class="hljs-string">&quot;&quot;</span><br>[HKEY_CLASSES_ROOT\Webshell\DefaultIcon]<br>@=<span class="hljs-string">&quot;C:\\Program Files (x86)\\Tencent\\WeChat\\WeChat.exe&quot;</span><br>[HKEY_CLASSES_ROOT\Webshell\shell]<br>[HKEY_CLASSES_ROOT\Webshell\shell\open]<br>[HKEY_CLASSES_ROOT\Webshell\shell\open\command]<br>@=<span class="hljs-string">&quot;\&quot;C:\\Program Files (x86)\\Tencent\\WeChat\\WeChat.exe\&quot; \&quot;%1\&quot;&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="2-修改参数"><a href="#2-修改参数" class="headerlink" title="2.修改参数"></a>2.<strong>修改参数</strong></h3><p>使用记事本打开文件后，按照下图说明修改相关参数</p>
<p>修改红框内名称自定义即可，全部使用英文字符（该名称即为调用时的href），共六处</p>
<!-- 
![image-20210423132126316](C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210423132126316.png) -->

<p><strong>2.2修改可执行文件路径</strong></p>
<p>需注意：文件路径中使用//分割（重要）</p>
<!-- 
![image-20210423132200180](C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210423132200180.png) -->

<h3 id="3-执行protocal-reg文件"><a href="#3-执行protocal-reg文件" class="headerlink" title="3.执行protocal.reg文件"></a>3.<strong>执行protocal.reg文件</strong></h3><h3 id="4-创建调用连接"><a href="#4-创建调用连接" class="headerlink" title="4.创建调用连接"></a>4.<strong>创建调用连接</strong></h3><p>连接地址为 步骤1中所命名的链接名称，后面加://hello，（hello为传递参数，可任意添加）</p>
<!-- ![image-20210423132233779](C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210423132233779.png) -->]]></content>
      <tags>
        <tag>js调用exe</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs-2</title>
    <url>/2020/09/18/nodejs%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h1 id="nodejs笔记2"><a href="#nodejs笔记2" class="headerlink" title="nodejs笔记2"></a>nodejs笔记2</h1><h2 id="web应用架构"><a href="#web应用架构" class="headerlink" title="web应用架构"></a>web应用架构</h2><p>client-客户端，一般指浏览器，浏览器可以通过http协议向服务器请求数据。</p>
<p>server-服务端，一般指web服务器，可以接收客户请求，并向客户端发送响应数据。</p>
<h5 id="http-server"><a href="#http-server" class="headerlink" title="http server"></a>http server</h5><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//支持web服务的http</span><br><br>*<span class="hljs-keyword">const</span>* http=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><br>*<span class="hljs-keyword">let</span>* count=<span class="hljs-number">0</span><br><br><span class="hljs-comment">//创建一个服务,如果有url访问到了这个服务，回调函数执行</span><br><br><span class="hljs-comment">// 回调函数中，第一个形参request代表的是请求对象，里面存放了请求信息</span><br><br><span class="hljs-comment">// 第二个参数response：响应对象</span><br><br>*<span class="hljs-keyword">var</span>* serve=http.createServer((*request*,*response*)*=&gt;*&#123;<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;有人访问&#x27;</span>+(++count))<br><br>  <span class="hljs-comment">//设置响应头；200是成功 编码 类型</span><br><br>  *response*.writeHead(<span class="hljs-number">200</span>,&#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>:<span class="hljs-string">&#x27;text/html;charset=utf-8&#x27;</span>&#125;)<br><br>  <span class="hljs-comment">// 响应对象中添加数据</span><br><br>  *response*.write(<span class="hljs-string">&#x27;我是相应内容&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>  <span class="hljs-comment">// 结束</span><br><br>  *response*.end()<br><br>&#125;)<br><br><span class="hljs-comment">// 把服务监听3000端口</span><br><br>serve.listen(<span class="hljs-string">&#x27;3000&#x27;</span>,(*err*)*=&gt;*&#123;<br><br>  <span class="hljs-keyword">if</span>(*err*) <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(*err*)<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;serve listen at 3000&#x27;</span>)<br><br>&#125;)<br><br><span class="hljs-comment">// url ：http：协议</span><br><br><span class="hljs-comment">// 域名：或者 ip DFS服务器</span><br><br><span class="hljs-comment">// 端口：80默认</span><br><br></code></pre></td></tr></table></figure>

<h5 id="http"><a href="#http" class="headerlink" title="http"></a>http</h5><p>http域名或者IP</p>
<p>端口号</p>
<p>相对路径</p>
<h5 id="nodejs-http-server"><a href="#nodejs-http-server" class="headerlink" title="nodejs http server"></a>nodejs http server</h5><p>加载http包</p>
<p>http.createServer((request,response)=&gt;{</p>
<p>回调函数</p>
<p>request：请求对象</p>
<p>response：响应对象</p>
<p>server.listen(‘3000’)</p>
<p>})</p>
<h5 id="http工作原理-过程"><a href="#http工作原理-过程" class="headerlink" title="http工作原理  (过程)"></a>http工作原理  (过程)</h5><ul>
<li><p>1  客户端连接到web服务器</p>
</li>
<li><p>2  发送http请求</p>
</li>
<li><p>3   服务器接收解释请求并返回http响应</p>
</li>
<li><p>4  释放连接tcp连接</p>
</li>
</ul>
<h5 id="path"><a href="#path" class="headerlink" title="path"></a>path</h5><ul>
<li>专注于文件路径</li>
</ul>
<h5 id="url"><a href="#url" class="headerlink" title="url"></a>url</h5><ul>
<li>专注于处理url地址</li>
</ul>
<h5 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h5><ul>
<li>专注于url中使用get请求后面解析参数</li>
</ul>
<h5 id="解析url"><a href="#解析url" class="headerlink" title="解析url"></a>解析url</h5><blockquote>
<p>new  URL(request.url,’http://${request.headers.host}’)</p>
</blockquote>
<h5 id="get-set"><a href="#get-set" class="headerlink" title="get   set"></a>get   set</h5><ul>
<li>get 参数，是拼接在url后面；post参数body</li>
<li>浏览器地址栏中访问的url</li>
</ul>
<h5 id="nodejs区分get-post"><a href="#nodejs区分get-post" class="headerlink" title="nodejs区分get post"></a>nodejs区分get post</h5><p>request.method</p>
<p>nodejs 从get  post  获取参数数据</p>
<ul>
<li>get  获取参数  分析url  </li>
<li>post获取参数</li>
</ul>
<h5 id="创建express项目"><a href="#创建express项目" class="headerlink" title="创建express项目"></a>创建express项目</h5><ul>
<li>安装一个创建express项目的工具（express生成器）–express-generator</li>
</ul>
<p>安装命令：</p>
<blockquote>
<p>npm install express-generator -g</p>
</blockquote>
<p>全局安装：</p>
<ul>
<li>使用这个工具生成一个express项目</li>
</ul>
<p>命令是：</p>
<blockquote>
<p>express –view=ejs myprogramName </p>
</blockquote>
<ul>
<li><p>myprogramName是项目的名字</p>
</li>
<li><p>–view=ejs 设置项目的页面使用的模板引擎；设置模版引擎为ejs pug</p>
</li>
<li><p>创建完成项目文件之后； </p>
</li>
<li><p>cd myprogramName 命令窗口前面的路径定位到项目文件</p>
</li>
<li><p>D:\work\Lesson\202002\2-165\Day08\my1</p>
</li>
</ul>
<blockquote>
<p>npm i </p>
</blockquote>
<p>会在my1这个文件夹下寻找package.json，获取dependencies里面的包；并且全部安装；</p>
<ul>
<li>启动项目</li>
</ul>
<blockquote>
<p>SET DEBUG=my1:* &amp; npm start</p>
</blockquote>
<ul>
<li>默认是在3000端口号： localhost:3000 127.0.0.1:3000</li>
</ul>
<h5 id="项目文件："><a href="#项目文件：" class="headerlink" title="项目文件："></a>项目文件：</h5><ul>
<li><p>bin/www 可以修改服务的端口号：</p>
</li>
<li><p>node_modules 所有局部安装的包</p>
</li>
<li><p>pulic 存放静态文件的；</p>
</li>
<li><p>routes 路由</p>
</li>
<li><p>views 页面</p>
</li>
<li><p>app.js 启动js</p>
</li>
<li><p>package.json npm配置文件</p>
</li>
</ul>
<p>npm i 就是安装的dependencies下的包</p>
<p>npm start 就是运行的scripts下面start命令</p>
<h5 id="app-js-文件"><a href="#app-js-文件" class="headerlink" title="app.js 文件"></a>app.js 文件</h5><h5 id="路由："><a href="#路由：" class="headerlink" title="路由："></a>路由：</h5><ul>
<li><p>在routes文件夹下 写路由文件</p>
</li>
<li><p>app.js中启用路由：</p>
</li>
</ul>
<h5 id="响应返回页面"><a href="#响应返回页面" class="headerlink" title="响应返回页面"></a>响应返回页面</h5><p>在路由中，使用res.render(“list”)；</p>
<p>-页面必须放在views下；而且后缀名必须是.ejs</p>
<h5 id="怎么获取url传递的数据："><a href="#怎么获取url传递的数据：" class="headerlink" title="怎么获取url传递的数据："></a>怎么获取url传递的数据：</h5><ul>
<li><p>get 参数: 在路由 req.query 属性，存放了所有get请求的参数：</p>
</li>
<li><p>post 数据 req.body 存储</p>
</li>
</ul>
<h5 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h5><p>req.params</p>
<h5 id="路由的路径是可以用正则表达式"><a href="#路由的路径是可以用正则表达式" class="headerlink" title="路由的路径是可以用正则表达式"></a>路由的路径是可以用正则表达式</h5><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><ul>
<li><p>npm i express-generator -g 如果安装过了，不用再安装</p>
</li>
<li><p>生成一个项目</p>
</li>
</ul>
<blockquote>
<p>express –view=ejs xiaou</p>
</blockquote>
<blockquote>
<p>cd xiaou</p>
</blockquote>
<blockquote>
<p>npm i </p>
</blockquote>
<blockquote>
<p>npm start</p>
</blockquote>
<ul>
<li><p>把index.html复制到views，并且要ejs后缀；</p>
</li>
<li><p>设计一个路由： 设计url地址；访问这个url，</p>
</li>
<li><p>routes文件夹下创建一个新的路由文件index.js</p>
</li>
</ul>
<h5 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h5><ul>
<li>单线程</li>
<li>非阻塞</li>
<li>事件驱动</li>
</ul>
<h5 id="模块化commonJS"><a href="#模块化commonJS" class="headerlink" title="模块化commonJS"></a>模块化commonJS</h5><ul>
<li>定义模块：</li>
</ul>
<p>modules.exporys{}</p>
<p>modules.exporys.xxx=xx</p>
<p>exports.xxx=xx</p>
<ul>
<li>加载模块：</li>
</ul>
<p>通过js（模块）的加载路径：</p>
<p>const mymoudule=require(‘模块’)</p>
<p>通过js（模块）的标识：核心模块（nodejs自带的    ）</p>
<p>const http=require(‘http’)</p>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><ul>
<li>初始化</li>
<li>绑定事件</li>
<li>触发事件</li>
<li>传值：</li>
</ul>
<h5 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h5><ul>
<li>包：</li>
<li>全局安装    -g   本地安装</li>
<li>依赖   和   开发依赖：</li>
</ul>
<p>依赖：express   简写–save    -S</p>
<p>开发依赖：less  简写  –save-dev   -D</p>
<h5 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h5><h5 id="nodejs-http"><a href="#nodejs-http" class="headerlink" title="nodejs  http"></a>nodejs  http</h5><ul>
<li><p><a href="http://www.ddd.com/">http://www.ddd.com:80</a>   默认是80</p>
<h5 id="http四个步骤："><a href="#http四个步骤：" class="headerlink" title="http四个步骤："></a>http四个步骤：</h5><ul>
<li>客户端向服务端发起的连接</li>
<li>客户端向服务器发送的数据</li>
<li>服务器响应客户端</li>
<li>客户端结束连接</li>
</ul>
<h5 id="nodejs下的一些小模块"><a href="#nodejs下的一些小模块" class="headerlink" title="nodejs下的一些小模块"></a>nodejs下的一些小模块</h5><ul>
<li>path</li>
<li>url</li>
<li>queryString</li>
</ul>
<h5 id="express"><a href="#express" class="headerlink" title="express"></a>express</h5><p>基于nodejs的一个web开发框架：</p>
<h5 id="创建esperss项目的步骤"><a href="#创建esperss项目的步骤" class="headerlink" title="创建esperss项目的步骤"></a>创建esperss项目的步骤</h5><ul>
<li>全局安装espress项目生成器</li>
</ul>
</li>
</ul>
<p>命令：npm i express-generator -g</p>
<p>创建express项目的基础框架</p>
<blockquote>
<p>express –view=ejs xiaou</p>
</blockquote>
<blockquote>
<p>cd xiaou</p>
</blockquote>
<blockquote>
<p>npm i </p>
</blockquote>
<blockquote>
<p>npm start</p>
</blockquote>
<h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><p>在routes创建新的路由文件product.js</p>
<p>路由地址的匹配</p>
<p>正则</p>
<p>动态路由</p>
<h5 id="路由返回数据"><a href="#路由返回数据" class="headerlink" title="路由返回数据"></a>路由返回数据</h5><ul>
<li>字符串：res.send()</li>
<li>页面：res.render(‘文件路径’)；文件夹是是固定的views文件夹</li>
<li>json  res.json({})</li>
</ul>
<h5 id="中间件："><a href="#中间件：" class="headerlink" title="中间件："></a>中间件：</h5><p>每个请求都会经过中间件的检查过滤</p>
<p>1、中间件就是一种功能的封装方式，就是封装在程序中处理http请求的功能，  </p>
<p>2、中间件是在管道中执行</p>
<p>3、中间件有一个next()函数，如果不调用next函数，请求就在这个中间件中终止了，</p>
<p>4、中间件和路由处理器的参数中都有回调函数，这个函数有2,3,4个参数</p>
<p>如果有两个参数就是req和res；</p>
<p>如果有三个参数就是req,res和next</p>
<p>如果有四个参数就是err，req，res，next</p>
<p>5、如果不调用next ，管道就会终止，不会再有处理器做后续响应，应该向客户端发送一个响应</p>
<p>6、如果调用了next，不应该发送响应到客户端，如果发送了，则后面发送的响应都会被忽略</p>
<p>7、中间件的第一个参数可以是路径，如果忽略则全部都匹配</p>
<h5 id="ejs"><a href="#ejs" class="headerlink" title="ejs"></a>ejs</h5><p>res.render(‘页面的相对路径‘，data)  第二个参数是数据。传递给页面    的数据</p>
<p>第二个参数是传递给页面中的模板引擎数据</p>
<p>模板引擎中的语法</p>
<p>&lt;%# 注释%&gt;</p>
<h5 id="art-template-模板引擎"><a href="#art-template-模板引擎" class="headerlink" title="art -template  模板引擎"></a>art -template  模板引擎</h5><ul>
<li><p>espress项目中，使用arttemplate模板引擎</p>
</li>
<li><p>安装arttemplate包和express下的支持包</p>
</li>
<li><p>npm  i art - template  -S</p>
</li>
<li><p>npm  i express-art - template  -S</p>
</li>
</ul>
<h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2><ul>
<li>数据库：存储文件：</li>
<li>MySQl:服务类的程序：</li>
</ul>
<h3 id="常见数据库"><a href="#常见数据库" class="headerlink" title="常见数据库"></a>常见数据库</h3><ul>
<li>Oracle</li>
<li>mysql</li>
<li>ms sql server</li>
<li>mongodb</li>
</ul>
<h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><ul>
<li>关系数据库</li>
<li>非关系数据库</li>
</ul>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><ul>
<li>第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项</li>
<li>第二范式（2NF）：在1NF的基础上，非主键属性必须完全依赖于主键</li>
<li>第三范式（3NF）：在2NF基础上，任何非主键属性不依赖于其它非主键属性（在2NF基础上消除传递依赖）</li>
<li>反范式：</li>
</ul>
<h3 id="mysql-语法：sql语法"><a href="#mysql-语法：sql语法" class="headerlink" title="mysql 语法：sql语法"></a>mysql 语法：sql语法</h3><ul>
<li>DDL  DML</li>
</ul>
<h3 id="数据库：database"><a href="#数据库：database" class="headerlink" title="数据库：database"></a>数据库：database</h3><pre><code>-   创建数据库：
&gt;create database if not exists xiaou ;</code></pre>
<h3 id="表：table"><a href="#表：table" class="headerlink" title="表：table"></a>表：table</h3><ul>
<li>创建表：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`xiaou`</span>.<span class="hljs-string">`user`</span> (<br>  <span class="hljs-string">`cardid`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`name`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`age`</span> <span class="hljs-built_in">INT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`address`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`height`</span> <span class="hljs-built_in">FLOAT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`createby`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`createtime`</span> <span class="hljs-built_in">DATE</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`updateby`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`updatetime`</span> <span class="hljs-built_in">DATE</span> <span class="hljs-literal">NULL</span>,<br>  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`cardid`</span>));<br><br><br></code></pre></td></tr></table></figure>

<ul>
<li>修改表：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`xiaou`</span>.<span class="hljs-string">`user`</span> <br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">`disc`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-literal">NULL</span> <span class="hljs-keyword">AFTER</span> <span class="hljs-string">`tel`</span>;<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`xiaou`</span>.<span class="hljs-string">`user`</span> <br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">`disc`</span>;<br><br><br></code></pre></td></tr></table></figure>

<h3 id="删除表、删除数据库"><a href="#删除表、删除数据库" class="headerlink" title="删除表、删除数据库"></a>删除表、删除数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> stud;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> ujiuye;<br><br><br></code></pre></td></tr></table></figure>

<h3 id="中文："><a href="#中文：" class="headerlink" title="中文："></a>中文：</h3><p>修改字段编码为urf8  ;utf8-general-ci;</p>
<h3 id="插入数据："><a href="#插入数据：" class="headerlink" title="插入数据："></a>插入数据：</h3><ul>
<li><p>insert into </p>
</li>
<li><p>格式<br><strong>全部列添加数据：</strong><br>insert into table_name (id,name,age,<code>drop</code>) values(10,’zs’,100,’eer’);<br>如果对所有的列添加数据： 前面的（列名、）是可以省略的；<br>insert into table_name values(10,’zs’,100,’eer’);</p>
</li>
</ul>
<p><strong>部分列添加数据：</strong><br>insert into table_name (id,name) values(10,’zs’);</p>
<h3 id="修改数据："><a href="#修改数据：" class="headerlink" title="修改数据："></a>修改数据：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> xiaou.user <span class="hljs-keyword">set</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">&#x27;zs2000&#x27;</span>,age=<span class="hljs-number">2000</span> <span class="hljs-keyword">where</span> address=<span class="hljs-string">&#x27;上海&#x27;</span>;<br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>nodejs-1</title>
    <url>/2020/09/18/nodejs%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="node-js"><a href="#node-js" class="headerlink" title="node js"></a>node js</h1><p>nodejs是基于google v8引擎，在服务器端支持javascript的一种运行环境。</p>
<p>特点：单线程、非阻塞I/O、事件驱动</p>
<h4 id="node运行js文件的路径："><a href="#node运行js文件的路径：" class="headerlink" title="node运行js文件的路径："></a>node运行js文件的路径：</h4><p>相对路径：node命令前面的路径（运行路径）</p>
<p>绝对路径        </p>
<h4 id="顶层对象"><a href="#顶层对象" class="headerlink" title="顶层对象"></a>顶层对象</h4><p>浏览器里是window，node里是global，ES6中提到同义顶层对象用globalThis，</p>
<p>ES6中将顶层对象的属性与全局变量逐步脱钩。</p>
<h4 id="默认的全局变量"><a href="#默认的全局变量" class="headerlink" title="默认的全局变量"></a>默认的全局变量</h4><p>__filename当前js文件带有完整绝对路径的文件名</p>
<p>__dirname获得当前执行文件所在目录的完整目录名</p>
<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p>Buffer 被引入用以帮助开发者处理二进制数据，在此生态系统中传统上只处理字符串而不是二进制数据。</p>
<p>1、指定大小：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buffer=Buffer.alloc(<span class="hljs-number">20</span>);<span class="hljs-comment">//length</span><br><span class="hljs-comment">//&lt;Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>2、</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buf2=Buffer.from(<span class="hljs-string">&quot;this is buffer&quot;</span>);<span class="hljs-comment">//string</span><br><span class="hljs-comment">//&lt;Buffer 74 68 69 73 20 69 73 20 62 75 66 66 65 72&gt;</span><br><span class="hljs-keyword">var</span> s=buf2.toString(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><span class="hljs-comment">//this is buffer</span><br>buf2.write();<br><br></code></pre></td></tr></table></figure>

<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>多个js文件的引用方式。</p>
<p>模块：按照特定的格式写出来的js文件。</p>
<p>特定的格式：为了引用，模块化规范。</p>
<p>nodejs里用的是commonjs规范。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sub</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-built_in">module</span>.exports=&#123;sum,sub&#125;;<span class="hljs-comment">//导出</span><br><span class="hljs-built_in">exports</span>.sum=sum;<span class="hljs-comment">//exports只能用这种方式</span><br><br><br><span class="hljs-comment">//引用</span><br><span class="hljs-keyword">let</span> &#123;sum,sub&#125;=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;路径&quot;</span>);<br><br></code></pre></td></tr></table></figure>

<h5 id="事件模块"><a href="#事件模块" class="headerlink" title="事件模块"></a>事件模块</h5><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//内置模块http、fs、events，核心模块</span><br><span class="hljs-keyword">let</span> http=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">let</span> fs=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><br><br><span class="hljs-comment">//events是内置的处理事件的模块 EventEmitter</span><br><span class="hljs-comment">//events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</span><br><span class="hljs-comment">//1、加载事件模块</span><br><span class="hljs-keyword">let</span> EventEmitter=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;events&quot;</span>).EventEmitter;<br><span class="hljs-number">2</span>、实例化一个事件对象<br><span class="hljs-keyword">let</span> event=<span class="hljs-keyword">new</span> EventEmitter();<br><span class="hljs-comment">//3、实例提供里两个方法：</span><br>event.on(<span class="hljs-string">&quot;event1&quot;</span>,<span class="hljs-function">(<span class="hljs-params">...args</span>)=&gt;</span>&#123;<span class="hljs-comment">//为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。</span><br>  <span class="hljs-built_in">console</span>.log(args)；<br>&#125;)<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    event.emit(<span class="hljs-string">&quot;event1&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>)<span class="hljs-comment">//触发事件emit(event, [arg1], [arg2], [...])</span><br>&#125;, <span class="hljs-number">1000</span>)<br>event.addListener(<span class="hljs-string">&#x27;event1&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>&#125;)<br>event.on(<span class="hljs-string">&quot;e2&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    event.removeAllListeners(<span class="hljs-string">&#x27;event1&#x27;</span>)<span class="hljs-comment">//只清除一个event.removeListener(&#x27;event1&#x27;,fn)</span><br>&#125;)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    event.emit(<span class="hljs-string">&#x27;e2&#x27;</span>)<br>&#125;,<span class="hljs-number">4000</span>)<br><span class="hljs-comment">//实例event提供的方法：</span><br>on(event,函数名)<span class="hljs-comment">//绑定</span><br>addListener(event,函数名)<span class="hljs-comment">//添加</span><br>once(event,函数名)<span class="hljs-comment">//只一次</span><br>removeListener(event,函数名)<span class="hljs-comment">//移除</span><br><span class="hljs-comment">//移除某个监听函数，必须在添加监视的时候，是通过函数名添加，如果是一个匿名函数添加监听不能移除</span><br>removeAllListeners(event)<span class="hljs-comment">//移除所有</span><br>emit(event, [arg1], [arg2], [...])<span class="hljs-comment">//触发</span><br><br><br></code></pre></td></tr></table></figure>

<h4 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h4><p>模块：按照CommonJS规范写的js文件；</p>
<p>包：包含js文件和其他附带信息的整体；</p>
<p>npm：包的管理工具：</p>
<p>​    1、根据包的名字，下载并按照npmjs.com</p>
<p>​    2、解决了包之间的依赖关系</p>
<p>命令</p>
<p>​    安装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">npm install 包<br><br><span class="hljs-keyword">let</span> x=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;包&#x27;</span>)<br><br></code></pre></td></tr></table></figure>

<h4 id="Nodejs的文件系统"><a href="#Nodejs的文件系统" class="headerlink" title="Nodejs的文件系统"></a>Nodejs的文件系统</h4><p>读取文件信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fs=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br>fs.stat(<span class="hljs-string">&quot;文件路径&quot;</span>,<span class="hljs-function">(<span class="hljs-params">err,stats</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">if</span>(err)&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;错误&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">if</span>(stats.isFile()) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这是文件&quot;</span>);<br>    <span class="hljs-keyword">if</span>(stats.isDirectory()) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这是文件夹&quot;</span>);<br>    <span class="hljs-built_in">console</span>.log(stats)<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure>

<p>读取文件内容</p>
<p>​    两个参数：文件路径、回调函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">fs.readFile(<span class="hljs-string">&#x27;文件路径&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;&#125;)<span class="hljs-comment">//异步</span><br><span class="hljs-keyword">var</span> data=fs.readFileSync(<span class="hljs-string">&quot;文件路径&quot;</span>，<span class="hljs-string">&quot;编码方式&quot;</span>)；<span class="hljs-comment">//同步读取文件</span><br><br></code></pre></td></tr></table></figure>

<p>读取文件的相对地址：参照物不是当前文件，而是node的启动路径。</p>
<p>写入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">fs.writeFile(<span class="hljs-string">&quot;文件路径&quot;</span>,<span class="hljs-string">&quot;写入内容&quot;</span>,<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;&#125;)<span class="hljs-comment">//覆盖之前内容</span><br>fs.writeFileSync()<br><br></code></pre></td></tr></table></figure>

<p>追加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">fs.appendFile(<span class="hljs-string">&quot;文件路径&quot;</span>,<span class="hljs-string">&quot;写入内容&quot;</span>,<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;&#125;)<br>fs.appendFileSync(path,data)<br><br></code></pre></td></tr></table></figure>

<p>异步通过err形参接收错误信息</p>
<p>同步如果发生错误直接报异常，程序可能中断</p>
<p>写入文件的方法，当文件名不存在的时候，会自动创建文件，如果文件夹也不存在会报错</p>
<p>修改文件方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">fs.rename(<span class="hljs-string">&#x27;oldpath&#x27;</span>,<span class="hljs-string">&#x27;newpath&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;&#125;)<br>fs.renameSync(<span class="hljs-string">&quot;oldpath&quot;</span>,<span class="hljs-string">&quot;newpath&quot;</span>)<br><br></code></pre></td></tr></table></figure>

<p>删除文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">fs.unlink(path,<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;&#125;)<br>fs.unlinkSync(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br></code></pre></td></tr></table></figure>

<p>创建文件夹</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">fs.mkdir(path,<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;&#125;)<br><br></code></pre></td></tr></table></figure>

<p>读取目录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">fs.readdir(path,<span class="hljs-function">(<span class="hljs-params">err,files</span>)=&gt;</span>&#123;&#125;)<br><br></code></pre></td></tr></table></figure>

<p>删除目录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">fs.rmdir(path,<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;&#125;)<br><br></code></pre></td></tr></table></figure>

<p>读取文件流</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-comment">//对于某个文件创建一个读取流</span><br><span class="hljs-keyword">var</span> readStream = fs.createReadStream(<span class="hljs-string">&quot;fs.js&quot;</span>);<br><span class="hljs-comment">//设置读取流的编码</span><br>readStream.setEncoding(<span class="hljs-string">&#x27;utf-8&#x27;</span>);<br><span class="hljs-comment">//绑定一个事件（data事件名）</span><br><span class="hljs-comment">//data这个事件，每次读取一个小块内容的时候，都会触发data事件；</span><br><span class="hljs-comment">//在回调函数中，能够设置一个形参chunk，接收每次读取那一小块内容；</span><br><span class="hljs-keyword">var</span> data = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<br>readStream.on(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> &#123;<br>    data += chunk;<br>    <span class="hljs-built_in">console</span>.log(++index);<br>&#125;)<br><span class="hljs-comment">//end事件代表所有内容读取完成</span><br>readStream.on(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">//这里代表data里面才是完整的数据</span><br>    <span class="hljs-built_in">console</span>.log(data);<br>&#125;)<br><br></code></pre></td></tr></table></figure>

<p>写入文件流</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">var</span> writeStream = fs.createWriteStream(<span class="hljs-string">&quot;fs1.txt&quot;</span>);<br>writeStream.write(<span class="hljs-string">&quot;aaaaaaa&quot;</span>, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>writeStream.write(<span class="hljs-string">&quot;bbbbbbb&quot;</span>, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>writeStream.end();<br>writeStream.on(<span class="hljs-string">&quot;finish&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;finish&quot;</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure>

<p>管道流</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">var</span> readS = fs.createReadStream(<span class="hljs-string">&quot;fs.txt&quot;</span>);<br><span class="hljs-keyword">var</span> ws = fs.createWriteStream(<span class="hljs-string">&quot;fs1.txt&quot;</span>);<br>readS.pipe(ws);<span class="hljs-comment">//把读取流和写入流连接起来，把读取的内容直接写入fs1.txt</span><br><br></code></pre></td></tr></table></figure>

<h2 id="web应用架构"><a href="#web应用架构" class="headerlink" title="web应用架构"></a>web应用架构</h2><p>client-客户端，一般指浏览器，浏览器可以通过http协议向服务器请求数据。</p>
<p>server-服务端，一般指web服务器，可以接收客户请求，并向客户端发送响应数据。</p>
<h5 id="http-server"><a href="#http-server" class="headerlink" title="http server"></a>http server</h5><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//支持web服务的http</span><br><br>*<span class="hljs-keyword">const</span>* http=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><br>*<span class="hljs-keyword">let</span>* count=<span class="hljs-number">0</span><br><br><span class="hljs-comment">//创建一个服务,如果有url访问到了这个服务，回调函数执行</span><br><br><span class="hljs-comment">// 回调函数中，第一个形参request代表的是请求对象，里面存放了请求信息</span><br><br><span class="hljs-comment">// 第二个参数response：响应对象</span><br><br>*<span class="hljs-keyword">var</span>* serve=http.createServer((*request*,*response*)*=&gt;*&#123;<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;有人访问&#x27;</span>+(++count))<br><br>  <span class="hljs-comment">//设置响应头；200是成功 编码 类型</span><br><br>  *response*.writeHead(<span class="hljs-number">200</span>,&#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>:<span class="hljs-string">&#x27;text/html;charset=utf-8&#x27;</span>&#125;)<br><br>  <span class="hljs-comment">// 响应对象中添加数据</span><br><br>  *response*.write(<span class="hljs-string">&#x27;我是相应内容&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>  <span class="hljs-comment">// 结束</span><br><br>  *response*.end()<br><br>&#125;)<br><br><span class="hljs-comment">// 把服务监听3000端口</span><br><br>serve.listen(<span class="hljs-string">&#x27;3000&#x27;</span>,(*err*)*=&gt;*&#123;<br><br>  <span class="hljs-keyword">if</span>(*err*) <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(*err*)<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;serve listen at 3000&#x27;</span>)<br><br>&#125;)<br><br><span class="hljs-comment">// url ：http：协议</span><br><br><span class="hljs-comment">// 域名：或者 ip DFS服务器</span><br><br><span class="hljs-comment">// 端口：80默认</span><br><br></code></pre></td></tr></table></figure>

<h5 id="http"><a href="#http" class="headerlink" title="http"></a>http</h5><p>http域名或者IP</p>
<p>端口号</p>
<p>相对路径</p>
<h5 id="nodejs-http-server"><a href="#nodejs-http-server" class="headerlink" title="nodejs http server"></a>nodejs http server</h5><p>加载http包</p>
<p>http.createServer((request,response)=&gt;{</p>
<p>回调函数</p>
<p>request：请求对象</p>
<p>response：响应对象</p>
<p>server.listen(‘3000’)</p>
<p>})</p>
<h5 id="http工作原理-过程"><a href="#http工作原理-过程" class="headerlink" title="http工作原理  (过程)"></a>http工作原理  (过程)</h5><ul>
<li><p>1  客户端连接到web服务器</p>
</li>
<li><p>2  发送http请求</p>
</li>
<li><p>3   服务器接收解释请求并返回http响应</p>
</li>
<li><p>4  释放连接tcp连接</p>
</li>
</ul>
<h5 id="path"><a href="#path" class="headerlink" title="path"></a>path</h5><ul>
<li>专注于文件路径</li>
</ul>
<h5 id="url"><a href="#url" class="headerlink" title="url"></a>url</h5><ul>
<li>专注于处理url地址</li>
</ul>
<h5 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h5><ul>
<li>专注于url中使用get请求后面解析参数</li>
</ul>
<h5 id="解析url"><a href="#解析url" class="headerlink" title="解析url"></a>解析url</h5><blockquote>
<p>new  URL(request.url,’http://${request.headers.host}’)</p>
</blockquote>
<h5 id="get-set"><a href="#get-set" class="headerlink" title="get   set"></a>get   set</h5><ul>
<li>get 参数，是拼接在url后面；post参数body</li>
<li>浏览器地址栏中访问的url</li>
</ul>
<h5 id="nodejs区分get-post"><a href="#nodejs区分get-post" class="headerlink" title="nodejs区分get post"></a>nodejs区分get post</h5><p>request.method</p>
<p>nodejs 从get  post  获取参数数据</p>
<ul>
<li>get  获取参数  分析url  </li>
<li>post获取参数</li>
</ul>
<h5 id="创建express项目"><a href="#创建express项目" class="headerlink" title="创建express项目"></a>创建express项目</h5><ul>
<li>安装一个创建express项目的工具（express生成器）–express-generator</li>
</ul>
<p>安装命令：</p>
<blockquote>
<p>npm install express-generator -g</p>
</blockquote>
<p>全局安装：</p>
<ul>
<li>使用这个工具生成一个express项目</li>
</ul>
<p>命令是：</p>
<blockquote>
<p>express –view=ejs myprogramName </p>
</blockquote>
<ul>
<li><p>myprogramName是项目的名字</p>
</li>
<li><p>–view=ejs 设置项目的页面使用的模板引擎；设置模版引擎为ejs pug</p>
</li>
<li><p>创建完成项目文件之后； </p>
</li>
<li><p>cd myprogramName 命令窗口前面的路径定位到项目文件</p>
</li>
<li><p>D:\work\Lesson\202002\2-165\Day08\my1</p>
</li>
</ul>
<blockquote>
<p>npm i </p>
</blockquote>
<p>会在my1这个文件夹下寻找package.json，获取dependencies里面的包；并且全部安装；</p>
<ul>
<li>启动项目</li>
</ul>
<blockquote>
<p>SET DEBUG=my1:* &amp; npm start</p>
</blockquote>
<ul>
<li>默认是在3000端口号： localhost:3000 127.0.0.1:3000</li>
</ul>
<h5 id="项目文件："><a href="#项目文件：" class="headerlink" title="项目文件："></a>项目文件：</h5><ul>
<li><p>bin/www 可以修改服务的端口号：</p>
</li>
<li><p>node_modules 所有局部安装的包</p>
</li>
<li><p>pulic 存放静态文件的；</p>
</li>
<li><p>routes 路由</p>
</li>
<li><p>views 页面</p>
</li>
<li><p>app.js 启动js</p>
</li>
<li><p>package.json npm配置文件</p>
</li>
</ul>
<p>npm i 就是安装的dependencies下的包</p>
<p>npm start 就是运行的scripts下面start命令</p>
<h5 id="app-js-文件"><a href="#app-js-文件" class="headerlink" title="app.js 文件"></a>app.js 文件</h5><h5 id="路由："><a href="#路由：" class="headerlink" title="路由："></a>路由：</h5><ul>
<li><p>在routes文件夹下 写路由文件</p>
</li>
<li><p>app.js中启用路由：</p>
</li>
</ul>
<h5 id="响应返回页面"><a href="#响应返回页面" class="headerlink" title="响应返回页面"></a>响应返回页面</h5><p>在路由中，使用res.render(“list”)；</p>
<p>-页面必须放在views下；而且后缀名必须是.ejs</p>
<h5 id="怎么获取url传递的数据："><a href="#怎么获取url传递的数据：" class="headerlink" title="怎么获取url传递的数据："></a>怎么获取url传递的数据：</h5><ul>
<li><p>get 参数: 在路由 req.query 属性，存放了所有get请求的参数：</p>
</li>
<li><p>post 数据 req.body 存储</p>
</li>
</ul>
<h5 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h5><p>req.params</p>
<h5 id="路由的路径是可以用正则表达式"><a href="#路由的路径是可以用正则表达式" class="headerlink" title="路由的路径是可以用正则表达式"></a>路由的路径是可以用正则表达式</h5><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><ul>
<li><p>npm i express-generator -g 如果安装过了，不用再安装</p>
</li>
<li><p>生成一个项目</p>
</li>
</ul>
<blockquote>
<p>express –view=ejs xiaou</p>
</blockquote>
<blockquote>
<p>cd xiaou</p>
</blockquote>
<blockquote>
<p>npm i </p>
</blockquote>
<blockquote>
<p>npm start</p>
</blockquote>
<ul>
<li><p>把index.html复制到views，并且要ejs后缀；</p>
</li>
<li><p>设计一个路由： 设计url地址；访问这个url，</p>
</li>
<li><p>routes文件夹下创建一个新的路由文件index.js</p>
</li>
</ul>
<h5 id="node-js-1"><a href="#node-js-1" class="headerlink" title="node.js"></a>node.js</h5><ul>
<li>单线程</li>
<li>非阻塞</li>
<li>事件驱动</li>
</ul>
<h5 id="模块化commonJS"><a href="#模块化commonJS" class="headerlink" title="模块化commonJS"></a>模块化commonJS</h5><ul>
<li>定义模块：</li>
</ul>
<p>modules.exporys{}</p>
<p>modules.exporys.xxx=xx</p>
<p>exports.xxx=xx</p>
<ul>
<li>加载模块：</li>
</ul>
<p>通过js（模块）的加载路径：</p>
<p>const mymoudule=require(‘模块’)</p>
<p>通过js（模块）的标识：核心模块（nodejs自带的    ）</p>
<p>const http=require(‘http’)</p>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><ul>
<li>初始化</li>
<li>绑定事件</li>
<li>触发事件</li>
<li>传值：</li>
</ul>
<h5 id="npm-1"><a href="#npm-1" class="headerlink" title="npm"></a>npm</h5><ul>
<li>包：</li>
<li>全局安装    -g   本地安装</li>
<li>依赖   和   开发依赖：</li>
</ul>
<p>依赖：express   简写–save    -S</p>
<p>开发依赖：less  简写  –save-dev   -D</p>
<h5 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h5><h5 id="nodejs-http"><a href="#nodejs-http" class="headerlink" title="nodejs  http"></a>nodejs  http</h5><ul>
<li><p><a href="http://www.ddd.com/">http://www.ddd.com:80</a>   默认是80</p>
<h5 id="http四个步骤："><a href="#http四个步骤：" class="headerlink" title="http四个步骤："></a>http四个步骤：</h5><ul>
<li>客户端向服务端发起的连接</li>
<li>客户端向服务器发送的数据</li>
<li>服务器响应客户端</li>
<li>客户端结束连接</li>
</ul>
<h5 id="nodejs下的一些小模块"><a href="#nodejs下的一些小模块" class="headerlink" title="nodejs下的一些小模块"></a>nodejs下的一些小模块</h5><ul>
<li>path</li>
<li>url</li>
<li>queryString</li>
</ul>
<h5 id="express"><a href="#express" class="headerlink" title="express"></a>express</h5><p>基于nodejs的一个web开发框架：</p>
<h5 id="创建esperss项目的步骤"><a href="#创建esperss项目的步骤" class="headerlink" title="创建esperss项目的步骤"></a>创建esperss项目的步骤</h5><ul>
<li>全局安装espress项目生成器</li>
</ul>
</li>
</ul>
<p>命令：npm i express-generator -g</p>
<p>创建express项目的基础框架</p>
<blockquote>
<p>express –view=ejs xiaou</p>
</blockquote>
<blockquote>
<p>cd xiaou</p>
</blockquote>
<blockquote>
<p>npm i </p>
</blockquote>
<blockquote>
<p>npm start</p>
</blockquote>
<h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><p>在routes创建新的路由文件product.js</p>
<p>路由地址的匹配</p>
<p>正则</p>
<p>动态路由</p>
<h5 id="路由返回数据"><a href="#路由返回数据" class="headerlink" title="路由返回数据"></a>路由返回数据</h5><ul>
<li>字符串：res.send()</li>
<li>页面：res.render(‘文件路径’)；文件夹是是固定的views文件夹</li>
<li>json  res.json({})</li>
</ul>
<h5 id="中间件："><a href="#中间件：" class="headerlink" title="中间件："></a>中间件：</h5><p>每个请求都会经过中间件的检查过滤</p>
<p>1、中间件就是一种功能的封装方式，就是封装在程序中处理http请求的功能，  </p>
<p>2、中间件是在管道中执行</p>
<p>3、中间件有一个next()函数，如果不调用next函数，请求就在这个中间件中终止了，</p>
<p>4、中间件和路由处理器的参数中都有回调函数，这个函数有2,3,4个参数</p>
<p>如果有两个参数就是req和res；</p>
<p>如果有三个参数就是req,res和next</p>
<p>如果有四个参数就是err，req，res，next</p>
<p>5、如果不调用next ，管道就会终止，不会再有处理器做后续响应，应该向客户端发送一个响应</p>
<p>6、如果调用了next，不应该发送响应到客户端，如果发送了，则后面发送的响应都会被忽略</p>
<p>7、中间件的第一个参数可以是路径，如果忽略则全部都匹配</p>
<h5 id="ejs"><a href="#ejs" class="headerlink" title="ejs"></a>ejs</h5><p>res.render(‘页面的相对路径‘，data)  第二个参数是数据。传递给页面    的数据</p>
<p>第二个参数是传递给页面中的模板引擎数据</p>
<p>模板引擎中的语法</p>
<p>&lt;%# 注释%&gt;</p>
<h5 id="art-template-模板引擎"><a href="#art-template-模板引擎" class="headerlink" title="art -template  模板引擎"></a>art -template  模板引擎</h5><ul>
<li><p>espress项目中，使用arttemplate模板引擎</p>
</li>
<li><p>安装arttemplate包和express下的支持包</p>
</li>
<li><p>npm  i art - template  -S</p>
</li>
<li><p>npm  i express-art - template  -S</p>
</li>
</ul>
<h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2><ul>
<li>数据库：存储文件：</li>
<li>MySQl:服务类的程序：</li>
</ul>
<h3 id="常见数据库"><a href="#常见数据库" class="headerlink" title="常见数据库"></a>常见数据库</h3><ul>
<li>Oracle</li>
<li>mysql</li>
<li>ms sql server</li>
<li>mongodb</li>
</ul>
<h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><ul>
<li>关系数据库</li>
<li>非关系数据库</li>
</ul>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><ul>
<li>第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项</li>
<li>第二范式（2NF）：在1NF的基础上，非主键属性必须完全依赖于主键</li>
<li>第三范式（3NF）：在2NF基础上，任何非主键属性不依赖于其它非主键属性（在2NF基础上消除传递依赖）</li>
<li>反范式：</li>
</ul>
<h3 id="mysql-语法：sql语法"><a href="#mysql-语法：sql语法" class="headerlink" title="mysql 语法：sql语法"></a>mysql 语法：sql语法</h3><ul>
<li>DDL  DML</li>
</ul>
<h3 id="数据库：database"><a href="#数据库：database" class="headerlink" title="数据库：database"></a>数据库：database</h3><pre><code>-   创建数据库：
&gt;create database if not exists xiaou ;</code></pre>
<h3 id="表：table"><a href="#表：table" class="headerlink" title="表：table"></a>表：table</h3><ul>
<li>创建表：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`xiaou`</span>.<span class="hljs-string">`user`</span> (<br>  <span class="hljs-string">`cardid`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`name`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`age`</span> <span class="hljs-built_in">INT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`address`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`height`</span> <span class="hljs-built_in">FLOAT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`createby`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`createtime`</span> <span class="hljs-built_in">DATE</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`updateby`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-string">`updatetime`</span> <span class="hljs-built_in">DATE</span> <span class="hljs-literal">NULL</span>,<br>  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`cardid`</span>));<br><br><br></code></pre></td></tr></table></figure>

<ul>
<li>修改表：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`xiaou`</span>.<span class="hljs-string">`user`</span> <br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">`disc`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-literal">NULL</span> <span class="hljs-keyword">AFTER</span> <span class="hljs-string">`tel`</span>;<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`xiaou`</span>.<span class="hljs-string">`user`</span> <br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">`disc`</span>;<br><br><br></code></pre></td></tr></table></figure>

<h3 id="删除表、删除数据库"><a href="#删除表、删除数据库" class="headerlink" title="删除表、删除数据库"></a>删除表、删除数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> stud;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> ujiuye;<br><br><br></code></pre></td></tr></table></figure>

<h3 id="中文："><a href="#中文：" class="headerlink" title="中文："></a>中文：</h3><p>修改字段编码为urf8  ;utf8-general-ci;</p>
<h3 id="插入数据："><a href="#插入数据：" class="headerlink" title="插入数据："></a>插入数据：</h3><ul>
<li><p>insert into </p>
</li>
<li><p>格式<br><strong>全部列添加数据：</strong><br>insert into table_name (id,name,age,<code>drop</code>) values(10,’zs’,100,’eer’);<br>如果对所有的列添加数据： 前面的（列名、）是可以省略的；<br>insert into table_name values(10,’zs’,100,’eer’);</p>
</li>
</ul>
<p><strong>部分列添加数据：</strong><br>insert into table_name (id,name) values(10,’zs’);</p>
<h3 id="修改数据："><a href="#修改数据：" class="headerlink" title="修改数据："></a>修改数据：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> xiaou.user <span class="hljs-keyword">set</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">&#x27;zs2000&#x27;</span>,age=<span class="hljs-number">2000</span> <span class="hljs-keyword">where</span> address=<span class="hljs-string">&#x27;上海&#x27;</span>;<br><br><br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Python基础</title>
    <url>/2021/03/18/python/</url>
    <content><![CDATA[<h5 id="Python-中文编码"><a href="#Python-中文编码" class="headerlink" title="Python 中文编码"></a>Python 中文编码</h5><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br>文件开头加入 <span class="hljs-comment"># -*- coding: UTF-8 -*- 或者 # coding=utf-8</span><br><br>print(<span class="hljs-string">&#x27;你好&#x27;</span>) <span class="hljs-comment">#输出你好</span><br><br><span class="hljs-comment"># #号键即是注释</span><br></code></pre></td></tr></table></figure>

<h5 id="变量类型和运算符"><a href="#变量类型和运算符" class="headerlink" title="变量类型和运算符"></a>变量类型和运算符</h5><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">name = value<br><span class="hljs-comment"># Python 使用等号=作为赋值运算符</span><br><span class="hljs-comment"># name 表示变量名；value 表示值，也就是要存储的数据</span><br><span class="hljs-comment"># Python 是弱类型的语言</span><br></code></pre></td></tr></table></figure>



<h5 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h5><p>计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。</p>
<p>比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用<code>if</code>语句实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">20</span><br><span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">18</span>:<br>    print(<span class="hljs-string">&#x27;your age is&#x27;</span>, age)<br>    print(<span class="hljs-string">&#x27;adult&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>根据Python的缩进规则，如果<code>if</code>语句判断是<code>True</code>，就把缩进的两行print语句执行了，否则，什么也不做。</p>
<p>也可以给<code>if</code>添加一个<code>else</code>语句，意思是，如果<code>if</code>判断是<code>False</code>，不要执行<code>if</code>的内容，去把<code>else</code>执行了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">3</span><br><span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">18</span>:<br>    print(<span class="hljs-string">&#x27;your age is&#x27;</span>, age)<br>    print(<span class="hljs-string">&#x27;adult&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">&#x27;your age is&#x27;</span>, age)<br>    print(<span class="hljs-string">&#x27;teenager&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>注意不要少写了冒号<code>:</code>。</p>
<p>当然上面的判断是很粗略的，完全可以用<code>elif</code>做更细致的判断：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">3</span><br><span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">18</span>:<br>    print(<span class="hljs-string">&#x27;adult&#x27;</span>)<br><span class="hljs-keyword">elif</span> age &gt;= <span class="hljs-number">6</span>:<br>    print(<span class="hljs-string">&#x27;teenager&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">&#x27;kid&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p><code>elif</code>是<code>else if</code>的缩写，完全可以有多个<code>elif</code>，所以<code>if</code>语句的完整形式就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> &lt;条件判断<span class="hljs-number">1</span>&gt;:<br>    &lt;执行<span class="hljs-number">1</span>&gt;<br><span class="hljs-keyword">elif</span> &lt;条件判断<span class="hljs-number">2</span>&gt;:<br>    &lt;执行<span class="hljs-number">2</span>&gt;<br><span class="hljs-keyword">elif</span> &lt;条件判断<span class="hljs-number">3</span>&gt;:<br>    &lt;执行<span class="hljs-number">3</span>&gt;<br><span class="hljs-keyword">else</span>:<br>    &lt;执行<span class="hljs-number">4</span>&gt;<br></code></pre></td></tr></table></figure>

<p><code>if</code>语句执行有个特点，它是从上往下判断，如果在某个判断上是<code>True</code>，把该判断对应的语句执行后，就忽略掉剩下的<code>elif</code>和<code>else</code>，所以，请测试并解释为什么下面的程序打印的是<code>teenager</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">age &#x3D; 20<br>if age &gt;&#x3D; 6:<br>    print(&#39;teenager&#39;)<br>elif age &gt;&#x3D; 18:<br>    print(&#39;adult&#39;)<br>else:<br>    print(&#39;kid&#39;)<br></code></pre></td></tr></table></figure>

<p><code>if</code>判断条件还可以简写，比如写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> x:<br>    print(<span class="hljs-string">&#x27;True&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>只要<code>x</code>是非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code>。</p>
<h3 id="再议-input"><a href="#再议-input" class="headerlink" title="再议 input"></a>再议 input</h3><p>最后看一个有问题的条件判断。很多同学会用<code>input()</code>读取用户的输入，这样可以自己输入，程序运行得更有意思：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">birth = input(<span class="hljs-string">&#x27;birth: &#x27;</span>)<br><span class="hljs-keyword">if</span> birth &lt; <span class="hljs-number">2000</span>:<br>    print(<span class="hljs-string">&#x27;00前&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">&#x27;00后&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>输入<code>1982</code>，结果报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: unorderable types: str() &gt; int()<br></code></pre></td></tr></table></figure>

<p>这是因为<code>input()</code>返回的数据类型是<code>str</code>，<code>str</code>不能直接和整数比较，必须先把<code>str</code>转换成整数。Python提供了<code>int()</code>函数来完成这件事情：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s = input(<span class="hljs-string">&#x27;birth: &#x27;</span>)<br>birth = int(s)<br><span class="hljs-keyword">if</span> birth &lt; <span class="hljs-number">2000</span>:<br>    print(<span class="hljs-string">&#x27;00前&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">&#x27;00后&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>再次运行，就可以得到正确地结果。但是，如果输入<code>abc</code>呢？又会得到一个错误信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>ValueError: invalid literal <span class="hljs-keyword">for</span> int() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure>

<p>原来<code>int()</code>函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。</p>
<h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><p>要计算1+2+3，我们可以直接写表达式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span><br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<p>要计算1+2+3+…+10，勉强也能写出来。</p>
<p>但是，要计算1+2+3+…+10000，直接写表达式就不可能了。</p>
<p>为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。</p>
<p>Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，看例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">names = [<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Tracy&#x27;</span>]<br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names:<br>    print(name)<br></code></pre></td></tr></table></figure>

<p>执行这段代码，会依次打印<code>names</code>的每一个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">Michael<br>Bob<br>Tracy<br></code></pre></td></tr></table></figure>

<p>所以<code>for x in ...</code>循环就是把每个元素代入变量<code>x</code>，然后执行缩进块的语句。</p>
<p>再比如我们想计算1-10的整数之和，可以用一个<code>sum</code>变量做累加：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">sum = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]:<br>    sum = sum + x<br>print(sum)<br></code></pre></td></tr></table></figure>

<p>如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个<code>range()</code>函数，可以生成一个整数序列，再通过<code>list()</code>函数可以转换为list。比如<code>range(5)</code>生成的序列是从0开始小于5的整数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>list(range(<span class="hljs-number">5</span>))<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure>

<p><code>range(101)</code>就可以生成0-100的整数序列，计算如下：</p>
<p><code># -*- coding: utf-8 -*- </code> Run</p>
<p>请自行运行上述代码，看看结果是不是当年高斯同学心算出的5050。</p>
<p>第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">sum = <span class="hljs-number">0</span><br>n = <span class="hljs-number">99</span><br><span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>    sum = sum + n<br>    n = n - <span class="hljs-number">2</span><br>print(sum)<br></code></pre></td></tr></table></figure>

<p>在循环内部变量<code>n</code>不断自减，直到变为<code>-1</code>时，不再满足while条件，循环退出。</p>
<p>第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">sum = <span class="hljs-number">0</span><br>n = <span class="hljs-number">99</span><br><span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>    sum = sum + n<br>    n = n - <span class="hljs-number">2</span><br>print(sum)<br></code></pre></td></tr></table></figure>

<p>在循环内部变量<code>n</code>不断自减，直到变为<code>-1</code>时，不再满足while条件，循环退出。</p>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>在循环中，<code>break</code>语句可以提前退出循环。例如，本来要循环打印1～100的数字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> n &lt;= <span class="hljs-number">100</span>:<br>    print(n)<br>    n = n + <span class="hljs-number">1</span><br>print(<span class="hljs-string">&#x27;END&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>上面的代码可以打印出1~100。</p>
<p>如果要提前结束循环，可以用<code>break</code>语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> n &lt;= <span class="hljs-number">100</span>:<br>    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">10</span>: <span class="hljs-comment"># 当n = 11时，条件满足，执行break语句</span><br>        <span class="hljs-keyword">break</span> <span class="hljs-comment"># break语句会结束当前循环</span><br>    print(n)<br>    n = n + <span class="hljs-number">1</span><br>print(<span class="hljs-string">&#x27;END&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>执行上面的代码可以看到，打印出1~10后，紧接着打印<code>END</code>，程序结束。</p>
<p>可见<code>break</code>的作用是提前结束循环。</p>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>在循环过程中，也可以通过<code>continue</code>语句，跳过当前的这次循环，直接开始下一次循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">10</span>:<br>    n = n + <span class="hljs-number">1</span><br>    print(n)<br></code></pre></td></tr></table></figure>

<p>上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用<code>continue</code>语句跳过某些循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">10</span>:<br>    n = n + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>: <span class="hljs-comment"># 如果n是偶数，执行continue语句</span><br>        <span class="hljs-keyword">continue</span> <span class="hljs-comment"># continue语句会直接继续下一轮循环，后续的print()语句不会执行</span><br>    print(n)<br></code></pre></td></tr></table></figure>

<p>执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。</p>
<p>可见<code>continue</code>的作用是提前结束本轮循环，并直接开始下一轮循环。</p>
]]></content>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3源码-Set、Map、WeakSet、WeakMap</title>
    <url>/2021/03/18/vu3%E6%BA%90%E7%A0%812/</url>
    <content><![CDATA[<h3 id="Set、Map、WeakSet、WeakMap"><a href="#Set、Map、WeakSet、WeakMap" class="headerlink" title="Set、Map、WeakSet、WeakMap"></a>Set、Map、WeakSet、WeakMap</h3><p>如果要用一句来描述，我们可以说 <strong>Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构</strong></p>
<p>那什么是集合？什么又是字典呢？</p>
<ul>
<li>集合</li>
</ul>
<blockquote>
<p>集合，是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合</p>
</blockquote>
<ul>
<li>字典</li>
</ul>
<blockquote>
<p>字典（dictionary）是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同</p>
</blockquote>
<p>那么集合和字典又有什么区别呢？</p>
<ul>
<li>共同点：集合、字典都可以存储不重复的值</li>
<li>不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储</li>
</ul>
<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>大多数主流编程语言都有多种内置的数据集合。例如<code>Python</code>拥有列表（<code>list</code>）、元组（<code>tuple</code>）和字典（<code>dictionary</code>）,Java有列表（<code>list</code>）、集合（<code>set</code>)、队列（<code>queue</code>）</p>
<p>然而 <code>JavaScript</code> 直到<code>ES6</code>的发布之前，只拥有数组（<code>array</code>）和对象（<code>object</code>）这两个内建的数据集合</p>
<p>在 <code>ES6</code> 之前,我们通常使用内置的 <code>Object</code> 模拟Map</p>
<p>但是这样模拟出来的<code>map</code>会有一些缺陷，如下:</p>
<ol>
<li><code>Object</code>的属性键是<code>String</code>或<code>Symbol</code>，这限制了它们作为不同数据类型的键/值对集合的能力</li>
<li><code>Object</code>不是设计来作为一种数据集合，因此没有直接有效的方法来确定对象具有多少属性</li>
</ol>
<h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><blockquote>
<p><code>Set</code> 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用，<code>Set</code>对象是值的集合，你可以按照插入的顺序迭代它的元素。 <code>Set</code>中的元素只会出现一次，即 <code>Set</code> 中的元素是唯一的</p>
</blockquote>
<p><code>Set</code>本身是一个构造函数，用来生成 <code>Set</code> 数据结构</p>
<h5 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h5><ul>
<li>语法<br><code>new Set([iterable])</code> 接收一个数组（或者具有 iterable 接口的其他数据结构）, 返回一个新的<code>Set</code>对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> set=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br><span class="hljs-built_in">console</span>.log(set)<span class="hljs-comment">//&#123;1,2&#125;</span><br></code></pre></td></tr></table></figure>

<p>所以说Set可以做到数组去重</p>
<h5 id="属性和方法："><a href="#属性和方法：" class="headerlink" title="属性和方法："></a>属性和方法：</h5><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]).size) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<p><strong>操作方法</strong></p>
<ul>
<li>add(value): 向集合中添加一个新的项</li>
<li>delete(value): 从集合中删除一个值</li>
<li>has(value): 如果值在集合中存在，返回ture, 否则返回false</li>
<li>clear(): 移除集合中的所有项</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()<br>set.add(<span class="hljs-number">1</span>)<br>set.add(<span class="hljs-number">2</span>)<br>set.add(<span class="hljs-number">2</span>)<br>set.add(<span class="hljs-number">3</span>)<br><span class="hljs-built_in">console</span>.log(set) <span class="hljs-comment">// &#123;1,2,3&#125;</span><br>set.has(<span class="hljs-number">2</span>) <span class="hljs-comment">// true</span><br>set.delete(<span class="hljs-number">2</span>)  <br>set.has(<span class="hljs-number">2</span>) <span class="hljs-comment">// false</span><br>set.clear() <br></code></pre></td></tr></table></figure>

<p><strong>遍历方法</strong></p>
<ul>
<li>keys(): 返回键名的遍历器</li>
<li>values(): 返回键值的遍历器</li>
<li>entries(): 返回键值对的遍历器</li>
<li>forEach(): 使用回调函数遍历每个成员</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br><br><span class="hljs-comment">// 由于set只有键值，没有键名，所以keys() values()行为完全一致</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(set.keys())) <span class="hljs-comment">// [1,2,3,4]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(set.values())) <span class="hljs-comment">// [1,2,3,4]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(set.entries())) <span class="hljs-comment">//  [[1,1],[2,2],[3,3],[4,4]]</span><br><br>set.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(item)&#125;) <span class="hljs-comment">// 1,2,3,4</span><br></code></pre></td></tr></table></figure>

<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>因为 <code>Set</code> 结构的值是唯一的，我们可以很轻松的实现以下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> unique = [... new <span class="hljs-built_in">Set</span>(arr)];<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]);<br>    <br><span class="hljs-comment">// 并集</span><br><span class="hljs-keyword">let</span> union = [...new <span class="hljs-built_in">Set</span>([...a, ...b])]; <span class="hljs-comment">// [1,2,3,4]</span><br>    <br><span class="hljs-comment">// 交集</span><br><span class="hljs-keyword">let</span> intersect = [...new <span class="hljs-built_in">Set</span>([...a].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> b.has(x)))]; [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>    <br><span class="hljs-comment">// 差集</span><br><span class="hljs-keyword">let</span> difference = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...a].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !b.has(x)))); [<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><blockquote>
<p>WeakSet 对象是一些对象值的集合, 并且其中的每个对象值都只能出现一次。在WeakSet的集合中是唯一的</p>
</blockquote>
<p><code>WeakSet</code> 的出现主要解决弱引用对象存储的场景, 其结构与<code>Set</code>类似</p>
<p>与<code>Set</code>的区别</p>
<ul>
<li>与Set相比，WeakSet 只能是对象的集合，而不能是任何类型的任意值</li>
<li>WeakSet集合中对象的引用为弱引用。 如果没有其他的对WeakSet中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着WeakSet中没有存储当前对象的列表。 正因为这样，WeakSet 是不可枚举的</li>
</ul>
<p><code>WeakSet</code> 的属性跟操作方法与 <code>Set</code> 一致，不同的是 <code>WeakSet</code> 没有遍历方法，因为其成员都是弱引用，弱引用随时都会消失，遍历机制无法保证成员的存在</p>
<p><strong>上面一直有提到弱引用，那弱引用到底是指什么呢？</strong></p>
<blockquote>
<p>弱引用是指不能确保其引用的对象不会被垃圾回收器回收的引用，换句话说就是可能在任意时间被回收</p>
</blockquote>
<p>基本跟 <code>Set</code> 类似，同样具有如下方法 <strong>属性</strong></p>
<ul>
<li>size: 返回 Map 结构的元素总数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>map.set(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;vuejs.cn&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(map.size) <span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;vue3js.cn&#x27;</span>], [<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-string">&#x27;18&#x27;</span>]]).size) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<p><strong>操作方法</strong></p>
<ul>
<li>set(key, value): 向 Map 中加入或更新键值对</li>
<li>get(key): 读取 key 对用的值，如果没有，返回 undefined</li>
<li>has(key): 某个键是否在 Map 对象中，在返回 true 否则返回 false</li>
<li>delete(key): 删除某个键，返回 true, 如果删除失败返回 false</li>
<li>clear(): 删除所有元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>map.set(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;vue3js.cn&#x27;</span>)<br>map.set(<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-string">&#x27;18&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(map) <span class="hljs-comment">// Map &#123;&quot;name&quot; =&gt; &quot;vuejs.cn&quot;, &quot;age&quot; =&gt; &quot;18&quot;&#125;</span><br>map.get(<span class="hljs-string">&#x27;name&#x27;</span>) <span class="hljs-comment">// vue3js.cn </span><br>map.has(<span class="hljs-string">&#x27;name&#x27;</span>) <span class="hljs-comment">// true</span><br>map.delete(<span class="hljs-string">&#x27;name&#x27;</span>)  <br>map.has(name) <span class="hljs-comment">// false</span><br>map.clear() <span class="hljs-comment">// Map &#123;&#125; </span><br></code></pre></td></tr></table></figure>

<p><strong>遍历方法</strong></p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回所有成员的遍历器</li>
<li>forEach()：遍历 Map 的所有成员</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>map.set(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;vue3js.cn&#x27;</span>)<br>map.set(<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-string">&#x27;18&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log([...map.keys()])  <span class="hljs-comment">// [&quot;name&quot;, &quot;age&quot;]</span><br><span class="hljs-built_in">console</span>.log([...map.values()])  <span class="hljs-comment">// [&quot;vue3js.cn&quot;, &quot;18&quot;]</span><br><span class="hljs-built_in">console</span>.log([...map.entries()]) <span class="hljs-comment">// [[&#x27;name&#x27;,&#x27;vue3js.cn&#x27;], [&#x27;age&#x27;,&#x27;18&#x27;]]</span><br><br><span class="hljs-comment">// name vuejs.cn</span><br><span class="hljs-comment">// age 18</span><br>map.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(key, value)&#125;) <br></code></pre></td></tr></table></figure>

<h5 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h5><p><code>Map</code> 会保留所有元素的顺序, 是在基于可迭代的基础上构建的，如果考虑到元素迭代或顺序保留或键值类型丰富的情况下都可以使用，下面摘抄自 <code>vue3</code> 源码中依赖收集的核心实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> depsMap = targetMap.get(target)<br><span class="hljs-keyword">if</span> (!depsMap) &#123;<br>  targetMap.set(target, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()))<br>&#125;<br><span class="hljs-keyword">let</span> dep = depsMap.get(key)<br><span class="hljs-keyword">if</span> (!dep) &#123;<br>  depsMap.set(key, (dep = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()))<br>&#125;<br><span class="hljs-keyword">if</span> (!dep.has(activeEffect)) &#123;<br>  dep.add(activeEffect)<br>  activeEffect.deps.push(dep)<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h5><blockquote>
<p>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的</p>
</blockquote>
<p>与<code>Map</code>的区别</p>
<ul>
<li>Map 的键可以是任意类型，WeakMap 的键只能是对象类型</li>
<li>WeakMap 键名所指向的对象，不计入垃圾回收机制</li>
</ul>
<p><code>WeakMap</code> 的属性跟操作方法与 <code>Map</code> 一致，同 <code>WeakSet</code> 一样，因为是弱引用，所以 <code>WeakSet</code> 也没有遍历方法</p>
<h5 id="类型的转换"><a href="#类型的转换" class="headerlink" title="类型的转换"></a>类型的转换</h5><ul>
<li><code>Map</code> 转为 <code>Array</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 解构</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>]])<br><span class="hljs-built_in">console</span>.log([...map])	<span class="hljs-comment">// [[1, 1], [2, 2], [3, 3]]</span><br><br><span class="hljs-comment">// Array.from()</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>]])<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(map))	<span class="hljs-comment">// [[1, 1], [2, 2], [3, 3]]</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>Array</code> 转为 <code>Map</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>]])<br><span class="hljs-built_in">console</span>.log(map)	<span class="hljs-comment">// Map &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>Map</code> 转为 <code>Object</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 非字符串键名会被转换为字符串</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapToObj</span>(<span class="hljs-params">map</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> map) &#123;<br>        obj[key] = value<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj<br>&#125;<br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;vue3js.cn&#x27;</span>).set(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;18&#x27;</span>)<br>mapToObj(map)  <span class="hljs-comment">// &#123;name: &quot;vue3js.cn&quot;, age: &quot;18&quot;&#125;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>Object</code> 转为 <code>Map</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&quot;b&quot;</span>:<span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<span class="hljs-built_in">Object</span>.entries(obj))<br></code></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>Set、Map、WeakSet、WeakMap、都是一种集合的数据结构</li>
<li>Set、WeakSet 是[值,值]的集合，且具有唯一性</li>
<li>Map 和 WeakMap 是一种[键,值]的集合，Map 的键可以是任意类型，WeakMap 的键只能是对象类型</li>
<li>Set 和 Map 有遍历方法，WeakSet 和 WeakMap 属于弱引用不可遍历</li>
</ul>
]]></content>
      <tags>
        <tag>Vue3源码-Set、Map、WeakSet、WeakMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3</title>
    <url>/2021/03/18/vue3/</url>
    <content><![CDATA[<p>学习Vue3最快的方式：就是对比veu2它有什么变化，那么对比Vue2</p>
<p>Vue3有什么不同呢？</p>
<h3 id="1-vue2和vue3双向数据绑定原理发生了改变"><a href="#1-vue2和vue3双向数据绑定原理发生了改变" class="headerlink" title="1. vue2和vue3双向数据绑定原理发生了改变"></a>1. vue2和vue3双向数据绑定原理发生了改变</h3><p><strong>vue2</strong> 的双向数据绑定是利用ES5 的一个 API <code>Object.definePropert()</code>对数据进行劫持 结合 发布订阅模式的方式来实现的。</p>
<p><strong>vue3</strong> 中使用了 es6 的 <code>Proxy</code>API 对数据代理。</p>
<p>相比于vue2.x，使用proxy的优势如下</p>
<ol>
<li>defineProperty只能监听某个属性，不能对全对象监听</li>
<li>可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）</li>
<li>可以监听数组，不用再去单独的对数组做特异性操作 vue3.x可以检测到数组内部数据的变化</li>
</ol>
<h4 id="2-默认进行懒观察（lazy-observation）。"><a href="#2-默认进行懒观察（lazy-observation）。" class="headerlink" title="2. 默认进行懒观察（lazy observation）。"></a>2. 默认进行懒观察（lazy observation）。</h4><p>在 2.x 版本里，不管数据多大，都会在一开始就为其创建观察者。当数据很大时，这可能会在页面载入时造成明显的性能压力。3.x 版本，只会对「被用于渲染初始可见部分的数据」创建观察者，而且 3.x 的观察者更高效。</p>
<ol start="3">
<li><p>更精准的变更通知。<br>比例来说：2.x 版本中，使用 Vue.set 来给对象新增一个属性时，这个对象的所有 watcher 都会重新运行；3.x 版本中，只有依赖那个属性的 watcher 才会重新运行。</p>
</li>
<li><p>3.0 新加入了 TypeScript 以及 PWA 的支持<br>5.vue2和vue3组件发送改变<strong>创建一个 <code>template</code></strong></p>
<p>组件来说，大多代码在Vue2和Vue3都<strong>非常相似</strong>。Vue3支持<code>碎片(Fragments)</code>，就是说在组件可以拥有多个根节点。</p>
<p>这种新特性可以减少很多组件之间的<code>div</code>包裹元素。在开发vue的时候，我们会发现每一个组件都会有个<code>div</code>元素包裹着。就会出现很多层多余的<code>div</code>元素。<code>碎片(Fragments)</code>解决了这个问题。对于有完美强迫症的童鞋“真的时太棒了”。我们这里的例子里就不展示了，用简单的单根节点的组件。</p>
<p><strong>Vue2 表格template</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;form-element&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> &#123;&#123; title &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text&#x27;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&#x27;username&#x27;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&#x27;Username&#x27;</span> /&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;password&#x27;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&#x27;password&#x27;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&#x27;Password&#x27;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;login&#x27;</span>&gt;</span><br>      Submit<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> <br>      Values: &#123;&#123; username + &#x27; &#x27; + password &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在Vue3的唯一真正的不同在于数据获取。Vue3中的<code>反应数据（Reactive Data）</code>是包含在一个<code>反应状态（Reactive State）</code>变量中。— 所以我们需要访问这个反应状态来获取数据值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;form-element&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> &#123;&#123; state.title &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">     <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text&#x27;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">v-model</span>=<span class="hljs-string">&#x27;state.username&#x27;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&#x27;Username&#x27;</span></span><br><span class="hljs-tag">    /&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">     <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;password&#x27;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">v-model</span>=<span class="hljs-string">&#x27;state.password&#x27;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&#x27;Password&#x27;</span></span><br><span class="hljs-tag">    /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;login&#x27;</span>&gt;</span><br>      Submit<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> <br>      Values: &#123;&#123; state.username + &#x27; &#x27; + state.password &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure>

<hr>
<h2 id="建立数据-data"><a href="#建立数据-data" class="headerlink" title="建立数据 data"></a><strong>建立数据 <code>data</code></strong></h2><p><strong>这里就是Vue2与Vue3 最大的区别 — Vue2使用<code>选项类型API（Options API）</code>对比Vue3<code>合成型API（Composition API）</code></strong></p>
<p>旧的选项型API在代码里分割了不同的属性（properties）：data，computed属性，methods，等等。新的合成型API能让我们用方法（function）来分割，相比于旧的API使用属性来分组，这样代码会更加简便和整洁。</p>
<blockquote>
<p>现在我们来对比一下Vue2写法和Vue3写法在代码里面的区别。</p>
</blockquote>
<p><strong>Vue2</strong> - 这里把两个数据放入data属性中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  props: &#123;<br>    title: <span class="hljs-built_in">String</span><br>  &#125;,<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      username: <span class="hljs-string">&#x27;&#x27;</span>,<br>      password: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<strong>Vue3.0</strong>，我们就需要使用一个新的<code>setup()</code>方法，此方法在组件初始化构造的时候触发。</p>
<p>为了可以让开发者对反应型数据有更多的控制，我们可以直接使用到 Vue3 的<code>反应API（reactivity API）</code>。</p>
<p>使用以下三步来建立<code>反应性数据</code>:</p>
<ol>
<li>从vue引入<code>reactive</code></li>
<li>使用<code>reactive()</code>方法来声名我们的数据为反应性数据</li>
<li>使用<code>setup()</code>方法来返回我们的反应性数据，从而我们的template可以获取这些反应性数据</li>
</ol>
<p>上一波代码，让大家更容易理解是怎么实现的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  props: &#123;<br>    title: <span class="hljs-built_in">String</span><br>  &#125;,<br>  setup () &#123;<br>    <span class="hljs-keyword">const</span> state = reactive(&#123;<br>      username: <span class="hljs-string">&#x27;&#x27;</span>,<br>      password: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> &#123; state &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里构造的反应性数据就可以被<code>template</code>使用，可以通过<code>state.username</code>和<code>state.password</code>获得数据的值。</p>
<hr>
<h2 id="Vue2-对比-Vue3的-methods-编写"><a href="#Vue2-对比-Vue3的-methods-编写" class="headerlink" title="Vue2 对比 Vue3的 methods 编写"></a><strong>Vue2 对比 Vue3的 <code>methods</code> 编写</strong></h2><p><strong>Vue2</strong> 的选项型API是把methods分割到独立的属性区域的。我们可以直接在这个属性里面添加方法来处理各种前端逻辑。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  props: &#123;<br>    title: <span class="hljs-built_in">String</span><br>  &#125;,<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      username: <span class="hljs-string">&#x27;&#x27;</span>,<br>      password: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    login () &#123;<br>      <span class="hljs-comment">// 登陆方法</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Vue3</strong> 的合成型API里面的<code>setup()</code>方法也是可以用来操控methods的。创建声名方法其实和声名数据状态是一样的。— 我们需要先声名一个方法然后在<code>setup()</code>方法中<code>返回(return)</code>， 这样我们的组件内就可以调用这个方法了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  props: &#123;<br>    title: <span class="hljs-built_in">String</span><br>  &#125;,<br>  setup () &#123;<br>    <span class="hljs-keyword">const</span> state = reactive(&#123;<br>      username: <span class="hljs-string">&#x27;&#x27;</span>,<br>      password: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;)<br><br>    <span class="hljs-keyword">const</span> login = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 登陆方法</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123; <br>      login,<br>      state<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="生命周期钩子-—-Lifecyle-Hooks"><a href="#生命周期钩子-—-Lifecyle-Hooks" class="headerlink" title="生命周期钩子 — Lifecyle Hooks"></a><strong>生命周期钩子 — <code>Lifecyle Hooks</code></strong></h2><p>在 <strong>Vue2</strong>，我们可以直接在组件属性中调用Vue的生命周期的钩子。以下使用一个<code>组件已挂载（mounted）</code>生命周期触发钩子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  props: &#123;<br>    title: <span class="hljs-built_in">String</span><br>  &#125;,<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      username: <span class="hljs-string">&#x27;&#x27;</span>,<br>      password: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br>  &#125;,<br>  mounted () &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;组件已挂载&#x27;</span>)<br>  &#125;,<br>  methods: &#123;<br>    login () &#123;<br>      <span class="hljs-comment">// login method</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在 <strong>Vue3</strong> 的合成型API里面的<code>setup()</code>方法可以包含了基本所有东西。生命周期的钩子就是其中之一！</p>
<p>但是在 Vue3 生周期钩子不是全局可调用的了，需要另外从vue中引入。和刚刚引入<code>reactive</code>一样，生命周期的挂载钩子叫<code>onMounted</code>。</p>
<p>引入后我们就可以在<code>setup()</code>方法里面使用<code>onMounted</code>挂载的钩子了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; reactive, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  props: &#123;<br>    title: <span class="hljs-built_in">String</span><br>  &#125;,<br>  setup () &#123;<br>    <span class="hljs-comment">// ..</span><br><br>    onMounted(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;组件已挂载&#x27;</span>)<br>    &#125;)<br><br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="计算属性-Computed-Properties"><a href="#计算属性-Computed-Properties" class="headerlink" title="计算属性 - Computed Properties"></a><strong>计算属性 - <code>Computed Properties</code></strong></h2><p>我们一起试试添加一个计算属性来转换<code>username</code>成小写字母。</p>
<p>在 <strong>Vue2</strong> 中实现，我们只需要在组件内的选项属性中添加即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// .. </span><br>  computed: &#123;<br>    lowerCaseUsername () &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.username.toLowerCase()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Vue3</strong> 的设计模式给予开发者们按需引入需要使用的依赖包。这样一来就不需要多余的引用导致性能或者打包后太大的问题。Vue2就是有这个一直存在的问题。</p>
<p>所以在 Vue3 使用计算属性，我们先需要在组件内引入<code>computed</code>。</p>
<p>使用方式就和<code>反应性数据（reactive data）</code>一样，在<code>state</code>中加入一个计算属性:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; reactive, onMounted, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  props: &#123;<br>    title: <span class="hljs-built_in">String</span><br>  &#125;,<br>  setup () &#123;<br>    <span class="hljs-keyword">const</span> state = reactive(&#123;<br>      username: <span class="hljs-string">&#x27;&#x27;</span>,<br>      password: <span class="hljs-string">&#x27;&#x27;</span>,<br>      lowerCaseUsername: computed(<span class="hljs-function">() =&gt;</span> state.username.toLowerCase())<br>    &#125;)<br><br>    <span class="hljs-comment">// ...</span><br>  &#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="接收-Props"><a href="#接收-Props" class="headerlink" title="接收 Props"></a><strong>接收 <code>Props</code></strong></h2><p>接收组件<code>props</code>参数传递这一块为我们带来了Vue2和Vue3之间最大的区别。<strong>—<code>this</code>在vue3中与vue2代表着完全不一样的东西。</strong></p>
<p>在 <strong>Vue2</strong>，<code>this</code>代表的是当前组件，不是某一个特定的属性。所以我们可以直接使用<code>this</code>访问prop属性值。就比如下面的例子在挂载完成后打印处当前传入组件的参数<code>title</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">mounted () &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;title: &#x27;</span> + <span class="hljs-built_in">this</span>.title)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是在 <strong>Vue3</strong> 中，<code>this</code>无法直接拿到props属性，emit events（触发事件）和组件内的其他属性。不过全新的<code>setup()</code>方法可以接收两个参数：</p>
<ol>
<li><code>props</code> - 不可变的组件参数</li>
<li><code>context</code> - Vue3 暴露出来的属性（emit，slots，attrs）</li>
</ol>
<p>所以在 Vue3 接收与使用props就会变成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">setup (props) &#123;<br>    <span class="hljs-comment">// ...</span><br><br>    onMounted(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;title: &#x27;</span> + props.title)<br>    &#125;)<br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="事件-Emitting-Events"><a href="#事件-Emitting-Events" class="headerlink" title="事件 - Emitting Events"></a><strong>事件 - <code>Emitting Events</code></strong></h2><p>在 <strong>Vue2</strong> 中自定义事件是非常直接的，但是在 <strong>Vue3</strong> 的话，我们会有更多的控制的自由度。</p>
<p>举例，现在我们想在点击提交按钮时触发一个<code>login</code>的事件。</p>
<p>在 <strong>Vue2</strong> 中我们会调用到<code>this.$emit</code>然后传入事件名和参数对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">login () &#123;<br>      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;login&#x27;</span>, &#123;<br>        username: <span class="hljs-built_in">this</span>.username,<br>        password: <span class="hljs-built_in">this</span>.password<br>      &#125;)<br> &#125;<br></code></pre></td></tr></table></figure>

<p>但是在 <strong>Vue3</strong>中，我们刚刚说过<code>this</code>已经不是和vue2代表着这个组件了，所以我们需要不一样的自定义事件的方式。</p>
<p>那怎么办呀？! ლಠ益ಠ)ლ</p>
<p>不用慌，在<code>setup()</code>中的第二个参数<code>content</code>对象中就有<code>emit</code>，这个是和<code>this.$emit</code>是一样的。那么我们只要在<code>setup()</code>接收第二个参数中使用<strong>分解对象法</strong>取出<code>emit</code>就可以在setup方法中随意使用了。</p>
<p>然后我们在<code>login</code>方法中编写登陆事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">setup (props, &#123; emit &#125;) &#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">const</span> login = <span class="hljs-function">() =&gt;</span> &#123;<br>      emit(<span class="hljs-string">&#x27;login&#x27;</span>, &#123;<br>        username: state.username,<br>        password: state.password<br>      &#125;)<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="最终的vue2对比vue3代码"><a href="#最终的vue2对比vue3代码" class="headerlink" title="最终的vue2对比vue3代码"></a><strong>最终的vue2对比vue3代码</strong></h2></li>
</ol>
<p>  ![img](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='2000' height='1250'></svg>)</p>
<p>  真的是太棒了，能看到这里的童鞋们，你们现在基本都看到vue2与vue3其实概念与理念都是一样的。只是有一些属性获取方式和声名和定义方式稍微变了。一直在鬼哭狼嚎的小小前端开发猿人们，你们可以松一口气了吧。</p>
<p>  总结一下，我觉得 <strong>Vue3</strong> 给我们前端开发者带来了全新的开发体验，更好的使用弹性，可控度也得到了大大的提升。如果你是一个学过或者接触过 <strong>React</strong> 然后现在想使用Vue的话，应该特别兴奋，因为很多使用方式都和React非常相近了 ！</p>
<p>  全新的<code>合成式API（Composition API）</code>可以提升代码的解耦程度 —— 特别是大型的前端应用，效果会更加明显。还有就是按需引用的有了更细微的可控性，让项目的性能和打包大小有更好的控制。</p>
<p>  最后我把完成的 <strong>Vue2</strong> 和 <strong>Vue3</strong> 的组件代码发出来给大家：</p>
<p>  <strong>Vue2</strong></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&#x27;form-element&#x27;</span>&gt;<br>    &lt;h2&gt; &#123;&#123; title &#125;&#125; &lt;/h2&gt;<br>    &lt;input type=<span class="hljs-string">&#x27;text&#x27;</span> v-model=<span class="hljs-string">&#x27;username&#x27;</span> placeholder=<span class="hljs-string">&#x27;Username&#x27;</span> /&gt;<br>    <br>    &lt;input type=<span class="hljs-string">&#x27;password&#x27;</span> v-model=<span class="hljs-string">&#x27;password&#x27;</span> placeholder=<span class="hljs-string">&#x27;Password&#x27;</span> /&gt;<br><br>    &lt;button @click=<span class="hljs-string">&#x27;login&#x27;</span>&gt;<br>      Submit<br>    &lt;/button&gt;<br>    &lt;p&gt; <br>      Values: &#123;&#123; username + <span class="hljs-string">&#x27; &#x27;</span> + password &#125;&#125;<br>    &lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  props: &#123;<br>    title: <span class="hljs-built_in">String</span><br>  &#125;,<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      username: <span class="hljs-string">&#x27;&#x27;</span>,<br>      password: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br>  &#125;,<br>  mounted () &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;title: &#x27;</span> + <span class="hljs-built_in">this</span>.title)<br>  &#125;,<br>  computed: &#123;<br>    lowerCaseUsername () &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.username.toLowerCase()<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    login () &#123;<br>      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;login&#x27;</span>, &#123;<br>        username: <span class="hljs-built_in">this</span>.username,<br>        password: <span class="hljs-built_in">this</span>.password<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>  <strong>Vue3</strong></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&#x27;form-element&#x27;</span>&gt;<br>    &lt;h2&gt; &#123;&#123; state.title &#125;&#125; &lt;/h2&gt;<br>    &lt;input type=<span class="hljs-string">&#x27;text&#x27;</span> v-model=<span class="hljs-string">&#x27;state.username&#x27;</span> placeholder=<span class="hljs-string">&#x27;Username&#x27;</span> /&gt;<br>    <br>    &lt;input type=<span class="hljs-string">&#x27;password&#x27;</span> v-model=<span class="hljs-string">&#x27;state.password&#x27;</span> placeholder=<span class="hljs-string">&#x27;Password&#x27;</span> /&gt;<br><br>    &lt;button @click=<span class="hljs-string">&#x27;login&#x27;</span>&gt;<br>      Submit<br>    &lt;/button&gt;<br>    &lt;p&gt; <br>      Values: &#123;&#123; state.username + <span class="hljs-string">&#x27; &#x27;</span> + state.password &#125;&#125;<br>    &lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br><span class="hljs-keyword">import</span> &#123; reactive, onMounted, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  props: &#123;<br>    title: <span class="hljs-built_in">String</span><br>  &#125;,<br>  setup (props, &#123; emit &#125;) &#123;<br>    <span class="hljs-keyword">const</span> state = reactive(&#123;<br>      username: <span class="hljs-string">&#x27;&#x27;</span>,<br>      password: <span class="hljs-string">&#x27;&#x27;</span>,<br>      lowerCaseUsername: computed(<span class="hljs-function">() =&gt;</span> state.username.toLowerCase())<br>    &#125;)<br><br>    onMounted(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;title: &#x27;</span> + props.title)<br>    &#125;)<br><br>    <span class="hljs-keyword">const</span> login = <span class="hljs-function">() =&gt;</span> &#123;<br>      emit(<span class="hljs-string">&#x27;login&#x27;</span>, &#123;<br>        username: state.username,<br>        password: state.password<br>      &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123; <br>      login,<br>      state<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3源码-Proxy</title>
    <url>/2021/03/18/vue3%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handle)<br></code></pre></td></tr></table></figure>

<ul>
<li>target 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理</li>
<li>handler 一个通常以函数作为属性的对象，用来定制拦截行为</li>
</ul>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> origon=&#123;&#125;<br><br><span class="hljs-keyword">const</span> obj=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(origon,&#123;<br>   get:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target,propkey,receiver</span>)</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;10&quot;</span><br>   &#125;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(obj.b);<span class="hljs-comment">//10</span><br><span class="hljs-built_in">console</span>.log(obj.a);<span class="hljs-comment">//10</span><br><span class="hljs-built_in">console</span>.log(origon.a);<span class="hljs-comment">//undefined</span><br><span class="hljs-built_in">console</span>.log(origon.a);<span class="hljs-comment">//undefined</span><br><br></code></pre></td></tr></table></figure>

<p>上方代码我们给一个空对象的get架设了一层代理，所有<code>get</code>操作都会直接返回我们定制的数字10，需要注意的是，代理只会对<code>proxy</code>对象生效，如上方的<code>origin</code>就没有任何效果</p>
<h2 id="Handler-对象常用的方法"><a href="#Handler-对象常用的方法" class="headerlink" title="Handler 对象常用的方法"></a>Handler 对象常用的方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th align="left">描述</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>handler.has()</td>
<td align="left">in 操作符的捕捉器。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>handler.get()</td>
<td align="left">属性读取操作的捕捉器。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>handler.set()</td>
<td align="left">属性设置操作的捕捉器。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>handler.deleteProperty()</td>
<td align="left">delete 操作符的捕捉器。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>handler.ownKeys()</td>
<td align="left">Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>handler.apply()</td>
<td align="left">函数调用操作的捕捉器。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>handler.construct()</td>
<td align="left">new 操作符的捕捉器</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>下面挑<code>handler.get</code>重点讲一下，其它方法的使用也都大同小异，不同的是参数的区别</p>
<h3 id="handler-get"><a href="#handler-get" class="headerlink" title="handler.get"></a>handler.get</h3><p><code>get</code>我们在上面例子已经体验过了，现在详细介绍一下，用于代理目标对象的属性读取操作</p>
<p>授受三个参数 <code>get(target, propKey, ?receiver)</code></p>
<ul>
<li>target 目标对象</li>
<li>propkey 属性名</li>
<li>receiver Proxy 实例本身</li>
</ul>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> preson = &#123;<br>   like: <span class="hljs-string">&#x27;vue.js&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(preson, &#123;<br>   get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, propkey</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (propkey <span class="hljs-keyword">in</span> target) &#123;<br>         <span class="hljs-keyword">return</span> target[propkey]<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ReferenceError</span>(<span class="hljs-string">&#x27;错误&#x27;</span>)<br>      &#125;<br>   &#125;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(obj.like);<span class="hljs-comment">// vuejs</span><br><span class="hljs-built_in">console</span>.log(obj.text);<span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ul>
<li>如果要访问的目标属性是不可写以及不可配置的，则返回的值必须与该目标属性的值相同</li>
<li>如果要访问的目标属性没有配置访问方法，即get方法是undefined的，则返回值必须为undefined</li>
</ul>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br>  configurable: <span class="hljs-literal">false</span>, <br>  enumerable: <span class="hljs-literal">false</span>, <br>  value: <span class="hljs-number">10</span>, <br>  writable: <span class="hljs-literal">false</span> <br>&#125;)<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, &#123;<br>  get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, prop</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;<br>  &#125;<br>&#125;)<br><br>p.a <span class="hljs-comment">// Uncaught TypeError: &#x27;get&#x27; on proxy: property &#x27;a&#x27; is a read-only and non-configurable..</span><br></code></pre></td></tr></table></figure>

<h2 id="可撤消的Proxy"><a href="#可撤消的Proxy" class="headerlink" title="可撤消的Proxy"></a>可撤消的Proxy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">proxy&#96;有一个唯一的静态方法，&#96;Proxy.revocable(target, handler)<br></code></pre></td></tr></table></figure>

<p><code>Proxy.revocable()</code>方法可以用来创建一个可撤销的代理对象</p>
<p>该方法的返回值是一个对象，其结构为： <code>&#123;&quot;proxy&quot;: proxy, &quot;revoke&quot;: revoke&#125;</code></p>
<ul>
<li>proxy 表示新生成的代理对象本身，和用一般方式 new Proxy(target, handler) 创建的代理对象没什么不同，只是它可以被撤销掉。</li>
<li>revoke 撤销方法，调用的时候不需要加任何参数，就可以撤销掉和它一起生成的那个代理对象。</li>
</ul>
<p>该方法常用于完全封闭对目标对象的访问, 如下示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;vuejs&#x27;</span>&#125;<br><span class="hljs-keyword">const</span> &#123;proxy, revoke&#125; = <span class="hljs-built_in">Proxy</span>.revocable(target, handler)<br>proxy.name <span class="hljs-comment">// 正常取值输出 vuejs</span><br>revoke() <span class="hljs-comment">// 取值完成对proxy进行封闭，撤消代理</span><br>proxy.name <span class="hljs-comment">// TypeError: Revoked</span><br></code></pre></td></tr></table></figure>

<h2 id="Proxy的应用场景"><a href="#Proxy的应用场景" class="headerlink" title="Proxy的应用场景"></a>Proxy的应用场景</h2><p><code>Proxy</code>的应用范围很广，下方列举几个典型的应用场景</p>
<h3 id="校验器"><a href="#校验器" class="headerlink" title="#校验器"></a><a href="https://vue3js.cn/es6/#%E6%A0%A1%E9%AA%8C%E5%99%A8">#</a><strong>校验器</strong></h3><p>想要一个<code>number</code>，拿回来的却是<code>string</code>，惊不惊喜？意不意外？下面我们使用<code>Proxy</code>实现一个逻辑分离的数据格式验证器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123;<br>  _id: <span class="hljs-string">&#x27;1024&#x27;</span>,<br>  name:  <span class="hljs-string">&#x27;vuejs&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> validators = &#123;  <br>    name(val) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;string&#x27;</span>;<br>    &#125;,<br>    _id(val) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; val &gt; <span class="hljs-number">1024</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> createValidator = <span class="hljs-function">(<span class="hljs-params">target, validator</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, &#123;<br>    _validator: validator,<br>    set(target, propkey, value, proxy)&#123;<br>      <span class="hljs-keyword">let</span> validator = <span class="hljs-built_in">this</span>._validator[propkey](value)<br>      <span class="hljs-keyword">if</span>(validator)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, propkey, value, proxy)<br>      &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Cannot set <span class="hljs-subst">$&#123;propkey&#125;</span> to <span class="hljs-subst">$&#123;value&#125;</span>. Invalid type.`</span>)<br>      &#125;<br>    &#125;<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = createValidator(target, validators)<br><br>proxy.name = <span class="hljs-string">&#x27;vue-js.com&#x27;</span> <span class="hljs-comment">// vue-js.com</span><br>proxy.name = <span class="hljs-number">10086</span> <span class="hljs-comment">// Uncaught Error: Cannot set name to 10086. Invalid type.</span><br>proxy._id = <span class="hljs-number">1025</span> <span class="hljs-comment">// 1025</span><br>proxy._id = <span class="hljs-number">22</span>  <span class="hljs-comment">// Uncaught Error: Cannot set _id to 22. Invalid type </span><br></code></pre></td></tr></table></figure>

<h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><p>在日常编写代码的过程中，我们想定义一些私有属性，通常是在团队中进行约定，大家按照约定在变量名之前添加下划线 _ 或者其它格式来表明这是一个私有属性，但我们不能保证他能真私‘私有化’，下面使用Proxy轻松实现私有属性拦截</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123;<br>   _id: <span class="hljs-string">&#x27;123&#x27;</span>,<br>   name: <span class="hljs-string">&#x27;张三&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, &#123;<br>   get(target, key, proxy) &#123;<br>      <span class="hljs-keyword">if</span> (key[<span class="hljs-number">0</span>] === <span class="hljs-string">&quot;_&quot;</span>) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;我是私有属性&#x27;</span>)<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, key, proxy)<br>   &#125;,<br>   set(target, key, val, proxy) &#123;<br>      <span class="hljs-keyword">if</span> (key[<span class="hljs-number">0</span>] === <span class="hljs-string">&quot;_&quot;</span>) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;我是私有属性&#x27;</span>)<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, key, val, proxy)<br>   &#125;<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(proxy.name);<span class="hljs-comment">//张三</span><br><span class="hljs-built_in">console</span>.log(proxy._id);<span class="hljs-comment">//Error: 我是私有属性</span><br><span class="hljs-built_in">console</span>.log(proxy.name = <span class="hljs-string">&#x27;李四&#x27;</span>);<span class="hljs-comment">//李四</span><br><span class="hljs-built_in">console</span>.log(proxy._id = <span class="hljs-number">456</span>);<span class="hljs-comment">//Error: 我是私有属性</span><br><br></code></pre></td></tr></table></figure>

<p><code>Proxy</code> 使用场景还有很多很多，不再一一列举，如果你需要在某一个动作的生命周期内做一些特定的处理，那么<code>Proxy</code> 都是适合的</p>
<h4 id="为什么要用Proxy重构"><a href="#为什么要用Proxy重构" class="headerlink" title="为什么要用Proxy重构"></a>为什么要用Proxy重构</h4><p>在 <code>Proxy</code> 之前，<code>JavaScript</code> 中就提供过 <code>Object.defineProperty</code>，允许对对象的 <code>getter/setter</code> 进行拦截</p>
<p>Vue3.0之前的双向绑定是由 <code>defineProperty</code> 实现, 在3.0重构为 <code>Proxy</code>，那么两者的区别究竟在哪里呢？</p>
<p>首先我们再来回顾一下它的定义</p>
<blockquote>
<p>Object.defineProperty() 方法会直接在一个<strong>对象上</strong>定义一个<strong>新属性</strong>，或者修改一个对象的现有属性，并返回此对象</p>
</blockquote>
<p>上面给两个词划了重点，<strong>对象上</strong>，<strong>属性</strong>，我们可以理解为是针对对象上的某一个属性做处理的</p>
<p><strong>语法</strong></p>
<ul>
<li>obj 要定义属性的对象</li>
<li>prop 要定义或修改的属性的名称或 Symbol</li>
<li>descriptor 要定义或修改的属性描述符</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.defineProperty(obj, prop, descriptor)<br></code></pre></td></tr></table></figure>

<p>举个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;&#125;<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&quot;a&quot;</span>, &#123;<br>  value : <span class="hljs-number">1</span>,<br>  writable : <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否可写 </span><br>  configurable : <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否可配置</span><br>  enumerable : <span class="hljs-literal">false</span> <span class="hljs-comment">// 是否可枚举</span><br>&#125;)<br><br><span class="hljs-comment">// 上面给了三个false, 下面的相关操作就很容易理解了</span><br>obj.a = <span class="hljs-number">2</span> <span class="hljs-comment">// 无效</span><br><span class="hljs-keyword">delete</span> obj.a <span class="hljs-comment">// 无效</span><br><span class="hljs-keyword">for</span>(key <span class="hljs-keyword">in</span> obj)&#123;<br>  <span class="hljs-built_in">console</span>.log(key) <span class="hljs-comment">// 无效 </span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Vue中的defineProperty"><a href="#Vue中的defineProperty" class="headerlink" title="#Vue中的defineProperty"></a><a href="https://vue3js.cn/es6/#vue%E4%B8%AD%E7%9A%84defineproperty">#</a><strong>Vue中的defineProperty</strong></h3><p>Vue3之前的双向绑定都是通过 <code>defineProperty</code> 的 <code>getter,setter</code> 来实现的，我们先来体验一下 <code>getter,setter</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<br>  set(val) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`开始设置新值: <span class="hljs-subst">$&#123;val&#125;</span>`</span>)<br>  &#125;,<br>  get() &#123; <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`开始读取属性`</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>  &#125;,<br>  writable : <span class="hljs-literal">true</span><br>&#125;)<br><br>obj.a = <span class="hljs-number">2</span> <span class="hljs-comment">// 开始设置新值: 2</span><br>obj.a <span class="hljs-comment">// 开始获取属性 </span><br></code></pre></td></tr></table></figure>

<p>看到这里，我相信有些同学已经想到了实现双向绑定背后的流程了，其实很简单嘛，只要我们观察到对象属性的变更，再去通知更新视图就好了</p>
<p>我们摘抄一段 Vue 源码中的核心实现验证一下，这一部分一笔代过，不是本文重点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 源码位置：https://github.com/vuejs/vue/blob/ef56410a2c/src/core/observer/index.js#L135</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>  enumerable: <span class="hljs-literal">true</span>,<br>  configurable: <span class="hljs-literal">true</span>,<br>  get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveGetter</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (Dep.target) &#123;<br>      <span class="hljs-comment">// 收集依赖</span><br>      dep.depend()<br>    &#125;<br>    <span class="hljs-keyword">return</span> value<br>  &#125;,<br>  set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveSetter</span> (<span class="hljs-params">newVal</span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 通知视图更新</span><br>    dep.notify()<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="对象新增属性为什么不更新"><a href="#对象新增属性为什么不更新" class="headerlink" title="#对象新增属性为什么不更新"></a><a href="https://vue3js.cn/es6/#%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%9B%B4%E6%96%B0">#</a><strong>对象新增属性为什么不更新</strong></h3><p>这个问题用过Vue的同学应该有超过95%比例遇到过</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">data  () &#123;<br>  <span class="hljs-keyword">return</span>  &#123;<br>    obj: &#123;<br>      a: <span class="hljs-number">1</span><br>    &#125;<br>  &#125;<br>&#125;<br><br>methods: &#123;<br>  update () &#123;<br>    <span class="hljs-built_in">this</span>.obj.b = <span class="hljs-number">2</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的伪代码，当我们执行 <code>update</code> 更新 <code>obj</code> 时，我们预期视图是要随之更新的，实际是并不会</p>
<p>这个其实很好理解，我们先要明白 <code>vue</code> 中 <code>data init</code> 的时机，<code>data init</code> 是在生命周期 <code>created</code> 之前的操作，会对 <code>data</code> 绑定一个观察者 <code>Observer</code>，之后 <code>data</code> 中的字段更新都会通知依赖收集器<code>Dep</code>触发视图更新</p>
<p>然后我们回到 <code>defineProperty</code> 本身，是对<strong>对象上的属性</strong>做操作，而非对象本身</p>
<p>一句话来说就是，在 <code>Observer data</code> 时，新增属性并不存在，自然就不会有 <code>getter, setter</code>，也就解释了为什么新增视图不更新，解决有很多种，<code>Vue</code> 提供的全局<code>$set</code> 本质也是给新增的属性手动 <code>observer</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 源码位置 https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js#L201</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set</span> (<span class="hljs-params">target: Array&lt;any&gt; | Object, key: any, val: any</span>): <span class="hljs-title">any</span> </span>&#123;<br>  <span class="hljs-comment">// ....</span><br>  <span class="hljs-keyword">if</span> (!ob) &#123;<br>    target[key] = val<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  defineReactive(ob.value, key, val)<br>  ob.dep.notify()<br>  <span class="hljs-keyword">return</span> val<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="数组变异"><a href="#数组变异" class="headerlink" title="#数组变异"></a><a href="https://vue3js.cn/es6/#%E6%95%B0%E7%BB%84%E5%8F%98%E5%BC%82">#</a>数组变异</h3><blockquote>
<p>由于 JavaScript 的限制，Vue 不能检测以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</p>
</blockquote>
<p>先来看一段代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  data: &#123;<br>    items: [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>]<br>  &#125;<br>&#125;)<br>vm.items[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;4&#x27;</span> <span class="hljs-comment">// 视图并未更新</span><br></code></pre></td></tr></table></figure>

<p>文档已经做出了解释，但并不是<code>defineProperty</code>的锅，而是尤大在设计上对性能的权衡，下面这段代码可以验证</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">data, key, val</span>) </span>&#123;<br>  <span class="hljs-built_in">Object</span>.defineProperty(data, key, &#123;<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>      get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineGet</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`get key: <span class="hljs-subst">$&#123;key&#125;</span> val: <span class="hljs-subst">$&#123;val&#125;</span>`</span>);<br>        <span class="hljs-keyword">return</span> val;<br>      &#125;,<br>      set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineSet</span>(<span class="hljs-params">newVal</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`set key: <span class="hljs-subst">$&#123;key&#125;</span> val: <span class="hljs-subst">$&#123;newVal&#125;</span>`</span>);<br>        val = newVal;<br>      &#125;<br>  &#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span>(<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>&#123;<br>    defineReactive(data, key, data[key]);<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">let</span> test = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>observe(test);<br><br>test[<span class="hljs-number">0</span>] = <span class="hljs-number">4</span> <span class="hljs-comment">// set key: 0 val: 4</span><br></code></pre></td></tr></table></figure>

<p>虽然说索引变更不是 <code>defineProperty</code> 的锅，但新增索引的确是 <code>defineProperty</code> 做不到的，所以就有了数组的变异方法</p>
<p>能看到这里，大概也能猜到内部实现了，还是跟<code>$set</code>一样，手动 <code>observer</code>，下面我们验证一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> methodsToPatch = [<br>  <span class="hljs-string">&#x27;push&#x27;</span>,<br>  <span class="hljs-string">&#x27;pop&#x27;</span>,<br>  <span class="hljs-string">&#x27;shift&#x27;</span>,<br>  <span class="hljs-string">&#x27;unshift&#x27;</span>,<br>  <span class="hljs-string">&#x27;splice&#x27;</span>,<br>  <span class="hljs-string">&#x27;sort&#x27;</span>,<br>  <span class="hljs-string">&#x27;reverse&#x27;</span><br>]<br><br>methodsToPatch.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>&#123;<br>  <span class="hljs-comment">// 缓存原生数组</span><br>  <span class="hljs-keyword">const</span> original = arrayProto[method]<br>  <span class="hljs-comment">// def使用Object.defineProperty重新定义属性</span><br>  def(arrayMethods, method, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutator</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> result = original.apply(<span class="hljs-built_in">this</span>, args) <span class="hljs-comment">// 调用原生数组的方法</span><br><br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-built_in">this</span>.__ob__  <span class="hljs-comment">// ob就是observe实例observe才能响应式</span><br>    <span class="hljs-keyword">let</span> inserted<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>      <span class="hljs-comment">// push和unshift方法会增加数组的索引，但是新增的索引位需要手动observe的</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;push&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;unshift&#x27;</span>:<br>        inserted = args<br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-comment">// 同理，splice的第三个参数，为新增的值，也需要手动observe</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;splice&#x27;</span>:<br>        inserted = args.slice(<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>    <span class="hljs-comment">// 其余的方法都是在原有的索引上更新，初始化的时候已经observe过了</span><br>    <span class="hljs-keyword">if</span> (inserted) ob.observeArray(inserted)<br>    <span class="hljs-comment">// dep通知所有的订阅者触发回调</span><br>    ob.dep.notify()<br>    <span class="hljs-keyword">return</span> result<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>一个优秀的开源框架本身就是一个不断打碎重朔的过程，上面做了些许铺垫，现在我们简要总结一下</p>
<ul>
<li><code>Proxy</code> 作为新标准将受到浏览器厂商重点持续的性能优化</li>
<li><code>Proxy</code> 能观察的类型比 <code>defineProperty</code> 更丰富</li>
<li><code>Proxy</code> 不兼容IE，也没有 <code>polyfill</code>, <code>defineProperty</code> 能支持到IE9</li>
<li><code>Object.definedProperty</code> 是劫持对象的属性，新增元素需要再次 <code>definedProperty</code>。而 <code>Proxy</code> 劫持的是整个对象，不需要做特殊处理</li>
<li>使用 <code>defineProperty</code> 时，我们修改原来的 <code>obj</code> 对象就可以触发拦截，而使用 <code>proxy</code>，就必须修改代理对象，即 <code>Proxy</code> 的实例才可以触发拦截</li>
</ul>
]]></content>
      <tags>
        <tag>Vue3源码-Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码理解——生命周期篇</title>
    <url>/2021/03/18/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A34/</url>
    <content><![CDATA[<h4 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h4><p>在<code>Vue</code>中，每个<code>Vue</code>实例从被创建出来到最终被销毁都会经历一个过程，就像人一样，从出生到死亡。在这一过程里会发生许许多多的事，例如设置数据监听，编译模板，组件挂载等。在<code>Vue</code>中，把<code>Vue</code>实例从被创建出来到最终被销毁的这一过程称为<code>Vue</code>实例的生命周期，同时，在<code>Vue</code>实例生命周期的不同阶段<code>Vue</code>还提供了不同的钩子函数，以方便用户在不同的生命周期阶段做一些额外的事情。那么，接下来的几篇文章我们就从源码角度深入剖析一下一个<code>Vue</code>实例在从生到死的生命周期里到底都经历了些什么，每个阶段都做了哪些事情。</p>
<h5 id="生命周期流程图"><a href="#生命周期流程图" class="headerlink" title="生命周期流程图"></a>生命周期流程图</h5><p>下图是<code>Vue</code>官网给出的<code>Vue</code>实例的生命周期流程图，如下：</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425145156115.png" alt="image-20210425145156115"></p>
<p>从图中我们可以看到，<code>Vue</code>实例的生命周期大致可分为4个阶段：</p>
<ul>
<li>初始化阶段：为<code>Vue</code>实例上初始化一些属性，事件以及响应式数据；</li>
<li>模板编译阶段：将模板编译成渲染函数；</li>
<li>挂载阶段：将实例挂载到指定的<code>DOM</code>上，即将模板渲染到真实<code>DOM</code>中；</li>
<li>销毁阶段：将实例自身从父组件中删除，并取消依赖追踪及事件监听器；</li>
</ul>
<h6 id="总结：："><a href="#总结：：" class="headerlink" title="总结：："></a>总结：：</h6><p>本篇文章是生命周期篇的开篇综述，借用<code>Vue</code>官网的生命周期流程图介绍了一个<code>Vue</code>实例的生命周期大致可分为四个阶段，分别是初始化阶段、模板编译阶段、挂载阶段、销毁阶段。接下来的几篇文章我们就从这个流程图为基础，自上到下，从每个阶段入手，深入分析在每个阶段里都干了些什么。</p>
<h2 id="2-new-Vue-都干了什么"><a href="#2-new-Vue-都干了什么" class="headerlink" title="2. new Vue()都干了什么"></a>2. new Vue()都干了什么</h2><p>初始化阶段所做的第一件事就是<code>new Vue()</code>创建一个<code>Vue</code>实例，那么<code>new Vue()</code>的内部都干了什么呢？ 我们知道，<code>new</code> 关键字在 <code>JS</code>中表示从一个类中实例化出一个对象来，由此可见， <code>Vue</code> 实际上是一个类。所以<code>new Vue()</code>实际上是执行了<code>Vue</code>类的构造函数，那么我们来看一下<code>Vue</code>类是如何定义的，<code>Vue</code>类的定义是在源码的<code>src/core/instance/index.js</code> 中，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Vue</span> (<span class="hljs-params">options</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp;<br>    !(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> Vue)<br>  ) &#123;<br>    warn(<span class="hljs-string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)<br>  &#125;<br>  <span class="hljs-built_in">this</span>._init(options)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，<code>Vue</code>类的定义非常简单，其构造函数核心就一行代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>._init(options)<br></code></pre></td></tr></table></figure>

<p>调用原型上的<code>_init(options)</code>方法并把用户所写的选项<code>options</code>传入。那这个<code>_init</code>方法是从哪来的呢？在<code>Vue</code>类定义的下面还有几行代码，其中之一就是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">initMixin(Vue)<br></code></pre></td></tr></table></figure>

<p>这一行代码执行了<code>initMixin</code>函数，那<code>initMixin</code>函数又是从哪儿来的呢？该函数定义位于源码的<code>src/core/instance/init.js</code> 中，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initMixin</span> (<span class="hljs-params">Vue</span>) </span>&#123;<br>  Vue.prototype._init = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">this</span><br>    vm.$options = mergeOptions(<br>        resolveConstructorOptions(vm.constructor),<br>        options || &#123;&#125;,<br>        vm<br>    )<br>    vm._self = vm<br>    initLifecycle(vm)<br>    initEvents(vm)<br>    initRender(vm)<br>    callHook(vm, <span class="hljs-string">&#x27;beforeCreate&#x27;</span>)<br>    initInjections(vm) <span class="hljs-comment">// resolve injections before data/props</span><br>    initState(vm)<br>    initProvide(vm) <span class="hljs-comment">// resolve provide after data/props</span><br>    callHook(vm, <span class="hljs-string">&#x27;created&#x27;</span>)<br><br>    <span class="hljs-keyword">if</span> (vm.$options.el) &#123;<br>      vm.$mount(vm.$options.el)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，在<code>initMixin</code>函数内部就只干了一件事，那就是给<code>Vue</code>类的原型上绑定<code>_init</code>方法，同时<code>_init</code>方法的定义也在该函数内部。现在我们知道了，<code>new Vue()</code>会执行<code>Vue</code>类的构造函数，构造函数内部会执行<code>_init</code>方法，所以<code>new Vue()</code>所干的事情其实就是<code>_init</code>方法所干的事情，那么我们着重来分析下<code>_init</code>方法都干了哪些事情。</p>
<p>首先，把<code>Vue</code>实例赋值给变量<code>vm</code>，并且把用户传递的<code>options</code>选项与当前构造函数的<code>options</code>属性及其父级构造函数的<code>options</code>属性进行合并（关于属性如何合并的问题下面会介绍），得到一个新的<code>options</code>选项赋值给<code>$options</code>属性，并将<code>$options</code>属性挂载到<code>Vue</code>实例上，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">vm.$options = mergeOptions(<br>    resolveConstructorOptions(vm.constructor),<br>    options || &#123;&#125;,<br>    vm<br>)<br></code></pre></td></tr></table></figure>

<p>接着，通过调用一些初始化函数来为<code>Vue</code>实例初始化一些属性，事件，响应式数据等，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">nitLifecycle(vm)       <span class="hljs-comment">// 初始化生命周期</span><br>initEvents(vm)        <span class="hljs-comment">// 初始化事件</span><br>initRender(vm)         <span class="hljs-comment">// 初始化渲染</span><br>callHook(vm, <span class="hljs-string">&#x27;beforeCreate&#x27;</span>)  <span class="hljs-comment">// 调用生命周期钩子函数</span><br>initInjections(vm)   <span class="hljs-comment">//初始化injections</span><br>initState(vm)    <span class="hljs-comment">// 初始化props,methods,data,computed,watch</span><br>initProvide(vm) <span class="hljs-comment">// 初始化 provide</span><br>callHook(vm, <span class="hljs-string">&#x27;created&#x27;</span>)  <span class="hljs-comment">// 调用生命周期钩子函数</span><br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>vue源码理解——生命周期篇</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码理解——实例方法篇</title>
    <url>/2021/03/18/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A35/</url>
    <content><![CDATA[<h4 id="实例方法："><a href="#实例方法：" class="headerlink" title="实例方法："></a>实例方法：</h4><p>与数据相关的实例方法有3个，分别是<code>vm.$set</code>、<code>vm.$delete</code>和<code>vm.$watch</code>。它们是在<code>stateMixin</code>函数中挂载到<code>Vue</code>原型上的，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;set,del&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../observer/index&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stateMixin</span> (<span class="hljs-params">Vue</span>) </span>&#123;<br>    Vue.prototype.$set = set<br>    Vue.prototype.$delete = del<br>    Vue.prototype.$watch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">expOrFn,cb,options</span>) </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当执行<code>stateMixin</code>函数后，会向<code>Vue</code>原型上挂载上述3个实例方法。</p>
<p>接下来，我们就来分析这3个与数据相关的实例方法其内部的原理都是怎样的</p>
<h5 id="vm-watch"><a href="#vm-watch" class="headerlink" title="vm.$watch"></a>vm.$watch</h5><h5 id="用法回顾"><a href="#用法回顾" class="headerlink" title="用法回顾"></a>用法回顾</h5><p>在介绍方法的内部原理之前，我们先根据官方文档示例回顾一下它的用法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">vm.$watch( expOrFn, callback, [options] )<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><p><code>&#123;string | Function&#125; expOrFn</code></p>
</li>
<li><p><code>&#123;Function | Object&#125; callback</code></p>
</li>
<li><pre><code>&#123;Object&#125; [options]
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>    - &#96;&#123;boolean&#125; deep&#96;<br>    - &#96;&#123;boolean&#125; immediate&#96;<br><br>- **返回值**：&#96;&#123;Function&#125; unwatch&#96;<br><br>- **用法**：<br><br>  观察 &#96;Vue&#96; 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。<br><br>  注意：在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象&#x2F;数组。&#96;Vue&#96; 不会保留变异之前值的副本。<br><br>- **示例**：<br><br>  &#96;&#96;&#96;javascript<br>  &#x2F;&#x2F; 键路径<br>  vm.$watch(&#39;a.b.c&#39;, function (newVal, oldVal) &#123;<br>    &#x2F;&#x2F; 做点什么<br>  &#125;)<br>  <br>  &#x2F;&#x2F; 函数<br>  vm.$watch(<br>    function () &#123;<br>      &#x2F;&#x2F; 表达式 &#96;this.a + this.b&#96; 每次得出一个不同的结果时<br>      &#x2F;&#x2F; 处理函数都会被调用。<br>      &#x2F;&#x2F; 这就像监听一个未被定义的计算属性<br>      return this.a + this.b<br>    &#125;,<br>    function (newVal, oldVal) &#123;<br>      &#x2F;&#x2F; 做点什么<br>    &#125;<br>  )<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><code>vm.$watch</code> 返回一个取消观察函数，用来停止触发回调：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> unwatch = vm.$watch(<span class="hljs-string">&#x27;a&#x27;</span>, cb)<br><span class="hljs-comment">// 之后取消观察</span><br>unwatch()<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>选项：deep</strong></p>
<p>为了发现对象内部值的变化，可以在选项参数中指定 <code>deep: true</code> 。注意监听数组的变动不需要这么做。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">vm.$watch(<span class="hljs-string">&#x27;someObject&#x27;</span>, callback, &#123;<br>  deep: <span class="hljs-literal">true</span><br>&#125;)<br>vm.someObject.nestedValue = <span class="hljs-number">123</span><br><span class="hljs-comment">// callback is fired</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>选项：immediate</strong></p>
<p>在选项参数中指定 <code>immediate: true</code> 将立即以表达式的当前值触发回调：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">vm.$watch(<span class="hljs-string">&#x27;a&#x27;</span>, callback, &#123;<br>  immediate: <span class="hljs-literal">true</span><br>&#125;)<br><span class="hljs-comment">// 立即以 `a` 的当前值触发回调</span><br></code></pre></td></tr></table></figure>

<p>注意在带有 <code>immediate</code> 选项时，你不能在第一次回调时取消侦听给定的 property。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这会导致报错</span><br><span class="hljs-keyword">var</span> unwatch = vm.$watch(<br>  <span class="hljs-string">&#x27;value&#x27;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    doSomething()<br>    unwatch()<br>  &#125;,<br>  &#123; <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> &#125;<br>)<br></code></pre></td></tr></table></figure>

<p>如果你仍然希望在回调内部调用一个取消侦听的函数，你应该先检查其函数的可用性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> unwatch = vm.$watch(<br>  <span class="hljs-string">&#x27;value&#x27;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    doSomething()<br>    <span class="hljs-keyword">if</span> (unwatch) &#123;<br>      unwatch()<br>    &#125;<br>  &#125;,<br>  &#123; <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> &#125;<br>)<br></code></pre></td></tr></table></figure>

</li>
</ul>
<p>撸码一时爽，一直撸码一直爽！！！</p>
]]></content>
      <tags>
        <tag>vue源码理解——实例方法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码理解——全局API篇</title>
    <url>/2021/03/18/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A36/</url>
    <content><![CDATA[<h4 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h4><p>与实例方法不同，实例方法是将方法挂载到<code>Vue</code>的原型上，而全局API是直接在<code>Vue</code>上挂载方法。在<code>Vue</code>中，全局API一共有12个，分别是<code>Vue.extend</code>、<code>Vue.nextTick</code>、<code>Vue.set</code>、<code>Vue.delete</code>、<code>Vue.directive</code>、<code>Vue.filter</code>、<code>Vue.component</code>、<code>Vue.use</code>、<code>Vue.mixin</code>、<code>Vue.observable</code>、<code>Vue.version</code>。这12个API中有的是我们在日常业务开发中经常会用到的，有的是对<code>Vue</code>内部或外部插件提供的，我们在日常业务开发中几乎用不到。接下来我们就对这12个API逐个进行分析，看看其内部原理都是怎样的。</p>
<h5 id="Vue-extend"><a href="#Vue-extend" class="headerlink" title="Vue.extend"></a>Vue.extend</h5><h6 id="用法回顾"><a href="#用法回顾" class="headerlink" title="用法回顾"></a>用法回顾</h6><p>其用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">Vue.extend( options )<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>&#123;Object&#125; options</code></li>
</ul>
</li>
<li><p><strong>作用</strong>：</p>
<p>使用基础 <code>Vue</code> 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p>
<p><code>data</code> 选项是特例，需要注意 - 在 <code>Vue.extend()</code> 中它必须是函数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mount-point&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建构造器</span><br><span class="hljs-keyword">var</span> Profile = Vue.extend(&#123;<br>  template: <span class="hljs-string">&#x27;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&#x27;</span>,<br>  data: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      firstName: <span class="hljs-string">&#x27;Walter&#x27;</span>,<br>      lastName: <span class="hljs-string">&#x27;White&#x27;</span>,<br>      alias: <span class="hljs-string">&#x27;Heisenberg&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// 创建 Profile 实例，并挂载到一个元素上。</span><br><span class="hljs-keyword">new</span> Profile().$mount(<span class="hljs-string">&#x27;##mount-point&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Walter White aka Heisenberg<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p>通过用法回顾我们知道，<code>Vue.extend</code>的作用是创建一个继承自<code>Vue</code>类的子类，可接收的参数是一个包含组件选项的对象。</p>
<p>既然是<code>Vue</code>类的子类，那么除了它本身独有的一些属性方法，还有一些是从<code>Vue</code>类中继承而来，所以创建子类的过程其实就是一边给子类上添加上独有的属性，一边将父类的公共属性复制到子类上。接下来，我们就来看看源码是如何实现这个过程的。</p>
<p>该API的定义位于源码的<code>src/core/global-api/extend.js</code>中，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">Vue.extend = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">extendOptions: Object</span>): <span class="hljs-title">Function</span> </span>&#123;<br>    extendOptions = extendOptions || &#123;&#125;<br>    <span class="hljs-keyword">const</span> Super = <span class="hljs-built_in">this</span><br>    <span class="hljs-keyword">const</span> SuperId = Super.cid<br>    <span class="hljs-keyword">const</span> cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)<br>    <span class="hljs-keyword">if</span> (cachedCtors[SuperId]) &#123;<br>        <span class="hljs-keyword">return</span> cachedCtors[SuperId]<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> name = extendOptions.name || Super.options.name<br>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; name) &#123;<br>        validateComponentName(name)<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> Sub = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">VueComponent</span> (<span class="hljs-params">options</span>) </span>&#123;<br>        <span class="hljs-built_in">this</span>._init(options)<br>    &#125;<br>    Sub.prototype = <span class="hljs-built_in">Object</span>.create(Super.prototype)<br>    Sub.prototype.constructor = Sub<br>    Sub.cid = cid++<br>    Sub.options = mergeOptions(<br>        Super.options,<br>        extendOptions<br>    )<br>    Sub[<span class="hljs-string">&#x27;super&#x27;</span>] = Super<br><br>    <span class="hljs-keyword">if</span> (Sub.options.props) &#123;<br>        initProps(Sub)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (Sub.options.computed) &#123;<br>        initComputed(Sub)<br>    &#125;<br><br>    <span class="hljs-comment">// allow further extension/mixin/plugin usage</span><br>    Sub.extend = Super.extend<br>    Sub.mixin = Super.mixin<br>    Sub.use = Super.use<br><br>    <span class="hljs-comment">// create asset registers, so extended classes</span><br>    <span class="hljs-comment">// can have their private assets too.</span><br>    ASSET_TYPES.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>&#123;<br>        Sub[type] = Super[type]<br>    &#125;)<br>    <span class="hljs-comment">// enable recursive self-lookup</span><br>    <span class="hljs-keyword">if</span> (name) &#123;<br>        Sub.options.components[name] = Sub<br>    &#125;<br><br>    Sub.superOptions = Super.options<br>    Sub.extendOptions = extendOptions<br>    Sub.sealedOptions = extend(&#123;&#125;, Sub.options)<br><br>    <span class="hljs-comment">// cache constructor</span><br>    cachedCtors[SuperId] = Sub<br>    <span class="hljs-keyword">return</span> Sub<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，虽然代码量稍微有点多，但是逻辑并不复杂，下面我们就来逐行分析一下。</p>
<p>首先，该函数内部定义了几个变量，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">extendOptions = extendOptions || &#123;&#125;<br><span class="hljs-keyword">const</span> Super = <span class="hljs-built_in">this</span><br><span class="hljs-keyword">const</span> SuperId = Super.cid<br><span class="hljs-keyword">const</span> cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)<br></code></pre></td></tr></table></figure>

<ul>
<li>extendOptions：用户传入的一个包含组件选项的对象参数；</li>
<li>Super：指向父类，即基础 <code>Vue</code>类；</li>
<li>SuperId：父类的<code>cid</code>属性，无论是基础 <code>Vue</code>类还是从基础 <code>Vue</code>类继承而来的类，都有一个<code>cid</code>属性，作为该类的唯一标识；</li>
<li>cachedCtors：缓存池，用于缓存创建出来的类；</li>
</ul>
<p>接着，在缓存池中先尝试获取是否之前已经创建过的该子类，如果之前创建过，则直接返回之前创建的。之所以有这一步，是因为<code>Vue</code>为了性能考虑，反复调用<code>Vue.extend</code>其实应该返回同一个结果，只要返回结果是固定的，就可以将结果缓存，再次调用时，只需从缓存中取出结果即可。在API方法定义的最后，当创建完子类后，会使用父类的<code>cid</code>作为<code>key</code>，创建好的子类作为<code>value</code>，存入缓存池<code>cachedCtors</code>中。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (cachedCtors[SuperId]) &#123;<br>    <span class="hljs-keyword">return</span> cachedCtors[SuperId]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接着，获取到传入的选项参数中的<code>name</code>字段，并且在开发环境下校验<code>name</code>字段是否合法，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = extendOptions.name || Super.options.name<br><span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; name) &#123;<br>    validateComponentName(name)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接着，创建一个类<code>Sub</code>，这个类就是将要继承基础<code>Vue</code>类的子类，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Sub = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">VueComponent</span> (<span class="hljs-params">options</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>._init(options)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到这里，我们已经把类创建好了，接下来的工作就是让该类去继承基础<code>Vue</code>类，让其具备一些基础<code>Vue</code>类的能力。</p>
<p>首先，将父类的原型继承到子类中，并且为子类添加唯一标识<code>cid</code>，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">Sub.prototype = <span class="hljs-built_in">Object</span>.create(Super.prototype)<br>Sub.prototype.constructor = Sub<br>Sub.cid = cid++<br></code></pre></td></tr></table></figure>

<p>接着，将父类的<code>options</code>与子类的<code>options</code>进行合并，将合并结果赋给子类的<code>options</code>属性，如下：</p>
<p>接着，将父类保存到子类的<code>super</code>属性中，以确保在子类中能够拿到父类，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">Sub[<span class="hljs-string">&#x27;super&#x27;</span>] = Super<br></code></pre></td></tr></table></figure>

<p>接着，如果选项中存在<code>props</code>属性，则初始化它，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (Sub.options.props) &#123;<br>    initProps(Sub)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initProps</span> (<span class="hljs-params">Comp</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> props = Comp.options.props<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> props) &#123;<br>    proxy(Comp.prototype, <span class="hljs-string">`_props`</span>, key)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>初始化<code>props</code>属性其实就是把参数中传入的<code>props</code>选项代理到原型的<code>_props</code>中。</p>
<p>接着，如果选项中存在<code>computed</code>属性，则初始化它，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (Sub.options.computed) &#123;<br>    initComputed(Sub)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initComputed</span> (<span class="hljs-params">Comp</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> computed = Comp.options.computed<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> computed) &#123;<br>    defineComputed(Comp.prototype, key, computed[key])<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>初始化<code>props</code>属性就是遍历参数中传入的<code>computed</code>选项，将每一项都调用<code>defineComputed</code>函数定义到子类原型上。此处的<code>defineComputed</code>函数与我们之前在生命周期初始化阶段<code>initState</code>中所介绍的<code>defineComputed</code>函数是一样的。</p>
<p>接着，将父类中的一些属性复制到子类中，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">Sub.extend = Super.extend<br>Sub.mixin = Super.mixin<br>Sub.use = Super.use<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ASSET_TYPES = [<br>  <span class="hljs-string">&#x27;component&#x27;</span>,<br>  <span class="hljs-string">&#x27;directive&#x27;</span>,<br>  <span class="hljs-string">&#x27;filter&#x27;</span><br>]<br><span class="hljs-comment">// create asset registers, so extended classes</span><br><span class="hljs-comment">// can have their private assets too.</span><br>ASSET_TYPES.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>&#123;<br>    Sub[type] = Super[type]<br>&#125;)<br><span class="hljs-comment">// enable recursive self-lookup</span><br><span class="hljs-keyword">if</span> (name) &#123;<br>    Sub.options.components[name] = Sub<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接着，给子类新增三个独有的属性，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">Sub.superOptions = Super.options<br>Sub.extendOptions = extendOptions<br>Sub.sealedOptions = extend(&#123;&#125;, Sub.options)<br></code></pre></td></tr></table></figure>

<p>最后，使用父类的<code>cid</code>作为<code>key</code>，创建好的子类<code>Sub</code>作为<code>value</code>，存入缓存池<code>cachedCtors</code>中。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// cache constructor</span><br>cachedCtors[SuperId] = Sub<br></code></pre></td></tr></table></figure>

<p>最终将创建好的子类<code>Sub</code>返回。</p>
<p>以上，就是<code>Vue.extend</code>的所有逻辑。其实总体来讲，整个过程就是先创建一个类<code>Sub</code>，接着通过原型继承的方式将该类继承基础<code>Vue</code>类，然后给<code>Sub</code>类添加一些属性以及将父类的某些属性复制到<code>Sub</code>类上，最后将<code>Sub</code>类返回。</p>
<p>撸码一时爽，一直撸码一直爽！！！</p>
]]></content>
      <tags>
        <tag>vue源码理解——全局API篇</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序</title>
    <url>/2020/09/18/%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p><img src="https://images.weserv.nl/?url=https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1620680741158-48410cc39150.jpg" alt="img"></p>
<h3 id="微信公众平台"><a href="#微信公众平台" class="headerlink" title="微信公众平台"></a>微信公众平台</h3><p>地址：<a href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com/</a></p>
<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>微信公众平台，简称公众号。曾命名为’官号平台’、’媒体平台’、’微信公众号’，最终定位公众平台</p>
<h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>就是一个简化的app应用，2017年1月9日，微信之父张小龙发布第一款微信小程序</p>
<h5 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h5><ul>
<li>优点</li>
</ul>
<p>1对用户而言，节省了手机内存，即开即用，用户体验好</p>
<p>2对开发者而言</p>
<p>(1) 开发成本（时间   技术   资金）上，接近h5，要比原生app（android   ios）端低</p>
<p>(2 )功能上，接近原生app，比h5强大，比如重力感应  定位等</p>
<ul>
<li>缺点</li>
</ul>
<p>1项目大小是2M限制（分包加载优化）</p>
<p>2分享到朋友圈权限android，不支持ios</p>
<p>3项目发布需要微信团队审核，审核周期1-7日</p>
<p>4功能对于个人开发者有些限制，比如支付  表单提交 （社交分享类）</p>
<h4 id="注册微信小程序开发者账号"><a href="#注册微信小程序开发者账号" class="headerlink" title="注册微信小程序开发者账号"></a>注册微信小程序开发者账号</h4><p>地址</p>
<p><a href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com/</a></p>
<h4 id="微信开发者工具下载安装"><a href="#微信开发者工具下载安装" class="headerlink" title="微信开发者工具下载安装"></a>微信开发者工具下载安装</h4><h5 id="地址："><a href="#地址：" class="headerlink" title="地址："></a>地址：</h5><p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a></p>
<p>下载稳定版</p>
<p>安装时无需注意，一直next就可以了</p>
]]></content>
  </entry>
  <entry>
    <title>vue源码理解——过滤器篇</title>
    <url>/2021/03/18/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A37/</url>
    <content><![CDATA[<h4 id="过虑器"><a href="#过虑器" class="headerlink" title="过虑器"></a>过虑器</h4><p>过滤器在我们日常开发中应该算是一个非常常用的功能了，它经常会被用来格式化模板中的文本。过滤器可以单个使用，也可以多个串联一起使用，还可以传参数使用。那么在<code>Vue</code>中过滤器是如何工作的呢？其内部原理是怎样的？<code>Vue</code>又是如何识别出我们所写的过滤器的？接下来，我们将从源码角度出发，探究过滤器内部的工作原理，分析其工作流程，揭开它神秘的面纱。</p>
<p>撸码一时爽，一直撸码一直爽！！！</p>
]]></content>
      <tags>
        <tag>vue源码理解——过滤器篇</tag>
      </tags>
  </entry>
  <entry>
    <title>算法理解</title>
    <url>/2020/09/18/%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="https://images.weserv.nl/?url=https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1621940022939-67cbe6a348d8.jpg" alt="img"></p>
<h5 id="两数之和："><a href="#两数之和：" class="headerlink" title="两数之和："></a>两数之和：</h5><p>​    思路（javaScript）：使用map函数，利用差值判断并返回值。</p>
<p>​    代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">var</span> findSum=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums,target</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span>  map=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>,len=nums.length;i&lt;len;i++)&#123;<br>        <br>        <span class="hljs-comment">//利用差值判断是否有存在与其对应的值</span><br>        <span class="hljs-keyword">let</span> key =target-nums[i]<br>        <span class="hljs-keyword">if</span>(map.has(key))&#123;<br>            <span class="hljs-keyword">return</span> [map.get(key),i]<br>        &#125;<br>        map.set(nums[i],i)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h5 id="整数反转："><a href="#整数反转：" class="headerlink" title="整数反转："></a>整数反转：</h5><p>​    思路（javaScript）：利用对10取余，向下取整，二者对应的思想</p>
<p>​    代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fn=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> res=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(num)&#123;<br>        res=res*<span class="hljs-number">10</span>+num%<span class="hljs-number">10</span><br>        <span class="hljs-comment">//res &gt; Math.pow(2, 31) - 1 || res &lt; Math.pow(-2, 31)字节的最小和最大</span><br>        <span class="hljs-keyword">if</span>(res &gt; <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>) - <span class="hljs-number">1</span> || res &lt; <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">-2</span>, <span class="hljs-number">31</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br>        <span class="hljs-comment">// ~~可以理解向下取整，类似Math.floor()</span><br>        num=~~(num/<span class="hljs-number">10</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="正序数组的中位数："><a href="#正序数组的中位数：" class="headerlink" title="正序数组的中位数："></a>正序数组的中位数：</h5><p>思路（javaScript）：合并数组（concat）并排序（.sort（a,b）=&gt;a-b），在用下标对2取余如果是奇数就就取[nums  .length / 2],如果是偶数就取(nums[nums.length/2-1]+nums[nums/2])/2</p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> find = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums1, nums2</span>) </span>&#123;<br>       <span class="hljs-keyword">let</span> nums = nums1.concat(nums2).sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)<br>       <span class="hljs-keyword">return</span> nums.length % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? (nums[nums.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] + nums[nums.length / <span class="hljs-number">2</span>]) / <span class="hljs-number">2</span> : nums[<span class="hljs-built_in">Math</span>.floor(nums<br>          .length / <span class="hljs-number">2</span>)]<br>    &#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法理解</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码理解——指令篇</title>
    <url>/2021/03/18/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A38/</url>
    <content><![CDATA[<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>在<code>Vue</code>中，除了<code>Vue</code>本身为我们提供的一些内置指令之外，<code>Vue</code>还支持用户自定义指令。并且用户有两种定义指令的方式：一种是使用全局API——<code>Vue.directive</code>来定义全局指令，这种方式定义的指令会被存放在<code>Vue.options[&#39;directives&#39;]</code>中；另一种是在组件内的<code>directive</code>选项中定义专为该组件使用的局部指令，这种方式定义的指令会被存放在<code>vm.$options[&#39;directives&#39;]</code>中。</p>
<p>可以看到，无论是使用哪一种方式定义的指令它都是将定义好的指令存放在指定的地方，而并不能让指令生效。那么定义的指令什么时候才会生效呢？或者说它是如何生效的呢？本篇文章就来带你探究自定义指令如何生效的内部原理。</p>
<p>撸码一时爽，一直撸码一直爽！！！</p>
]]></content>
      <tags>
        <tag>vue源码理解——指令篇</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码理解——内置组件篇</title>
    <url>/2021/03/18/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A39/</url>
    <content><![CDATA[<h4 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h4><p><code>&lt;keep-alive&gt;</code> 是 <code>Vue</code> 实现的一个内置组件，也就是说 <code>Vue</code> 源码不仅实现了一套组件化的机制，也实现了一些内置组件，关于<code>&lt;keep-alive&gt;</code>组件，官网如下介绍：</p>
<blockquote>
<p><code>&lt;keep-alive&gt;</code>是<code>Vue</code>中内置的一个抽象组件，它自身不会渲染一个 <code>DOM</code> 元素，也不会出现在父组件链中。当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。</p>
</blockquote>
<p>这句话的意思简单来说：就是我们可以把一些不常变动的组件或者需要缓存的组件用<code>&lt;keep-alive&gt;</code>包裹起来，这样<code>&lt;keep-alive&gt;</code>就会帮我们把组件保存在内存中，而不是直接的销毁，这样做可以保留组件的状态或避免多次重新渲染，以提高页面性能。</p>
<p>撸码一时爽，一直撸码一直爽！！！</p>
]]></content>
      <tags>
        <tag>vue源码理解——内置组件篇</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript 1</title>
    <url>/2020/09/22/javascript/</url>
    <content><![CDATA[<p><img src="https://images.weserv.nl/?url=https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1625903443536-ec7e0e5fc341.jpg" alt="img"></p>
<h1 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h1><h3 id="1-JavaScript-是什么"><a href="#1-JavaScript-是什么" class="headerlink" title="1 JavaScript 是什么"></a>1 JavaScript 是什么</h3><p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/图片7.png"></p>
<ul>
<li><p>JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 是脚本的意思）</p>
</li>
<li><p>脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行</p>
</li>
<li><p>现在也可以基于 Node.js 技术进行服务器端编程</p>
<p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/图片8.png"></p>
</li>
</ul>
<h3 id="3-2-JavaScript的作用"><a href="#3-2-JavaScript的作用" class="headerlink" title="3.2 JavaScript的作用"></a>3.2 JavaScript的作用</h3><ul>
<li>表单动态校验（密码强度检测）  （ JS 产生最初的目的 ）</li>
<li>网页特效</li>
<li>服务端开发(Node.js)</li>
<li>桌面程序(Electron)</li>
<li>App(Cordova) </li>
<li>控制硬件-物联网(Ruff)</li>
<li>游戏开发(cocos2d-js)</li>
</ul>
<h3 id="3-3-HTML-CSS-JS-的关系"><a href="#3-3-HTML-CSS-JS-的关系" class="headerlink" title="3.3 HTML/CSS/JS 的关系"></a>3.3 HTML/CSS/JS 的关系</h3><p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/图片9.png"></p>
<h3 id="3-4-浏览器执行-JS-简介"><a href="#3-4-浏览器执行-JS-简介" class="headerlink" title="3.4 浏览器执行 JS 简介"></a>3.4 浏览器执行 JS 简介</h3><p><strong>浏览器分成两部分：渲染引擎和 JS 引擎</strong></p>
<p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/neihe.png"></p>
<pre><code>    浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。</code></pre>
<p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/图片10.png"></p>
<h3 id="3-5-JS-的组成"><a href="#3-5-JS-的组成" class="headerlink" title="3.5 JS 的组成"></a>3.5 JS 的组成</h3><p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/图片11.png"></p>
<h4 id="1-ECMAScript"><a href="#1-ECMAScript" class="headerlink" title="1.ECMAScript"></a><strong>1.ECMAScript</strong></h4><p>​        ECMAScript 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。</p>
<p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/图片12.png"></p>
<p>​        ECMAScript：规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。</p>
<p>更多参看MDN: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview">MDN手册</a></p>
<h4 id="2-DOM——文档对象模型"><a href="#2-DOM——文档对象模型" class="headerlink" title="2.DOM——文档对象模型"></a><strong>2.DOM——文档对象模型</strong></h4><p>​        <strong>文档对象模型</strong>（DocumentObject Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）</p>
<h4 id="3-BOM——浏览器对象模型"><a href="#3-BOM——浏览器对象模型" class="headerlink" title="3.BOM——浏览器对象模型"></a><strong>3.BOM——浏览器对象模型</strong></h4><p>​        <strong>浏览器对象模型</strong>(Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</p>
<h3 id="3-6-JavaScript的特点"><a href="#3-6-JavaScript的特点" class="headerlink" title="3.6  JavaScript的特点"></a>3.6  JavaScript的特点</h3><p>​        JavaScript是基于对象和事件驱动的解释性的脚本语言，适用于静态或动态页面，是一种广泛使用的客户端脚本语言，它具有解释性、基于对象、事件驱动、安全性和跨平台等特点。</p>
<h4 id="1-解释性"><a href="#1-解释性" class="headerlink" title="1.  解释性"></a>1.  解释性</h4><p>JavaScript 不同于一些编译性的程序语言，例如 C、C++ 等，他是一种解释性的程序语言，它的源代码不需要经过编译，而直接在浏览器种运行时被解析。</p>
<h4 id="2-基于对象"><a href="#2-基于对象" class="headerlink" title="2.  基于对象"></a>2.  基于对象</h4><p>JavaScript 是一种基于对象的语言，这意味着它能运用自己已经创建的对象，因此，许多功能可以来自脚本环境中对象的方法与脚本的相互作用。</p>
<h4 id="3-事件驱动"><a href="#3-事件驱动" class="headerlink" title="3.  事件驱动"></a>3.  事件驱动</h4><p>JavaScript 可以直接对用户或者客户输入做出响应，无须经过 web 服务器，它对用户的响应，以事件驱动的方式进行。</p>
<h4 id="4-跨平台"><a href="#4-跨平台" class="headerlink" title="4.  跨平台"></a>4.  跨平台</h4><p>JavaScript依赖于浏览器本身，与操作环境无关，只要能运行浏览器的计算机，并支持 JavaScript 的浏览器就可正常执行。</p>
<h3 id="3-7-JS-初体验"><a href="#3-7-JS-初体验" class="headerlink" title="3.7 JS 初体验"></a>3.7 JS 初体验</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">JS 有<span class="hljs-number">3</span>种书写位置，分别为行内、内嵌和外部。<br></code></pre></td></tr></table></figure>

<ol>
<li><p>行内式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;点我试试&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Hello World&#x27;)&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），如：onclick</li>
<li>注意单双引号的使用：在HTML中我们推荐使用双引号, JS 中我们推荐使用单引号</li>
<li>可读性差， 在html中编写JS大量代码时，不方便阅读；</li>
<li>引号易错，引号多层嵌套匹配时，非常容易弄混；</li>
<li>特殊情况下使用</li>
</ul>
</li>
<li><p>内嵌式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    alert(<span class="hljs-string">&#x27;Hello  World~!&#x27;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>可以将多行JS代码写到 script 标签中</li>
<li>内嵌 JS 是学习时常用的方式</li>
</ul>
</li>
<li><p>外部JS文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;my.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>利于HTML页面代码结构化，把大段 JS代码独立到 HTML 页面之外，既美观，也方便文件级别的复用</li>
<li>引用外部 JS文件的 script 标签中间不可以写代码</li>
<li>适合于JS 代码量比较大的情况</li>
</ul>
</li>
</ol>
<h2 id="4-JavaScript注释"><a href="#4-JavaScript注释" class="headerlink" title="4 - JavaScript注释"></a>4 - JavaScript注释</h2><h4 id="4-1-单行注释"><a href="#4-1-单行注释" class="headerlink" title="4.1  单行注释"></a>4.1  单行注释</h4><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">为了提高代码的可读性，JS与CSS一样，也提供了注释功能。<br>JS中的注释主要有两种，分别是 单行注释 和 多行注释。<br></code></pre></td></tr></table></figure>

<p>单行注释的注释方式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">// 我是一行文字，不想被 JS引擎 执行，所以 注释起来	<br></code></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">// 用来注释单行文字（  快捷键   ctrl  +  /   ）<br></code></pre></td></tr></table></figure>

<h4 id="4-2-多行注释"><a href="#4-2-多行注释" class="headerlink" title="4.2 多行注释"></a>4.2 多行注释</h4><p>多行注释的注释方式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">/*<br>  获取用户年龄和姓名<br>  并通过提示框显示出来<br>*/<br></code></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">/* */  用来注释多行文字（ 默认快捷键  alt +  shift  + a ） <br></code></pre></td></tr></table></figure>

<p>快捷键修改为：   ctrl + command  +  /</p>
<p>vscode → 首选项按钮 → 键盘快捷方式 → 查找 原来的快捷键 → 修改为新的快捷键 → 回车确认</p>
<h2 id="5-JavaScript输入输出语句"><a href="#5-JavaScript输入输出语句" class="headerlink" title="5 - JavaScript输入输出语句"></a>5 - JavaScript输入输出语句</h2><p>为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th align="left">说明</th>
<th>归属</th>
</tr>
</thead>
<tbody><tr>
<td>alert(msg)</td>
<td align="left">浏览器弹出警示框</td>
<td>浏览器</td>
</tr>
<tr>
<td>console.log(msg)</td>
<td align="left">浏览器控制台打印输出信息</td>
<td>浏览器</td>
</tr>
<tr>
<td>prompt(info)</td>
<td align="left">浏览器弹出输入框，用户可以输入</td>
<td>浏览器</td>
</tr>
</tbody></table>
<ul>
<li>注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。</li>
</ul>
<h2 id="6-事件基础"><a href="#6-事件基础" class="headerlink" title="6 - 事件基础"></a>6 - 事件基础</h2><h4 id="6-1-事件概述"><a href="#6-1-事件概述" class="headerlink" title="6.1. 事件概述"></a>6.1. 事件概述</h4><p>​     JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。</p>
<p>简单理解： <strong>触发— 响应机制</strong>。</p>
<p>​    网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。</p>
<h4 id="6-2-事件三要素"><a href="#6-2-事件三要素" class="headerlink" title="6.2  事件三要素"></a>6.2  事件三要素</h4><p>交互效果可以遵循简单三步曲来实现：</p>
<ul>
<li>事件源（谁）：触发事件的元素</li>
<li>事件类型（什么事件）： 例如 click 点击事件</li>
<li>事件处理程序（做啥）：事件触发后要执行的代码(函数形式)，事件处理函数</li>
</ul>
<h4 id="6-3-js获取标签"><a href="#6-3-js获取标签" class="headerlink" title="6.3 js获取标签"></a>6.3 js获取标签</h4><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>  /*<br><span class="javascript"> <span class="hljs-built_in">document</span>:文档</span><br> get:获取<br> Element:元素<br> By:通过<br> Id:ID名<br> */<br><span class="javascript"> alert(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;div1&quot;</span>));  <span class="hljs-comment">//[object HTMLDivElement]</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>事件案例代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;唐伯虎&lt;/button&gt;<br>    &lt;script&gt;<br>        <span class="hljs-comment">// 点击一个按钮，弹出对话框</span><br>        <span class="hljs-comment">// 1. 事件是有三部分组成  事件源  事件类型  事件处理程序   我们也称为事件三要素</span><br>        <span class="hljs-comment">//(1) 事件源 事件被触发的对象   谁  按钮</span><br>        <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>);<br>        <span class="hljs-comment">//(2) 事件类型  如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下</span><br>        <span class="hljs-comment">//(3) 事件处理程序  通过一个函数赋值的方式 完成</span><br>        btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            alert(<span class="hljs-string">&#x27;点秋香&#x27;</span>);<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

<h4 id="6-4-执行事件的步骤"><a href="#6-4-执行事件的步骤" class="headerlink" title="6.4. 执行事件的步骤"></a>6.4. 执行事件的步骤</h4><p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550734387056.png" alt="1550734387056"></p>
<p><strong>案例代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div&gt;<span class="hljs-number">123</span>&lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-comment">// 执行事件步骤</span><br>        <span class="hljs-comment">// 点击div 控制台输出 我被选中了</span><br>        <span class="hljs-comment">// 1. 获取事件源</span><br>        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        <span class="hljs-comment">// 2.绑定事件 注册事件</span><br>        <span class="hljs-comment">// div.onclick </span><br>        <span class="hljs-comment">// 3.添加事件处理程序 </span><br>        div.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我被选中了&#x27;</span>);<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

<h4 id="6-5-常见的鼠标事件"><a href="#6-5-常见的鼠标事件" class="headerlink" title="6.5. 常见的鼠标事件"></a>6.5. 常见的鼠标事件</h4><p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550734506084.png" alt="1550734506084"></p>
<h4 id="6-6-分析事件三要素"><a href="#6-6-分析事件三要素" class="headerlink" title="6.6. 分析事件三要素"></a>6.6. 分析事件三要素</h4><ul>
<li>下拉菜单三要素</li>
<li>关闭广告三要素</li>
</ul>
<h4 id="6-7-添加事件"><a href="#6-7-添加事件" class="headerlink" title="6.7  添加事件"></a>6.7  添加事件</h4><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>/*<br>onclick:单击事件<br>*/<br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;div1&quot;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript"> <span class="hljs-comment">// 存放 展示效果的代码块</span></span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="6-8-点击按钮触发事件弹出-hello-world"><a href="#6-8-点击按钮触发事件弹出-hello-world" class="headerlink" title="6.8  点击按钮触发事件弹出 hello world"></a>6.8  点击按钮触发事件弹出 hello world</h4><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;but&quot;</span>&gt;</span>弹出<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>/*<br><span class="javascript"><span class="hljs-number">1.</span> 找到谁 按钮 <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;but&quot;</span>);</span><br>2. 加事件 ( 点击事件 ) 标签.onclick<br><span class="javascript"><span class="hljs-number">3.</span> 要做的事情 (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;&#125;)</span><br><span class="javascript">语法：标签.事件 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;要做的事情&#125;</span><br>*/<br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;but&quot;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">   alert(<span class="hljs-string">&quot;hello world&quot;</span>);</span><br>&#125;<br> <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="7-window-onload"><a href="#7-window-onload" class="headerlink" title="7 - window.onload"></a>7 - window.onload</h2><p>window.onload的作用是，当文档和资源都加载完成后调用。</p>
<p>​        当我们把script标签放在head里面去获取元素的时候，我们会发现获取到的值为null，那是因为代码是从上往下执行，当获取标签的时候，标签还没有被加载。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">   <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;but&quot;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">	 alert(<span class="hljs-string">&quot;hello world&quot;</span>);</span><br>  &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;but&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="8-其他事件"><a href="#8-其他事件" class="headerlink" title="8 - 其他事件"></a>8 - 其他事件</h2><p>​        js 的事件有很多，如鼠标事件，键盘事件，文本事件，窗口事件等等，这些后期会讲，我们这里先掌握简单的鼠标事件。</p>
<p>鼠标事件除了点击onclick之外，还有很多其他的鼠标事件，具体如下：</p>
<ul>
<li>onclick ：点击事件</li>
<li>ondblclick ：双击事件</li>
<li>onmouseover ： 鼠标移入元素</li>
<li>onmouseout :  鼠标离开元素</li>
<li>onmouseenter ：鼠标移入元素</li>
<li>onmouseleave ：鼠标离开元素</li>
<li>onmousemove:  鼠标在元素中移动</li>
<li>onmousedown： 鼠标按下</li>
<li>onmouseup： 鼠标抬起</li>
<li>oncontextmenu ：鼠标右键菜单事件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">// 1.onclick ：点击事件</span></span><br><span class="javascript">    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;box&quot;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;点击了&quot;</span>);</span><br>    &#125;<br><span class="javascript">    <span class="hljs-comment">// 2.onmouseover ：鼠标移入元素</span></span><br><span class="javascript">    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;box&quot;</span>).onmouseover = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;鼠标移入元素&quot;</span>);</span><br>    &#125;<br><span class="javascript">    <span class="hljs-comment">// ......</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>我是box<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="9-变量的概念"><a href="#9-变量的概念" class="headerlink" title="9 - 变量的概念"></a>9 - 变量的概念</h2><h4 id="9-1-什么是变量"><a href="#9-1-什么是变量" class="headerlink" title="9.1 什么是变量"></a>9.1 什么是变量</h4><p>白话：变量就是一个装东西的盒子。</p>
<p>通俗：变量是用于存放数据的容器。 我们通过 变量名 获取数据，甚至数据可以修改。<br><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/图片13.png"></p>
<h4 id="9-2-变量在内存中的存储"><a href="#9-2-变量在内存中的存储" class="headerlink" title="9.2 变量在内存中的存储"></a>9.2 变量在内存中的存储</h4><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">本质：变量是程序在内存中申请的一块用来存放数据的空间。类似我们酒店的房间，一个房间就可以看做是一个变量。 <br></code></pre></td></tr></table></figure>

<p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/图片14.png" alt="图片14"></p>
<h2 id="10-变量的使用"><a href="#10-变量的使用" class="headerlink" title="10 - 变量的使用"></a>10 - 变量的使用</h2><ul>
<li>变量的声明   </li>
<li>变量的赋值 </li>
</ul>
<h4 id="10-1-声明变量"><a href="#10-1-声明变量" class="headerlink" title="10.1 声明变量"></a>10.1 声明变量</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//  声明变量  </span><br><span class="hljs-keyword">var</span> age; <span class="hljs-comment">//  声明一个 名称为age 的变量     </span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>var 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管</p>
</li>
<li><p>age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间</p>
</li>
</ul>
<h4 id="10-2-赋值"><a href="#10-2-赋值" class="headerlink" title="10.2 赋值"></a>10.2 赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">age = <span class="hljs-number">10</span>; <span class="hljs-comment">// 给 age  这个变量赋值为 10        </span><br></code></pre></td></tr></table></figure>

<ul>
<li>= 用来把右边的值赋给左边的变量空间中   此处代表赋值的意思</li>
<li>变量值是程序员保存到变量空间里的值</li>
</ul>
<h4 id="10-3-变量的初始化"><a href="#10-3-变量的初始化" class="headerlink" title="10.3 变量的初始化"></a>10.3 变量的初始化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age  = <span class="hljs-number">18</span>;  <span class="hljs-comment">// 声明变量同时赋值为 18</span><br><span class="hljs-comment">// 声明一个变量并赋值， 我们称之为变量的初始化。</span><br></code></pre></td></tr></table></figure>

<h4 id="10-4-变量语法扩展"><a href="#10-4-变量语法扩展" class="headerlink" title="10.4 变量语法扩展"></a>10.4 变量语法扩展</h4><ul>
<li>更新变量</li>
</ul>
<p>​           一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>;<br>age = <span class="hljs-number">81</span>;   <span class="hljs-comment">// 最后的结果就是81因为18 被覆盖掉了  </span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>同时声明多个变量</p>
<p>​        同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。    </p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span>,  name = <span class="hljs-string">&#x27;zs&#x27;</span>, sex = <span class="hljs-number">2</span>;       <br></code></pre></td></tr></table></figure>

<ul>
<li><p>声明变量特殊情况</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>var  age ; console.log (age);</td>
<td>只声明 不赋值</td>
<td>undefined</td>
</tr>
<tr>
<td>console.log(age)</td>
<td>不声明 不赋值  直接使用</td>
<td>报错</td>
</tr>
<tr>
<td>age   = 10; console.log (age);</td>
<td>不声明   只赋值</td>
<td>10</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="10-5-变量命名规范"><a href="#10-5-变量命名规范" class="headerlink" title="10.5 变量命名规范"></a>10.5 变量命名规范</h4><p>规则：</p>
<ul>
<li>由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name</li>
<li>严格区分大小写。var app; 和 var App; 是两个变量</li>
<li>不能 以数字开头。  18age   是错误的</li>
<li>不能 是关键字、保留字。例如：var、for、while</li>
<li>变量名必须有意义。 MMD   BBD        nl   →     age  </li>
<li>遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName![](/Users/mac/Desktop/one/第一章 JavaScript初识/笔记/图片15.png)</li>
</ul>
<p>推荐翻译网站： 有道    爱词霸</p>
<h2 id="11-操作元素"><a href="#11-操作元素" class="headerlink" title="11 - 操作元素"></a>11 - 操作元素</h2><p>​    JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的）</p>
<h4 id="11-1-改变元素内容（获取或设置）"><a href="#11-1-改变元素内容（获取或设置）" class="headerlink" title="11.1. 改变元素内容（获取或设置）"></a>11.1. 改变元素内容（获取或设置）</h4><p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550735016756.png" alt="1550735016756"></p>
<p><strong>innerText改变元素内容</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;button&gt;显示当前系统时间&lt;/button&gt;<br>    &lt;div&gt;某个时间&lt;/div&gt;<br>    &lt;p&gt;<span class="hljs-number">1123</span>&lt;/p&gt;<br>    &lt;script&gt;<br>        <span class="hljs-comment">// 当我们点击了按钮，  div里面的文字会发生变化</span><br>        <span class="hljs-comment">// 1. 获取元素 </span><br>        <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);<br>        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        <span class="hljs-comment">// 2.注册事件</span><br>        btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// div.innerText = &#x27;2019-6-6&#x27;;</span><br>            div.innerHTML = getDate();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDate</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>            <span class="hljs-comment">// 我们写一个 2019年 5月 1日 星期三</span><br>            <span class="hljs-keyword">var</span> year = date.getFullYear();<br>            <span class="hljs-keyword">var</span> month = date.getMonth() + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">var</span> dates = date.getDate();<br>            <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;星期日&#x27;</span>, <span class="hljs-string">&#x27;星期一&#x27;</span>, <span class="hljs-string">&#x27;星期二&#x27;</span>, <span class="hljs-string">&#x27;星期三&#x27;</span>, <span class="hljs-string">&#x27;星期四&#x27;</span>, <span class="hljs-string">&#x27;星期五&#x27;</span>, <span class="hljs-string">&#x27;星期六&#x27;</span>];<br>            <span class="hljs-keyword">var</span> day = date.getDay();<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;今天是：&#x27;</span> + year + <span class="hljs-string">&#x27;年&#x27;</span> + month + <span class="hljs-string">&#x27;月&#x27;</span> + dates + <span class="hljs-string">&#x27;日 &#x27;</span> + arr[day];<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

<p><strong>innerText和innerHTML的区别</strong></p>
<ul>
<li>获取内容时的区别：</li>
</ul>
<p>​    innerText会去除空格和换行，而innerHTML会保留空格和换行    </p>
<ul>
<li>设置内容时的区别：</li>
</ul>
<p>​    innerText不会识别html，而innerHTML会识别</p>
<p><strong>案例代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div&gt;&lt;/div&gt;<br>    &lt;p&gt;<br>        我是文字<br>        &lt;span&gt;<span class="hljs-number">123</span>&lt;/span&gt;<br>    &lt;/p&gt;<br>    &lt;script&gt;<br>        <span class="hljs-comment">// innerText 和 innerHTML的区别 </span><br>        <span class="hljs-comment">// 1. innerText 不识别html标签 非标准  去除空格和换行</span><br>        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        <span class="hljs-comment">// div.innerText = &#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;;</span><br>        <span class="hljs-comment">// 2. innerHTML 识别html标签 W3C标准 保留空格和换行的</span><br>        div.innerHTML = <span class="hljs-string">&#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;</span>;<br>        <span class="hljs-comment">// 这两个属性是可读写的  可以获取元素里面的内容</span><br>        <span class="hljs-keyword">var</span> p = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;p&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(p.innerText);<br>        <span class="hljs-built_in">console</span>.log(p.innerHTML);<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

<h2 id="12-常用元素的属性操作"><a href="#12-常用元素的属性操作" class="headerlink" title="12 - 常用元素的属性操作"></a>12 - 常用元素的属性操作</h2><p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550735556297.png" alt="1550735556297"></p>
<p><strong>获取属性的值</strong></p>
<p>元素对象.属性名</p>
<p><strong>设置属性的值</strong></p>
<p>元素对象.属性名 = 值</p>
<p><strong>案例代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;button id=<span class="hljs-string">&quot;ldh&quot;</span>&gt;刘德华&lt;/button&gt;<br>    &lt;button id=<span class="hljs-string">&quot;zxy&quot;</span>&gt;张学友&lt;/button&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br>    &lt;img src=&quot;images/ldh.jpg&quot; alt=&quot;&quot; title=&quot;刘德华&quot;&gt;<br>    &lt;script&gt;<br>        // 修改元素属性  src<br>        // 1. 获取元素<br>        var ldh = document.getElementById(&#x27;ldh&#x27;);<br>        var zxy = document.getElementById(&#x27;zxy&#x27;);<br>        var img = document.querySelector(&#x27;img&#x27;);<br>        // 2. 注册事件  处理程序<br>        zxy.onclick = function() &#123;<br>            img.src = &#x27;images/zxy.jpg&#x27;;<br>            img.title = &#x27;张学友思密达&#x27;;<br>        &#125;<br>        ldh.onclick = function() &#123;<br>            img.src = &#x27;images/ldh.jpg&#x27;;<br>            img.title = &#x27;刘德华&#x27;;<br>        &#125;<br>    &lt;/script&gt;<br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<h4 id="12-1-案例：分时问候"><a href="#12-1-案例：分时问候" class="headerlink" title="12.1. 案例：分时问候"></a>12.1. 案例：分时问候</h4><p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550735858049.png" alt="1550735858049"></p>
<p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550735877145.png" alt="1550735877145"></p>
<h2 id="13-表单元素的属性操作"><a href="#13-表单元素的属性操作" class="headerlink" title="13 - 表单元素的属性操作"></a>13 - 表单元素的属性操作</h2><p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736039005.png" alt="1550736039005"></p>
<p><strong>获取属性的值</strong></p>
<p>元素对象.属性名</p>
<p><strong>设置属性的值</strong></p>
<p>元素对象.属性名 = 值</p>
<p>表单元素中有一些属性如：disabled、checked、selected，元素对象的这些属性的值是布尔型。</p>
<p><strong>案例代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;button&gt;按钮&lt;/button&gt;<br>    &lt;input type=<span class="hljs-string">&quot;text&quot;</span> value=<span class="hljs-string">&quot;输入内容&quot;</span>&gt;<br>    &lt;script&gt;<br>        <span class="hljs-comment">// 1. 获取元素</span><br>        <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);<br>        <span class="hljs-keyword">var</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>);<br>        <span class="hljs-comment">// 2. 注册事件 处理程序</span><br>        btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// 表单里面的值 文字内容是通过 value 来修改的</span><br>            input.value = <span class="hljs-string">&#x27;被点击了&#x27;</span>;<br>            <span class="hljs-comment">// 如果想要某个表单被禁用 不能再点击 disabled  我们想要这个按钮 button禁用</span><br>            <span class="hljs-comment">// btn.disabled = true;</span><br>            <span class="hljs-built_in">this</span>.disabled = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// this 指向的是事件函数的调用者 btn</span><br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

<h4 id="13-1-仿京东显示密码"><a href="#13-1-仿京东显示密码" class="headerlink" title="13.1. 仿京东显示密码"></a>13.1. 仿京东显示密码</h4><p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736330331.png" alt="1550736330331"></p>
<p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736346822.png" alt="1550736346822"></p>
<h2 id="14-点操作符和中括号操作符使用"><a href="#14-点操作符和中括号操作符使用" class="headerlink" title="14 - 点操作符和中括号操作符使用"></a>14 - 点操作符和中括号操作符使用</h2><ul>
<li>是某一个具体的属性值是，用点操作符。</li>
<li>当是某一个变量时，用中括号操作符，中括号里面放这个变量。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;div id=<span class="hljs-string">&quot;box&quot;</span> title=<span class="hljs-string">&quot;优就业&quot;</span>&gt;中公教育&lt;/div&gt;<br>&lt;script&gt;<br><span class="hljs-keyword">var</span> oDiv = <span class="hljs-built_in">document</span>.getElementById(box<span class="hljs-string">&quot;);</span><br><span class="hljs-string">// 1.获取title属性值</span><br><span class="hljs-string">var t= oDiv[&quot;</span>title<span class="hljs-string">&quot;];</span><br><span class="hljs-string">console.log(t);</span><br><span class="hljs-string"></span><br><span class="hljs-string">// 2.设置title属性</span><br><span class="hljs-string">oDiv[&quot;</span>title<span class="hljs-string">&quot;] = &quot;</span>web全栈<span class="hljs-string">&quot;;</span><br><span class="hljs-string"></span><br><span class="hljs-string">// 3.中括号操作符的正确使用场景</span><br><span class="hljs-string">var tit = ‘title’;</span><br><span class="hljs-string">console.log(oDiv[tit]); // 当是变量时，就只能使用中括号操作符，不能使用点操作符</span><br><span class="hljs-string">&lt;/script&gt;</span><br></code></pre></td></tr></table></figure>

<h6 id="注意：当把属性名赋值给一个变量的时候，就可以通过使用中括号-来操作变量，就可以操作这个属性"><a href="#注意：当把属性名赋值给一个变量的时候，就可以通过使用中括号-来操作变量，就可以操作这个属性" class="headerlink" title="注意：当把属性名赋值给一个变量的时候，就可以通过使用中括号  []来操作变量，就可以操作这个属性"></a>注意：当把属性名赋值给一个变量的时候，就可以通过使用中括号  <code>[]</code>来操作变量，就可以操作这个属性</h6><h2 id="15-样式属性操作"><a href="#15-样式属性操作" class="headerlink" title="15 - 样式属性操作"></a>15 - 样式属性操作</h2><p>元素样式是写在 style 标签或 style 属性中，用来设置元素的外观的。</p>
<p>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</p>
<p>js操作的样式全部属于行内样式</p>
<p><strong>常用方式</strong></p>
<p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736488634.png" alt="1550736488634"></p>
<h4 id="方式1：通过操作style属性"><a href="#方式1：通过操作style属性" class="headerlink" title="方式1：通过操作style属性"></a>方式1：通过操作style属性</h4><p>语法：</p>
<ul>
<li>获取元素样式属性：元素.style.样式</li>
<li>设置元素样式属性：元素.style.样式名 = “样式值”</li>
</ul>
<p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736620181.png" alt="1550736620181"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    &lt;div&gt;&lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-comment">// 1. 获取元素</span><br>        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        <span class="hljs-comment">// 2. 注册事件 处理程序</span><br>        div.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// div.style里面的属性 采取驼峰命名法 </span><br>            div.style.backgroundColor = <span class="hljs-string">&#x27;purple&#x27;</span>;<br>            div.style.width = <span class="hljs-string">&#x27;250px&#x27;</span>;<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

<h4 id="案例：淘宝点击关闭二维码"><a href="#案例：淘宝点击关闭二维码" class="headerlink" title="案例：淘宝点击关闭二维码"></a>案例：淘宝点击关闭二维码</h4><p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736843659.png" alt="1550736843659"></p>
<p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736881832.png" alt="1550736881832"></p>
<h4 id="案例：循环精灵图背景"><a href="#案例：循环精灵图背景" class="headerlink" title="案例：循环精灵图背景"></a>案例：循环精灵图背景</h4><p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736940082.png" alt="1550736940082"></p>
<p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736956754.png" alt="1550736956754"></p>
<h4 id="案例：显示隐藏文本框内容"><a href="#案例：显示隐藏文本框内容" class="headerlink" title="案例：显示隐藏文本框内容"></a>案例：显示隐藏文本框内容</h4><p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550737006593.png" alt="1550737006593"></p>
<p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550737019729.png" alt="1550737019729"></p>
<h4 id="方式2：通过操作className属性"><a href="#方式2：通过操作className属性" class="headerlink" title="方式2：通过操作className属性"></a>方式2：通过操作className属性</h4><p>元素对象.className = 值;</p>
<p>因为class是关键字，所有使用className。</p>
<p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550737214510.png" alt="1550737214510"></p>
<p><strong>案例代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;first&quot;</span>&gt;文本&lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-comment">// 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用</span><br>        <span class="hljs-keyword">var</span> test = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        test.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// this.style.backgroundColor = &#x27;purple&#x27;;</span><br>            <span class="hljs-comment">// this.style.color = &#x27;#fff&#x27;;</span><br>            <span class="hljs-comment">// this.style.fontSize = &#x27;25px&#x27;;</span><br>            <span class="hljs-comment">// this.style.marginTop = &#x27;100px&#x27;;</span><br><br>            <span class="hljs-comment">// 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况</span><br>            <span class="hljs-comment">// 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器</span><br>            <span class="hljs-comment">// this.className = &#x27;change&#x27;;</span><br>            <span class="hljs-built_in">this</span>.className = <span class="hljs-string">&#x27;first change&#x27;</span>;<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

<h4 id="案例：密码框格式提示错误信息"><a href="#案例：密码框格式提示错误信息" class="headerlink" title="案例：密码框格式提示错误信息"></a>案例：密码框格式提示错误信息</h4><p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550737269546.png" alt="1550737269546"></p>
<p><img src="C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550737284218.png" alt="1550737284218"></p>
<h2 id="16-cssText"><a href="#16-cssText" class="headerlink" title="16 - cssText"></a>16 - cssText</h2><h4 id="16-1-cssText-本质是什么？"><a href="#16-1-cssText-本质是什么？" class="headerlink" title="16.1 cssText 本质是什么？"></a>16.1 cssText 本质是什么？</h4><p>cssText 的本质就是设置 HTML 元素的 style 属性值。</p>
<h4 id="16-2-cssText-怎么用？"><a href="#16-2-cssText-怎么用？" class="headerlink" title="16.2 cssText 怎么用？"></a>16.2 <strong>cssText 怎么用？</strong></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;d1&quot;</span>).style.cssText = <span class="hljs-string">&quot;color:red; font-size:13px;&quot;</span>;<br></code></pre></td></tr></table></figure>

<h4 id="16-3-cssText-返回值是什么？"><a href="#16-3-cssText-返回值是什么？" class="headerlink" title="16.3 cssText 返回值是什么？"></a>16.3 <strong>cssText 返回值是什么？</strong></h4><p>在某些浏览器中（比如 Chrome），你给他赋什么值，它就返回什么值。在 IE 中则比较痛苦，它会格式化输出、会把属性大写、会改变属性顺序、会去掉最后一个分号，比如：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;d1&quot;</span>).style.cssText = <span class="hljs-string">&quot;color:red; font-size:13px;&quot;</span>;<br>alert(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;d1&quot;</span>).style.cssText);<br></code></pre></td></tr></table></figure>

<p>在 IE 中值为：FONT-SIZE: 13px; COLOR: red</p>
<h4 id="16-4-cssText的使用优势"><a href="#16-4-cssText的使用优势" class="headerlink" title="16.4 cssText的使用优势"></a>16.4 <strong>cssText的使用优势</strong></h4><p>一般情况下我们用js设置元素对象的样式会使用这样的形式：</p>
<p><code>var element= document.getElementById(“id”); element.style.width=”20px”; element.style.height=”20px”; element.style.border=”solid 1px red”;</code></p>
<p>样式一多，代码就很多；而且通过JS来覆写对象的样式是比较典型的一种销毁原样式并重建的过程，这种销毁和重建，都会增加浏览器的开销。</p>
<h4 id="16-5-cssText问题"><a href="#16-5-cssText问题" class="headerlink" title="16.5 cssText问题"></a>16.5 cssText问题</h4><p>语法为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">obj.style.cssText=”样式”;<br><br>element.style.cssText=”width:<span class="hljs-number">20</span>px;height:<span class="hljs-number">20</span>px;border:solid <span class="hljs-number">1</span>px red;”;<br></code></pre></td></tr></table></figure>

<p>这样就可以尽量避免页面reflow，提高页面性能。</p>
<p>但是，这样会有一个问题，会把原有的cssText清掉，比如原来的style中有’display:none;’，那么执行完上面的JS后，display就被删掉了。</p>
<h4 id="16-6-cssText累加的方法"><a href="#16-6-cssText累加的方法" class="headerlink" title="16.6 cssText累加的方法"></a>16.6 cssText累加的方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">Element.style.cssText += ‘width:<span class="hljs-number">100</span>px;height:<span class="hljs-number">100</span>px;top:<span class="hljs-number">100</span>px;left:<span class="hljs-number">100</span>px;’<br></code></pre></td></tr></table></figure>

<h4 id="16-7-IE中解决兼容问题"><a href="#16-7-IE中解决兼容问题" class="headerlink" title="16.7 IE中解决兼容问题"></a>16.7 IE中解决兼容问题</h4><p>上面cssText累加的方法在IE中是无效的。</p>
<p>可以在前面添加一个分号来解决这个问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">Element.style.cssText += ‘;width:<span class="hljs-number">100</span>px;height:<span class="hljs-number">100</span>px;top:<span class="hljs-number">100</span>px;left:<span class="hljs-number">100</span>px;’<br></code></pre></td></tr></table></figure>

<h4 id="16-8-内嵌样式不会被覆盖掉"><a href="#16-8-内嵌样式不会被覆盖掉" class="headerlink" title="16.8 内嵌样式不会被覆盖掉"></a>16.8 内嵌样式不会被覆盖掉</h4><p>如果前面有样式表文件写着 div { text-decoration:underline; }，这个会被覆盖吗？</p>
<p>不会！因为它不是直接作用于 HTML 元素的 style 属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;style&gt;<br>#outer&#123;width:500px;margin:0 auto;padding:0;text-align:center;&#125;<br>#div1&#123;width:100px;height:100px;background:black;margin:10px auto;display:block;&#125;<br>&lt;/style&gt;<br>&lt;script&gt;<br><span class="hljs-keyword">var</span> changeStyle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, attr, value</span>)</span><br><span class="hljs-function"></span>&#123;<br>    elem.style[attr] = value<br>&#125;;<br><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">var</span> oBtn = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;input&quot;</span>);<br>    <span class="hljs-keyword">var</span> oDiv = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;div1&quot;</span>);<br>    <span class="hljs-keyword">var</span> oAtt = [<span class="hljs-string">&quot;width&quot;</span>,<span class="hljs-string">&quot;height&quot;</span>,<span class="hljs-string">&quot;background&quot;</span>,<span class="hljs-string">&quot;display&quot;</span>,<span class="hljs-string">&quot;display&quot;</span>];<br>    <span class="hljs-keyword">var</span> oVal = [<span class="hljs-string">&quot;200px&quot;</span>,<span class="hljs-string">&quot;200px&quot;</span>,<span class="hljs-string">&quot;red&quot;</span>,<span class="hljs-string">&quot;none&quot;</span>,<span class="hljs-string">&quot;block&quot;</span>];<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; oBtn.length; i++)<br>    &#123;<br>        oBtn[i].index = i;<br>        oBtn[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">this</span>.index == oBtn.length - <span class="hljs-number">1</span> &amp;&amp; (oDiv.style.cssText = <span class="hljs-string">&quot;&quot;</span>);<br>            changeStyle(oDiv, oAtt[<span class="hljs-built_in">this</span>.index], oVal[<span class="hljs-built_in">this</span>.index])<br>        &#125;  <br>    &#125;<br>&#125;;<br>&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div id=<span class="hljs-string">&quot;outer&quot;</span>&gt;<br>&lt;input type=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;变宽&quot;</span> /&gt;<br>&lt;input type=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;变高&quot;</span> /&gt;<br>&lt;input type=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;变色&quot;</span> /&gt;<br>&lt;input type=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;隐藏&quot;</span> /&gt;<br>&lt;input type=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;重置&quot;</span> /&gt;<br>&lt;div id=<span class="hljs-string">&quot;div1&quot;</span>&gt;&lt;/div&gt;<br>&lt;/div&gt;　　<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>javascript 1</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2</title>
    <url>/2020/09/18/vue/</url>
    <content><![CDATA[<h4 id="vue-介绍"><a href="#vue-介绍" class="headerlink" title="vue 介绍"></a>vue 介绍</h4><ul>
<li>渐进式javascript框架</li>
</ul>
<p>渐进式：主张最少</p>
<p>模块：数据请求：axios  UI：elementUI  路由：vue-router状态层：vuex。。</p>
<ul>
<li>优点</li>
</ul>
<p>模块化友好  易用 灵活 高效 SPA  用户体验好</p>
<p>SPA ：sing page  application 单页面应用</p>
<p>1个url ——&gt;1个html文件，多个html文件  多页面的应用：优点：利于SEO优化，缺点：白屏，用户体验不好</p>
<p>1个url ——&gt;1个html文件，多个html文件 单页面的应用：优点：用户体验好  缺点：首屏加载慢，不利于SEO的优化</p>
<p>VUE缺点：</p>
<ul>
<li>兼容性不好，首屏加载慢。不利于SEO优化</li>
</ul>
<p>4.核心</p>
<p>数据驱动  组件系统</p>
<p>js 绑定事件 样式操作  event阻止默认事件 阻止冒泡事件。。</p>
<p>jq  获取节点  取值 赋值  样式  绑定事件   event阻止默认事件  阻止冒泡事件  ajax..</p>
<p>vue  获取节点  赋值  取值  绑定事件  event 阻止默认事件  阻止冒泡事件  ajax 自己的内容。。</p>
<h5 id="节点赋值"><a href="#节点赋值" class="headerlink" title="节点赋值"></a>节点赋值</h5><ul>
<li><p>非表单元素：div  span等..  js：innerHTML     jq：html（）</p>
</li>
<li><p>表单元素： input textarea   select-option..  js:value  jq:val()</p>
</li>
<li><p>媒体元素：img  video。  js：src    jq：img.attr(src,1.jpg)</p>
</li>
</ul>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>官网：<a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></p>
<p>兼容性：vue不支持ie8及以下的版本</p>
<p>安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1.cdn<br><br>&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br><br>2.npm <br>npm install vue<br><br>3.vue脚手架 vue-cli ：工作中使用的方式  5天<br></code></pre></td></tr></table></figure>

<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 1.安装 npm i vue  --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 2.引入 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 3.控制范围 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        &#123;&#123;1+1&#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-comment">// 4.实例化vue对象</span></span><br><span class="javascript">        <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            <span class="hljs-comment">//element</span></span><br><span class="javascript">            el:<span class="hljs-string">&quot;div&quot;</span></span><br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="el挂载点"><a href="#el挂载点" class="headerlink" title="el挂载点"></a>el挂载点</h5><ol>
<li>不能挂载到body  html ，要 挂载到正常的元素上</li>
<li>一个vue实列只能挂载到一个节点上，所以一般情况使用id选择器</li>
<li>如果有多个元素都满足el的选择，vue实列挂载到满足条件的第一个节点上</li>
</ol>
<h5 id="data：先声明-后使用"><a href="#data：先声明-后使用" class="headerlink" title="data：先声明 后使用"></a>data：先声明 后使用</h5><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">new Vue(&#123;<br>	el:&quot;#app&quot;,//挂载点<br>	data:&#123;	//属性-变量<br>			x:10,<br>     arr:[]<br>	&#125;,<br>	methods:&#123;//方法-函数<br>		 fn:function()&#123;&#125;,<br>     changeArr:function()&#123;&#125;<br>	&#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="数据绑定-指令"><a href="#数据绑定-指令" class="headerlink" title="数据绑定 指令"></a>数据绑定 指令</h2><h5 id="1-非表单元素：div-span-…"><a href="#1-非表单元素：div-span-…" class="headerlink" title="1.非表单元素：div  span …"></a>1.非表单元素：div  span …</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#123;&#123;&#125;&#125; 模板语法  优点：简单 方便   缺点：不能解析标签，首屏会出现闪屏问题<br>v-html       优点：可以解析标签  缺点：不方便<br>v-text       优点：可以解决首闪屏问题  缺点：不方便，不能解析标签<br></code></pre></td></tr></table></figure>

<h5 id="2-表单元素：input-textarea"><a href="#2-表单元素：input-textarea" class="headerlink" title="2.表单元素：input  textarea"></a>2.表单元素：input  textarea</h5><p>v-model</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="3-属性绑定：媒体元素：img-video"><a href="#3-属性绑定：媒体元素：img-video" class="headerlink" title="3.属性绑定：媒体元素：img  video"></a>3.属性绑定：媒体元素：img  video</h5><p>v-bind简写  ：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;company.url&quot;</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;company.name&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;company.logo&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;company.url&quot;</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;company.name&quot;</span> <span class="hljs-attr">:a</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;company.logo&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="4-条件渲染"><a href="#4-条件渲染" class="headerlink" title="4.条件渲染"></a>4.条件渲染</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">相同点：<br>v-if 和v-show 都是true显示，false 消失<br><br><br>不同点：<br>	v-if false 不加载节点-惰性加载<br>	V-show false 加了display:none；<br>	<br>使用：<br>	频繁切换，建议使用v-show,不频繁切换，建议使用v-if.<br></code></pre></td></tr></table></figure>

<p>v-else 必须和它一对的v-if挨着</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;comment.length==0&quot;</span>&gt;</span>暂无数据<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">v-else</span>&gt;</span>有数据<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="5-列表渲染"><a href="#5-列表渲染" class="headerlink" title="5.列表渲染"></a>5.列表渲染</h5><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in arr&quot;</span>&gt;</span><br>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><br></code></pre></td></tr></table></figure>

<h4 id="1-for-key"><a href="#1-for-key" class="headerlink" title="1.for key"></a>1.for key</h4><p>vue 的for更新的时候采用的是“就地更新”的原则，如果更新的时候想要提高更新的性能，我们就需要给vue一个标识，作为对比条件，这个标识必须是唯一的。所以一般用id</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(a,b) in people&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;a.id&quot;</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;&#123;b&#125;&#125;姓名：&#123;&#123;a.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>金额：<br>                   <br>                &#123;&#123;a.money&#125;&#125; <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;add(b)&quot;</span>&gt;</span>++<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>           <br>       <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="2-样式"><a href="#2-样式" class="headerlink" title="2.样式"></a>2.样式</h5><ul>
<li><h4 id="动态行间样式"><a href="#动态行间样式" class="headerlink" title="动态行间样式"></a>动态行间样式</h4></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;json&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><h5 id="动态的类名"><a href="#动态的类名" class="headerlink" title="动态的类名"></a>动态的类名</h5></li>
</ul>
<p>1.:class=”变量”</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 1. v-bind:class=&quot;变量&quot;  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;selectName&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>2.:class=”[三元]”</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 2.v-bind:class=&quot;[三元]&quot; --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[isRed?&#x27;red&#x27;:&#x27;blue&#x27;]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>3.:class=”{class1:true,class2:false,…}</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!-- 3. :class=&quot;&#123;class1:true,class2:false,...&#125;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;&#x27;red&#x27;:true,&#x27;blue&#x27;:true,&#x27;black&#x27;:true&#125;&quot;</span>&gt;</span>商道酬信<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="4-表单"><a href="#4-表单" class="headerlink" title="4.表单"></a>4.表单</h4><ul>
<li>1  定义变量为一个json，key和后端要求的字段保持一致；</li>
<li>2   所有表单元素通过v-model绑定数据</li>
<li>3   单选框  准备value：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>性别：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;user.sex&quot;</span>&gt;</span> 男<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;user.sex&quot;</span>&gt;</span> 女<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>4  下拉菜单  option-value</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>           专业：<br>           <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;user.job&quot;</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;web&quot;</span>&gt;</span>web工程师<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;php&quot;</span>&gt;</span>php工程师<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;java&quot;</span>&gt;</span>java工程师<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>           社团：<br>           <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">multiple</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;user.org&quot;</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>篮球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>足球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>排球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br></code></pre></td></tr></table></figure>

<ul>
<li>5  多选框：对于多选框来说，如果初始值是数组，那么结果就是数组；如果初始值不是数组，那么结果就是boolean</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>爱好：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;user.hobbies&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sing&quot;</span>&gt;</span>唱歌<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;user.hobbies&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dancing&quot;</span>&gt;</span>跳舞<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;user.hobbies&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;codding&quot;</span>&gt;</span>写代码<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;user.isAgree&quot;</span>&gt;</span>我同意<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>6  表单修饰符</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- .lazy 失去光标才修改模型数据，优化 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br><br>      <span class="hljs-comment">&lt;!-- .number 将绑定的数据 的数据类型转换为number --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">v-on:blur</span>=<span class="hljs-string">&quot;blur()&quot;</span>&gt;</span><br><br>      <span class="hljs-comment">&lt;!-- .trim 去空格 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="5-事件绑定"><a href="#5-事件绑定" class="headerlink" title="5.事件绑定"></a>5.事件绑定</h4><h2 id="5-事件绑定-1"><a href="#5-事件绑定-1" class="headerlink" title="5.事件绑定"></a>5.事件绑定</h2><ul>
<li><p>1.如何绑定事件？</p>
</li>
<li><p>2.传参</p>
</li>
<li><p>3.event</p>
</li>
<li><p>4.阻止默认事件 阻止事件传播</p>
</li>
<li><p>5.本框架自带哪些事件特征</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">.prevent 阻止默认事件<br>.stop 阻止事件传播<br>.self 触发的目标元素是自身，才执行<br>.left .right .up .down .enter .13 <br>.capture  捕获<br>.native native 解决组件绑定不上事件<br></code></pre></td></tr></table></figure>

<h2 id="1-生命周期"><a href="#1-生命周期" class="headerlink" title="1.生命周期"></a>1.生命周期</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">beforeCreate  创建之前：什么都是undefined<br>created 创建完成：vue实列数据初始化完成，el还是undefined<br>&#x2F;&#x2F;如果有挂载点：了&#x2F;&#x2F;如果有挂载点：el $mount()<br>beforeMount 挂载之前 ：找到了要挂载的节点，但是&#123;&#123;&#125;&#125;、指令等等还没有被解析<br>mounted 挂载完成 *****<br>	页面初始化完成。开启计时器、轮播图、ajax、操作DOM 节点、给window | docuemnt添加事件、<br><br>beforeUpdate 页面更新之前：不是数据变化之前，而是数据已经变了，页面重新渲染之前<br>updated 页面更新完成 <br><br>&#x2F;&#x2F; vm.$dstrory()<br>beforeDestroy 销毁之前：善后工作 ***<br>	 清除计时器、轮播图、window|document置空<br>destroyed 销毁完成<br></code></pre></td></tr></table></figure>





<p>![1](D:\梁超\梁超 第四阶段\day03\老师代码\笔记/1.png)</p>
<h2 id="2-watch"><a href="#2-watch" class="headerlink" title="2.watch"></a>2.watch</h2><p>目的：监听属性的改变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;<br>	watch:&#123;<br>		kw(newV,oldV)&#123;<br>			<span class="hljs-comment">//逻辑</span><br>		&#125;，<br>        <span class="hljs-comment">//深度监听不建议使用，因为会造成页面卡顿，如果要使用的话，建议转换成简单类型使用</span><br>        json:&#123;<br>        	handler()&#123;<br>    			<span class="hljs-comment">//逻辑</span><br>			&#125;，<br>        	deep:<span class="hljs-literal">true</span><br>    	&#125;<br>	&#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h5 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h5><p>ajax  不能跨域  get   post</p>
<p>jsonp 可以跨域get</p>
<p>使用jsonp条件：1.跨域  2.有一个参数需要是回调函数，大部分情况下叫cb  |   callback</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span>创建一个script标签<br>	<span class="hljs-keyword">var</span> os=<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;script&quot;</span>)<br><span class="hljs-number">2.</span>给他src<br>	os.src=<span class="hljs-string">&quot;url&quot;</span><br><span class="hljs-number">3.</span>插入到页面<br>	<span class="hljs-built_in">document</span>.body.appendChild(os)<br><span class="hljs-number">4.</span>回调函数中处理数据<br>	<br></code></pre></td></tr></table></figure>

<h2 id="3-filter"><a href="#3-filter" class="headerlink" title="3.filter"></a>3.filter</h2><p>目的：转换数据</p>
<p>使用：|  管道符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &#123;&#123;price | filterPrice&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>定义：推荐全局定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//全局定义</span><br>Vue.filter(<span class="hljs-string">&quot;过滤器名称&quot;</span>,<span class="hljs-function">(<span class="hljs-params">过滤对象</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">//逻辑 </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你要的结果&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//局部定义</span><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    filters:&#123;<br>        <span class="hljs-comment">//全局定义</span><br>		过滤器名称(过滤对象)&#123;<br>            <span class="hljs-comment">//逻辑 </span><br>    		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你要的结果&quot;</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="4-computed计算属性"><a href="#4-computed计算属性" class="headerlink" title="4.computed计算属性"></a>4.computed计算属性</h2><p>计算属性：经过计算得到的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;<br>	computed:&#123;<span class="hljs-comment">//计算属性</span><br>        a()&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span><br>        &#125;,<br>        ava()&#123;<br>            <span class="hljs-keyword">var</span> sum=<span class="hljs-number">0</span><br>            <span class="hljs-built_in">this</span>.students.forEach(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>                sum+=item.score<br>            &#125;)<br>            <span class="hljs-keyword">return</span> (sum/<span class="hljs-built_in">this</span>.students.length).toFixed(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="5-vue常见的bug有哪些？怎么解决？"><a href="#5-vue常见的bug有哪些？怎么解决？" class="headerlink" title="5.vue常见的bug有哪些？怎么解决？"></a>5.vue常见的bug有哪些？怎么解决？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1.&#123;&#123;&#125;&#125;闪屏问题。 v-text解决<br>2.组件绑定事件绑定不上。 .native解决<br>3.watch深度监听卡顿。 换成简单类型，浅监听。<br></code></pre></td></tr></table></figure>

<h2 id="1-计算属性补充"><a href="#1-计算属性补充" class="headerlink" title="1.计算属性补充"></a>1.计算属性补充</h2><p>1.v-for和v-if同时作用在一个标签上的时候，不合法。需要所使用的的计算属性解决。</p>
<p>2.如果出现数组变了，页面不渲染问题，采用下面3种方式结解决：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.this.goods.splice(&#x27;下标&#x27;,1,&#x27;新值&#x27;)</span><br><span class="hljs-built_in">this</span>.goods.splice(index,<span class="hljs-number">1</span>,obj)<br><br><span class="hljs-comment">//2.vm.$set(数组，下标，新值)</span><br><span class="hljs-built_in">this</span>.$set(<span class="hljs-built_in">this</span>.goods,inds,obj)<br><br><span class="hljs-comment">//3.vue.set(数组，下标，新值)</span><br>vue.set(<span class="hljs-built_in">this</span>.goods,indes,obj)<br></code></pre></td></tr></table></figure>

<p>3.如果是json发生了改变，页面不渲染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vm.set(obj,key,value)</span><br><span class="hljs-built_in">this</span>.$set(<span class="hljs-built_in">this</span>.json,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-number">30</span>)<br>vue.set(<span class="hljs-built_in">this</span>.json,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-number">40</span>)<br></code></pre></td></tr></table></figure>

<h2 id="2-动画"><a href="#2-动画" class="headerlink" title="2.动画"></a>2.动画</h2><h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">v-if<br>v-show<br>动态组件<br>路由<br></code></pre></td></tr></table></figure>

<h4 id="状态："><a href="#状态：" class="headerlink" title="状态："></a>状态：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">进来之前 enter<br>进来过程 enter-active<br>进来完成 enter-to<br>离开之前 leave<br>离开过程 leave-active<br>离开完成 leave-to<br></code></pre></td></tr></table></figure>

<p>animate.css</p>
<p>1.官网：<a href="https://animate.style/">https://animate.style/</a></p>
<p>2.安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">npm i animate.css --save<br></code></pre></td></tr></table></figure>

<p>3.使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> href=<span class="hljs-string">&quot;./node_modules/animate.css/animate.css&quot;</span>&gt;<br>&lt;transition <br>            enter-active-<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;animate__animated animate__flipInX&quot;</span><br>            leave-active-<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;animate__animated animate__rotateOutDownRight&quot;</span><br>            &gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;box&quot;</span> v-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;isshow&quot;</span>&gt;&lt;/div&gt;<br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure>



<h5 id="建议："><a href="#建议：" class="headerlink" title="建议："></a>建议：</h5><p>只写进来|离开的动画，如果都写了，太花里胡哨。一般情况下写进来。</p>
<h2 id="3-组件"><a href="#3-组件" class="headerlink" title="3.组件"></a>3.组件</h2><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>可复用的vue实列</p>
<h5 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h5><p>重复调用</p>
<h5 id="注册：推荐局部"><a href="#注册：推荐局部" class="headerlink" title="注册：推荐局部"></a>注册：推荐局部</h5><p>1.全局注册：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">Vue.component（<span class="hljs-string">&#x27;组件名&#x27;</span>，&#123;<br>    <span class="hljs-comment">//配置项</span><br>&#125;）<br></code></pre></td></tr></table></figure>

<p>2.局部注册：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;<br>    components:&#123;<br>        组件名:&#123;<br>            <span class="hljs-comment">//配置项</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="组件命名"><a href="#组件命名" class="headerlink" title="组件命名"></a>组件命名</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.不要以现有的标签命名 eg：div span</span><br><span class="hljs-comment">//2.不能以现有的标签的大写命名 eg Input   Div</span><br><span class="hljs-comment">//3.如果组件名称中间包含了大写字母，调用改成  —小写  烤串写法</span><br><span class="hljs-comment">//4.建议组件取名的时候中间包含一个大写字母，方便调用</span><br></code></pre></td></tr></table></figure>

<h5 id="template"><a href="#template" class="headerlink" title="template"></a>template</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1.一个vue实列只能挂载到一个节点上，所以template只能有一个元素<br>2.借助template 标签来实现template 配置顶<br></code></pre></td></tr></table></figure>

<h5 id="data"><a href="#data" class="headerlink" title="data"></a>data</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1.data是一个返回对象的函数<br>2.组件希望模板是一样的，但是数据是隔离的。如果直接使用json，json引用类型，<br>一个变全都变<br>3.一个vue实例只能使用自己的data、methods、watch、filters、mounted、computed,components ....<br></code></pre></td></tr></table></figure>

<h2 id="4-脚手架"><a href="#4-脚手架" class="headerlink" title="4.脚手架"></a>4.脚手架</h2><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//安装webpack</span><br>npm i webpack -g<br><br><span class="hljs-comment">//安装vue的脚手架</span><br>npm i vue-cli -g<br><br><span class="hljs-comment">//创建项目</span><br>vue init webpack 项目名称<br><br><span class="hljs-comment">//进入项目</span><br>cd 创建的项目<br><br><span class="hljs-comment">//启动项目</span><br>npm run dev  <span class="hljs-comment">//http://localhost:8080</span><br></code></pre></td></tr></table></figure>

<h5 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- 项目<br>    -build webpack所有配置<br>	-config 启动配置文件<br>	-node_modules 依赖包<br>	-dist 打包生成的文件夹<br>	-static 静态资源：reset.css 图片 rem.js<br>	.babelrc ES6-》ES5<br>	-editorconfig 编辑器配置文件<br>	.gitignore 上传到github不用上传的文件<br>	.postcssrc.js 处理css<br>	 index.html 页面<br>	 package.json 记录项目命令和依赖包<br>	 README.md 项目说明<br>	<br>	 -src 你的代码<br>	main.js 入口文件<br>	App.vue 根组件<br>		<br></code></pre></td></tr></table></figure>

<h2 id="组件进阶"><a href="#组件进阶" class="headerlink" title="组件进阶"></a>组件进阶</h2><h4 id="1-组件通信"><a href="#1-组件通信" class="headerlink" title="1.组件通信"></a>1.组件通信</h4><ul>
<li><h6 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h6></li>
</ul>
<p>父传子：父组件将要传递的数据通过自定义属性传递给子组件，子组件通过props、接收</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs vue">&lt;!--父组件--&gt;<br>&lt;v-child :a&#x3D;&quot;name&quot;&gt;&lt;&#x2F;v-child&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//子组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;   <br>    props:[<span class="hljs-string">&quot;a&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>扩展：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1.在子组件js使用父组件传递过来的数据，用this.age<br>2.对于一个组件来说，模板中可以使用的变量只能是自己的props  data computed，能直接修改的只有data和computed<br>3.父组件传递过来的数据，子组间不允许修改，按标准来做，应该使用子传父，实现子组件修改父组件的数据<br>4.如果子组件直接修改父组件传递过来的值子变 父不变 还报错<br>5.父变，子变；子变，父变.可以传递json数据解决。<br></code></pre></td></tr></table></figure>

<p>props验证</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    props:&#123;<br>        <span class="hljs-comment">//约束传递过来的数据类型</span><br>        type:<span class="hljs-built_in">Number</span>,<br>        <br>        <span class="hljs-comment">//必传</span><br>        required:ture<br>    &#125;,<br>    arr:&#123;<br>        <span class="hljs-comment">//默认值</span><br>        <span class="hljs-keyword">default</span>()&#123;<br>            <span class="hljs-keyword">return</span>[<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&#x27;9&#x27;</span>]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="2-子传父"><a href="#2-子传父" class="headerlink" title="2.子传父"></a>2.子传父</h5><p>目的:</p>
<p>子组件要修改父组件的值</p>
<p>在父组件上绑定自定义事件，子组件通过$emit()触发自定义事件，携带的参数，在event上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs vue">&lt;!--父组件--&gt;<br>&lt;v-child2 @changwang&#x3D;&#39;change&#39; @change&#x3D;&#39;changename(&#39;$event&#39;)&gt;&lt;&#x2F;v-child2&gt;<br></code></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//子组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    methods:&#123;<br>        changeWang()&#123;<br>            <span class="hljs-comment">//通知父组件 修改他自己的name </span><br>            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;changewang&quot;</span>)<br>        &#125;,<br>        change(name)&#123;<br>            <span class="hljs-comment">//通知父组件，把父组件的name改成功 name</span><br>            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;change&quot;</span>,name)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="3-非父子传值"><a href="#3-非父子传值" class="headerlink" title="3.非父子传值"></a>3.非父子传值</h5><h6 id="1-单一事件管理：基本不会用到"><a href="#1-单一事件管理：基本不会用到" class="headerlink" title="1.单一事件管理：基本不会用到"></a>1.单一事件管理：基本不会用到</h6><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1. main.js</span><br>Vue.prototype.Event=<span class="hljs-keyword">new</span> Vue();<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//2.想要接受数据的组件，绑定自定义事件</span><br> mounted()&#123;<br>     <span class="hljs-built_in">this</span>.Event.$on(<span class="hljs-string">&quot;sendA&quot;</span>,<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>         <span class="hljs-built_in">console</span>.log(e);<br>         <span class="hljs-built_in">this</span>.a=e;<br>     &#125;)<br> &#125;,<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//3.触发事件</span><br><span class="hljs-built_in">this</span>.Event.$emit(<span class="hljs-string">&quot;sendA&quot;</span>,<span class="hljs-string">&quot;王昭君&quot;</span>)<br></code></pre></td></tr></table></figure>

<h4 id="3-非父子传值-1"><a href="#3-非父子传值-1" class="headerlink" title="3.非父子传值"></a>3.非父子传值</h4><h5 id="1-单一事件管理-：永远不会用到"><a href="#1-单一事件管理-：永远不会用到" class="headerlink" title="1.单一事件管理 ：永远不会用到"></a>1.单一事件管理 ：永远不会用到</h5><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1. main.js</span><br>Vue.prototype.Event=<span class="hljs-keyword">new</span> Vue();<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//2.想要接受数据的组件，绑定自定义事件</span><br> mounted()&#123;<br>     <span class="hljs-built_in">this</span>.Event.$on(<span class="hljs-string">&quot;sendA&quot;</span>,<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>         <span class="hljs-built_in">console</span>.log(e);<br>         <span class="hljs-built_in">this</span>.a=e;<br>     &#125;)<br> &#125;,<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//3.触发事件</span><br><span class="hljs-built_in">this</span>.Event.$emit(<span class="hljs-string">&quot;sendA&quot;</span>,<span class="hljs-string">&quot;王昭君&quot;</span>)<br></code></pre></td></tr></table></figure>



<h5 id="2-vuex状态层"><a href="#2-vuex状态层" class="headerlink" title="2.vuex状态层"></a>2.vuex状态层</h5><h5 id="3-本地存储-localstorage-sessionStorage"><a href="#3-本地存储-localstorage-sessionStorage" class="headerlink" title="3.本地存储 localstorage sessionStorage"></a>3.本地存储 localstorage sessionStorage</h5><h2 id="2-is"><a href="#2-is" class="headerlink" title="2.is"></a>2.is</h2><h5 id="1-is-解决标签固定搭配问题"><a href="#1-is-解决标签固定搭配问题" class="headerlink" title="1.is 解决标签固定搭配问题"></a>1.is 解决标签固定搭配问题</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs vue">&lt;ul&gt;<br>     &lt;li is&#x3D;&quot;v-one&quot;&gt;&lt;&#x2F;li&gt;<br>   &lt;&#x2F;ul&gt;<br></code></pre></td></tr></table></figure>

<h5 id="2-动态组件"><a href="#2-动态组件" class="headerlink" title="2.动态组件"></a>2.动态组件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs vue">&lt;button @click&#x3D;&quot;com&#x3D;&#39;v-one&#39;&quot;&gt;one&lt;&#x2F;button&gt;<br>&lt;button @click&#x3D;&quot;com&#x3D;&#39;v-two&#39;&quot;&gt;two&lt;&#x2F;button&gt;<br>&lt;!--2. 动态组件 --&gt;<br>&lt;div :is&#x3D;&quot;com&quot;&gt;&lt;&#x2F;div&gt;<br></code></pre></td></tr></table></figure>

<h5 id="3-动态组件使用动画"><a href="#3-动态组件使用动画" class="headerlink" title="3.动态组件使用动画"></a>3.动态组件使用动画</h5><p>1.安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cnpm i animate.css --save<br></code></pre></td></tr></table></figure>

<p>2.main.js引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入animate.css</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;animate.css&quot;</span><br></code></pre></td></tr></table></figure>

<p>3.transition 嵌套</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs vue">&lt;button @click&#x3D;&quot;obj&#x3D;&#39;v-ui&#39;&quot;&gt;ui&lt;&#x2F;button&gt;<br>   &lt;button @click&#x3D;&quot;obj&#x3D;&#39;v-java&#39;&quot;&gt;java&lt;&#x2F;button&gt;<br>   &lt;transition<br>   	enter-active-class&#x3D;&quot;animate__animated animate__rotateInDownLeft&quot;<br>   &gt;<br>     	&lt;div :is&#x3D;&quot;obj&quot;&gt;&lt;&#x2F;div&gt;<br>   &lt;&#x2F;transition&gt;<br></code></pre></td></tr></table></figure>

<h2 id="3-slot插槽"><a href="#3-slot插槽" class="headerlink" title="3.slot插槽"></a>3.slot插槽</h2><p>目的：组件嵌套内容，不希望内容消失</p>
<h6 id="1-匿名插槽"><a href="#1-匿名插槽" class="headerlink" title="1.匿名插槽"></a>1.匿名插槽</h6><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs vue">&lt;!-------组件---------&gt;	<br>&lt;div class&#x3D;&quot;right&quot;&gt;<br>    &lt;!-- 匿名插槽 --&gt;<br>  &lt;slot&gt;&lt;&#x2F;slot&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs vue"> &lt;v-one&gt;<br>     &lt;div&gt;天道酬勤&lt;&#x2F;div&gt;<br>&lt;&#x2F;v-one&gt;<br><br>&lt;v-one&gt;<br>    &lt;div&gt;人道酬善&lt;&#x2F;div&gt;<br>    &lt;div&gt;商道酬信&lt;&#x2F;div&gt;<br>&lt;&#x2F;v-one&gt;<br><br>&lt;v-one&gt;&lt;&#x2F;v-one&gt;<br></code></pre></td></tr></table></figure>

<h2 id="4-scoped"><a href="#4-scoped" class="headerlink" title="4.scoped"></a>4.scoped</h2><p>样式局部作用，都要局部作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs vue">&lt;style scoped&gt;<br>h2 &#123;<br>  color: red;<br>&#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure>

<h2 id="5-jquery"><a href="#5-jquery" class="headerlink" title="5.jquery"></a>5.jquery</h2><p>1.安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">npm i jquery --save<br></code></pre></td></tr></table></figure>

<p>2引入 挂到vue的原型链上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//main.js</span><br><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jquery&quot;</span><br>Vue.prototype.$=$<br><br></code></pre></td></tr></table></figure>

<p>3.使用 ：注意在mounted之后使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">mounted() &#123;<br>    <span class="hljs-built_in">this</span>.$(<span class="hljs-string">&quot;button&quot;</span>).eq(<span class="hljs-number">0</span>).click(<span class="hljs-function">()=&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.$(<span class="hljs-string">&quot;.red&quot;</span>).slideDown(<span class="hljs-number">400</span>);<br>      &#125;);<br>     <span class="hljs-built_in">this</span>.$(<span class="hljs-string">&quot;button&quot;</span>).eq(<span class="hljs-number">1</span>).click(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.$(<span class="hljs-string">&quot;.red&quot;</span>).slideUp(<span class="hljs-number">400</span>);<br>      &#125;);<br>  &#125;,<br></code></pre></td></tr></table></figure>

<h2 id="6-ref"><a href="#6-ref" class="headerlink" title="6.ref"></a>6.ref</h2><p>是vue安全访问DOM和子组件的句柄！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class&#x3D;&quot;box&quot;&gt;<br>    &lt;h1 ref&#x3D;&quot;h1&quot;&gt;ref&lt;&#x2F;h1&gt;<br>    &lt;button @click&#x3D;&quot;getWidth&quot;&gt;点击获取下面元素的宽度&lt;&#x2F;button&gt;<br>      <br>    &lt;!-- ref 访问了DOM --&gt;<br>    &lt;div class&#x3D;&quot;red&quot; ref&#x3D;&quot;red&quot;&gt;&lt;&#x2F;div&gt;<br><br>    &lt;button @click&#x3D;&quot;change&quot;&gt;哈哈哈&lt;&#x2F;button&gt;<br>    &lt;!-- ref 访问子组件 --&gt;<br>    &lt;v-child ref&#x3D;&quot;child&quot;&gt;&lt;&#x2F;v-child&gt;<br><br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import vChild from &quot;.&#x2F;child&quot;<br>export default &#123;<br>    components:&#123;<br>        vChild<br>    &#125;,<br>  methods: &#123;<br>    getWidth() &#123;<br>        console.log(this.$refs.red.clientWidth);<br>        var div&#x3D;this.$refs.red<br>        div.innerHTML&#x3D;&quot;哈哈哈&quot;<br>        div.style.background&#x3D;&quot;red&quot;<br>    &#125;,<br>    change()&#123;<br>        console.log(this.$refs.child);<br>        this.$refs.child.change()<br>    &#125;<br>  &#125;,<br>&#125;;<br>&lt;&#x2F;script&gt;<br><br></code></pre></td></tr></table></figure>

<h4 id="使用情景："><a href="#使用情景：" class="headerlink" title="使用情景："></a>使用情景：</h4><p>1.媒体元素</p>
<p>2.DOM属性：offsetLeft clientWidth  scrollTop 、children</p>
<p>3.父组件要调用子组件的数据和方法</p>
<p>注意：ref必须在mounted之后</p>
]]></content>
      <tags>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码理解——变化侦测篇</title>
    <url>/2021/03/18/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A31/</url>
    <content><![CDATA[<h3 id="1-变化侦测篇"><a href="#1-变化侦测篇" class="headerlink" title="1.变化侦测篇"></a>1.变化侦测篇</h3><p><code>Vue</code>中如何实现数据的响应式系统，从而达到数据驱动视图。</p>
<h5 id="变化侦测"><a href="#变化侦测" class="headerlink" title="变化侦测"></a>变化侦测</h5><p>vue最大的特点之一就是数据驱动视图</p>
<p>什么是数据驱动视图？我们可以把数据理解成状态，而视图就是用户可以直观看到的，页面不是一层不变的，它是动态变化的，它可能是用户操作引起变化，也可能因为后台数据引起变化的，不管它尤什么引起的，我们统称状态变了由前一个状态变到了后一个状态，页面也就应该随之而变化，所以我们就可以得到如下一个公式：**<em>UI = render(state)**</em></p>
<p>公式中：状态<code>state</code>是输入，页面<code>UI</code>输出，状态输入一旦变化了，页面输出也随之而变化。我们把这种特性称之为数据驱动视图。</p>
<p>OK，有了基本概念以后，我们再把上述公式拆成三部分：<code>state</code>、<code>render()</code>以及<code>UI</code>。我们知道<code>state</code>和<code>UI</code>都是用户定的，而不变的是这个<code>render()</code>。所以<code>Vue</code>就扮演了<code>render()</code>这个角色，当<code>Vue</code>发现<code>state</code>变化之后，经过一系列加工，最终将变化反应在<code>UI</code>上。</p>
<h5 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h5><h5 id="Object的变化侦测"><a href="#Object的变化侦测" class="headerlink" title="Object的变化侦测"></a>Object的变化侦测</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> car = &#123;&#125;<br>        <span class="hljs-keyword">let</span> val = <span class="hljs-number">3000</span><br>        <span class="hljs-built_in">Object</span>.defineProperty(car, <span class="hljs-string">&#x27;price&#x27;</span>, &#123;<br>            enumerable: <span class="hljs-literal">true</span>,<br>            configurable: <span class="hljs-literal">true</span>,<br>            get() &#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;price 的属性被读取了&#x27;</span>)<br>                <span class="hljs-keyword">return</span> val<br>            &#125;,<br>            set(newval) &#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;price的属性被修改了&#x27;</span>)<br>                val = newval<br>            &#125;<br>        &#125;)<br><span class="hljs-comment">//通过Object.defineProperty()方法给car定义了一个price属性，并把这个属性的读和写分别使用get()和set()进行拦截，每当该属性进行读或写操作的时候就会触发get()和set()  如下图</span><br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210421145548907.png" alt="image-20210421145548907"></p>
<p>注：enumerable控制是否可以删除</p>
<p>​         configurable控制是否可以枚举（循环遍历）</p>
<p>怎么把<code>car</code>的所有属性都变得可观测？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>            <span class="hljs-keyword">constructor</span>(value) &#123;<br>                <span class="hljs-built_in">this</span>.value = value<br><span class="hljs-comment">// 给value新增一个__ob__属性，值为该value的Observer实例</span><br><span class="hljs-comment">// 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作</span><br>                def(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>, <span class="hljs-built_in">this</span>)<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>                    <span class="hljs-comment">// 当value为数组时的逻辑</span><br>                    <span class="hljs-comment">// ...</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">this</span>.walk(value)<br>                &#125;<br>            &#125;<br><br>            walk(obj:<span class="hljs-built_in">Object</span>) &#123;<br>                <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(obj)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) &#123;<br>                    defineReactive(obj, keys[i])<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 使一个对象转化成可观测对象</span><br><span class="hljs-comment">         * @param &#123; Object &#125; obj 对象</span><br><span class="hljs-comment">         * @param &#123; String &#125; key 对象的key</span><br><span class="hljs-comment">         * @param &#123; Any &#125; val 对象的某个key的值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) </span>&#123;<br>            <span class="hljs-comment">// 如果只传了obj和key，那么val = obj[key]</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) &#123;<br>                val = obj[key]<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>                <span class="hljs-keyword">new</span> Observer(val)<br>            &#125;<br>            <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>                enumerable: <span class="hljs-literal">true</span>,<br>                configurable: <span class="hljs-literal">true</span>,<br>                get() &#123;<br>                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>属性被读取了`</span>);<br>                    <span class="hljs-keyword">return</span> val;<br>                &#125;,<br>                set(newVal) &#123;<br>                    <span class="hljs-keyword">if</span> (val === newVal) &#123;<br>                        <span class="hljs-keyword">return</span><br>                    &#125;<br>                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>属性被修改了`</span>);<br>                    val = newVal;<br>                &#125;<br>            &#125;)<br>        &#125;<br>        <span class="hljs-keyword">let</span> car = <span class="hljs-keyword">new</span> Observer(&#123;<br>            <span class="hljs-string">&#x27;brand&#x27;</span>: <span class="hljs-string">&#x27;BMW&#x27;</span>,<br>            <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">3000</span><br>        &#125;)<br></code></pre></td></tr></table></figure>

<p>​             在上面的代码中，我们定义了<code>observer</code>类，它用来将一个正常的<code>object</code>转换成可观测的<code>object</code>。</p>
<p>并且给<code>value</code>新增一个<code>__ob__</code>属性，值为该<code>value</code>的<code>Observer</code>实例。这个操作相当于为<code>value</code>打上标记，表示它已经被转化成响应式了，避免重复操作</p>
<p>然后判断数据的类型，只有<code>object</code>类型的数据才会调用<code>walk</code>将每一个属性转换成<code>getter/setter</code>的形式来侦测变化。 最后，在<code>defineReactive</code>中当传入的属性值还是一个<code>object</code>时使用<code>new observer（val）</code>来递归子属性，这样我们就可以把<code>obj</code>中的所有属性（包括子属性）都转换成<code>getter/seter</code>的形式来侦测变化。 也就是说，只要我们将一个<code>object</code>传到<code>observer</code>中，那么这个<code>object</code>就会变成可观测的、响应式的<code>object</code>。</p>
<h6 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h6><p>什么是依赖收集？</p>
<p>如上，我们可以做到数据可观测性，这样我们就可以知道什么时候发生了什么变化，当数据发生变化后，我们去通知视图去更新就好了，但是视图有好多，到底去通知谁去变化？肯定不能一个数据变了然后去刷新所有视图，所以要做到：视图里谁用到了这个数据就更新谁</p>
<p>视图里谁用到了这个数据就更新谁，换个说法就是我们把”谁用到了这个数据”称为”谁依赖了这个数据”,我们给每个数据都建一个依赖数组(因为一个数据可能被多处使用)，谁依赖了这个数据(即谁用到了这个数据)我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们：”你们依赖的数据变啦，你们该更新啦！”。这个过程就是<code>依赖收集</code></p>
<p>谁用到了这个数据，其实就是谁获取了这个数据，而可观测的数据被获取时会触发<code>getter</code>属性，那么我们就可以在<code>getter</code>中收集这个依赖。同样，当这个数据变化时会触发<code>setter</code>属性，那么我们就可以在<code>setter</code>中通知依赖更新。</p>
<p>总结一句话就是：<strong>在getter中收集依赖，在setter中通知依赖更新</strong></p>
<h6 id="把依赖收集到哪？？？"><a href="#把依赖收集到哪？？？" class="headerlink" title="把依赖收集到哪？？？"></a>把依赖收集到哪？？？</h6><p>我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中。单单用一个数组来存放依赖的话，功能好像有点欠缺并且代码过于耦合。我们应该将依赖数组的功能扩展一下，更好的做法是我们应该为每一个数据都建立一个依赖管理器，把这个数据所有的依赖都管理起来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span> () &#123;<br>    <span class="hljs-built_in">this</span>.subs = []<br>  &#125;<br><br>  addSub (sub) &#123;<br>    <span class="hljs-built_in">this</span>.subs.push(sub)<br>  &#125;<br>  <span class="hljs-comment">// 删除一个依赖</span><br>  removeSub (sub) &#123;<br>    remove(<span class="hljs-built_in">this</span>.subs, sub)<br>  &#125;<br>  <span class="hljs-comment">// 添加一个依赖</span><br>  depend () &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.target) &#123;<br>      <span class="hljs-built_in">this</span>.addSub(<span class="hljs-built_in">window</span>.target)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 通知所有依赖更新</span><br>  notify () &#123;<br>    <span class="hljs-keyword">const</span> subs = <span class="hljs-built_in">this</span>.subs.slice()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = subs.length; i &lt; l; i++) &#123;<br>      subs[i].update()<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Remove an item from an array</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span> (<span class="hljs-params">arr, item</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (arr.length) &#123;<br>    <span class="hljs-keyword">const</span> index = arr.indexOf(item)<br>    <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-keyword">return</span> arr.splice(index, <span class="hljs-number">1</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的依赖管理器<code>Dep</code>类中，我们先初始化了一个<code>subs</code>数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作</p>
<p>有了依赖管理器后，我们就可以在getter中收集依赖，在setter中通知依赖更新了，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) </span>&#123;<br>           <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) &#123;<br>               val = obj[key]<br>           &#125;<br>           <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>               <span class="hljs-keyword">new</span> Observer(val)<br>           &#125;<br>           <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep() <span class="hljs-comment">//实例化一个依赖管理器，生成一个依赖管理数组dep</span><br>           <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>               enumerable: <span class="hljs-literal">true</span>,<br>               configurable: <span class="hljs-literal">true</span>,<br>               get() &#123;<br>                   dep.depend() <span class="hljs-comment">// 在getter中收集依赖</span><br>                   <span class="hljs-keyword">return</span> val;<br>               &#125;,<br>               set(newVal) &#123;<br>                   <span class="hljs-keyword">if</span> (val === newVal) &#123;<br>                       <span class="hljs-keyword">return</span><br>                   &#125;<br>                   val = newVal;<br>                   dep.notify() <span class="hljs-comment">// 在setter中通知依赖更新</span><br>               &#125;<br>           &#125;)<br>       &#125;<br></code></pre></td></tr></table></figure>

<p>在上述代码中，我们在<code>getter</code>中调用了<code>dep.depend()</code>方法收集依赖，在<code>setter</code>中调用<code>dep.notify()</code>方法通知所有依赖更新。</p>
<h6 id="依赖是谁？？？"><a href="#依赖是谁？？？" class="headerlink" title="依赖是谁？？？"></a>依赖是谁？？？</h6><p>通过上一章节，我们明白了什么是依赖？何时收集依赖？以及收集的依赖存放到何处？那么我们收集的依赖到底是谁？</p>
<p>虽然我们一直在说”谁用到了这个数据谁就是依赖“，但是这仅仅是在口语层面上，那么反应在代码上该如何来描述这个”谁“呢？</p>
<p>其实在<code>Vue</code>中还实现了一个叫做<code>Watcher</code>的类，而<code>Watcher</code>类的实例就是我们上面所说的那个”谁”。换句话说就是：谁用到了数据，谁就是依赖，我们就为谁创建一个<code>Watcher</code>实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的<code>Watch</code>实例，由<code>Watcher</code>实例去通知真正的视图。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span> (vm,expOrFn,cb) &#123;<br>    <span class="hljs-built_in">this</span>.vm = vm;<br>    <span class="hljs-built_in">this</span>.cb = cb;<br>    <span class="hljs-built_in">this</span>.getter = parsePath(expOrFn)<br>    <span class="hljs-built_in">this</span>.value = <span class="hljs-built_in">this</span>.get()<br>  &#125;<br>  get () &#123;<br>    <span class="hljs-built_in">window</span>.target = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">this</span>.vm<br>    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.getter.call(vm, vm)<br>    <span class="hljs-built_in">window</span>.target = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-keyword">return</span> value<br>  &#125;<br>  update () &#123;<br>    <span class="hljs-keyword">const</span> oldValue = <span class="hljs-built_in">this</span>.value<br>    <span class="hljs-built_in">this</span>.value = <span class="hljs-built_in">this</span>.get()<br>    <span class="hljs-built_in">this</span>.cb.call(<span class="hljs-built_in">this</span>.vm, <span class="hljs-built_in">this</span>.value, oldValue)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Parse simple path.</span><br><span class="hljs-comment"> * 把一个形如&#x27;data.a.b.c&#x27;的字符串路径所表示的值，从真实的data对象中取出来</span><br><span class="hljs-comment"> * 例如：</span><br><span class="hljs-comment"> * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125;</span><br><span class="hljs-comment"> * parsePath(&#x27;a.b.c&#x27;)(data)  // 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> bailRE = <span class="hljs-regexp">/[^\w.$]/</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parsePath</span> (<span class="hljs-params">path</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (bailRE.test(path)) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> segments = path.split(<span class="hljs-string">&#x27;.&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; segments.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span><br>      obj = obj[segments[i]]<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>当实例化<code>Watcher</code>类时，会先执行其构造函数；</li>
<li>在构造函数中调用了<code>this.get()</code>实例方法；</li>
<li>在<code>get()</code>方法中，首先通过<code>window.target = this</code>把实例自身赋给了全局的一个唯一对象<code>window.target</code>上，然后通过<code>let value = this.getter.call(vm, vm)</code>获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的<code>getter</code>，上文我们说过，在<code>getter</code>里会调用<code>dep.depend()</code>收集依赖，而在<code>dep.depend()</code>中取到挂载<code>window.target</code>上的值并将其存入依赖数组中，在<code>get()</code>方法最后将<code>window.target</code>释放掉。</li>
<li>而当数据变化时，会触发数据的<code>setter</code>，在<code>setter</code>中调用了<code>dep.notify()</code>方法，在<code>dep.notify()</code>方法中，遍历所有依赖(即watcher实例)，执行依赖的<code>update()</code>方法，也就是<code>Watcher</code>类中的<code>update()</code>实例方法，在<code>update()</code>方法中调用数据变化的更新回调函数，从而更新视图。</li>
</ol>
<p>简单总结一下就是：<code>Watcher</code>先把自己设置到全局唯一的指定位置（<code>window.target</code>），然后读取数据。因为读取了数据，所以会触发这个数据的<code>getter</code>。接着，在<code>getter</code>中就会从全局唯一的那个位置读取当前正在读取数据的<code>Watcher</code>，并把这个<code>watcher</code>收集到<code>Dep</code>中去。收集好之后，当数据发生变化时，会向<code>Dep</code>中的每个<code>Watcher</code>发送通知。通过这样的方式，<code>Watcher</code>可以主动去订阅任意一个数据的变化。</p>
<h6 id="不足："><a href="#不足：" class="headerlink" title="不足："></a>不足：</h6><p>虽然我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，但是这个方法仅仅只能观测到<code>object</code>数据的取值及设置值，当我们向<code>object</code>数据里添加一对新的<code>key/value</code>或删除一对已有的<code>key/value</code>时，它是无法观测到的，导致当我们对<code>object</code>数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。</p>
<p>当然，<code>Vue</code>也注意到了这一点，为了解决这一问题，<code>Vue</code>增加了两个全局API:<code>Vue.set</code>和<code>Vue.delete</code>，这两个API的实现原理将会在后面学习全局API的时候说到</p>
<h6 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h6><p>首先，我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，并且封装了<code>Observer</code>类，让我们能够方便的把<code>object</code>数据中的所有属性（包括子属性）都转换成<code>getter/seter</code>的形式来侦测变化。</p>
<p>接着，我们学习了什么是依赖收集？并且知道了在<code>getter</code>中收集依赖，在<code>setter</code>中通知依赖更新，以及封装了依赖管理器<code>Dep</code>，用于存储收集到的依赖。</p>
<p>最后，我们为每一个依赖都创建了一个<code>Watcher</code>实例，当数据发生变化时，通知<code>Watcher</code>实例，由<code>Watcher</code>实例去做真实的更新操作。</p>
<p>其整个流程大致如下：</p>
<ol>
<li><code>Data</code>通过<code>observer</code>转换成了<code>getter/setter</code>的形式来追踪变化。</li>
<li>当外界通过<code>Watcher</code>读取数据时，会触发<code>getter</code>从而将<code>Watcher</code>添加到依赖中。</li>
<li>当数据发生了变化时，会触发<code>setter</code>，从而向<code>Dep</code>中的依赖（即Watcher）发送通知。</li>
<li><code>Watcher</code>接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</li>
</ol>
<h5 id="Array的变化侦测"><a href="#Array的变化侦测" class="headerlink" title="Array的变化侦测"></a>Array的变化侦测</h5><p>上一篇文章中我们介绍了<code>Object</code>数据的变化侦测方式，本篇文章我们来看一下对<code>Array</code>型数据的变化<code>Vue</code>是如何进行侦测的。</p>
<p>为什么<code>Object</code>数据和<code>Array</code>型数据会有两种不同的变化侦测方式？</p>
<p>这是因为对于<code>Object</code>数据我们使用的是<code>JS</code>提供的对象原型上的方法<code>Object.defineProperty</code>，而这个方法是对象原型上的，所以<code>Array</code>无法使用这个方法，所以我们需要对<code>Array</code>型数据设计一套另外的变化侦测机制。</p>
<p>万变不离其宗，虽然对<code>Array</code>型数据设计了新的变化侦测机制，但是其根本思路还是不变的。那就是：还是在获取数据时收集依赖，数据变化时通知依赖更新。</p>
<p>下面我们就通过源码来看看<code>Vue</code>对<code>Array</code>型数据到底是如何进行变化侦测的。</p>
<p>大同小异思路同object一样还是先把用到<code>Array</code>型数据的地方作为依赖收集起来。</p>
<p>那么如何收集呢？？？</p>
<p>其实<code>Array</code>型数据的依赖收集方式和<code>Object</code>数据的依赖收集方式相同，都是在<code>getter</code>中收集。那么问题就来了，不是说<code>Array</code>无法使用<code>Object.defineProperty</code>方法吗？无法使用怎么还在<code>getter</code>中收集依赖呢？</p>
<p>那么我们回想一下平常在开发的时候，在组件的<code>data</code>中是不是都这么写的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">data()&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    arr:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>arr</code>这个数据始终都存在于一个<code>object</code>数据对象中，而且我们也说了，谁用到了数据谁就是依赖，那么要用到<code>arr</code>这个数据，是不是得先从<code>object</code>数据对象中获取一下<code>arr</code>数据，而从<code>object</code>数据对象中获取<code>arr</code>数据自然就会触发<code>arr</code>的<code>getter</code>，所以我们就可以在<code>getter</code>中收集依赖。</p>
<p>总结一句话就是：<strong>Array型数据还是在getter中收集依赖。</strong></p>
<p>如何使Array数据成为可观测性呢？？？</p>
<p><code>Object</code>数据变化侦测的时候，我们先让<code>Object</code>数据变的可观测，即我们能够知道数据什么时候被读取了、什么时候发生变化了。同理，对于<code>Array</code>型数据我们也得让它变的可观测，目前我们已经完成了一半可观测，即我们只知道了<code>Array</code>型数据何时被读取了，而何时发生变化我们无法知道，那么接下来我们就来解决这一问题：当<code>Array</code>型数据发生变化时我们如何得知？</p>
<p>分析：</p>
<p><code>Object</code>的变化时通过<code>setter</code>来追踪的，只有某个数据发生了变化，就一定会触发这个数据上的<code>setter</code>。但是<code>Array</code>型数据没有<code>setter</code>，怎么办？</p>
<p>我们试想一下，要想让<code>Array</code>型数据发生变化，那必然是操作了<code>Array</code>，而<code>JS</code>中提供的操作数组的方法就那么几种，我们可以把这些方法都重写一遍，在不改变原有功能的前提下，我们为其新增一些其他功能，例如下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>        arr.push(<span class="hljs-number">4</span>)<br>        <span class="hljs-built_in">Array</span>.prototype.newPush=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;arr 被修改了&#x27;</span>)<br>            <span class="hljs-built_in">this</span>.push(val)<br>        &#125;<br>        arr.newPush(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210422103153864.png" alt="image-20210422103153864"></p>
<p>在上面这个例子中，我们针对数组的原生<code>push</code>方法定义个一个新的<code>newPush</code>方法，这个<code>newPush</code>方法内部调用了原生<code>push</code>方法，这样就保证了新的<code>newPush</code>方法跟原生<code>push</code>方法具有相同的功能，而且我们还可以在新的<code>newPush</code>方法内部干一些别的事情，比如通知变化。</p>
<p>是不是很巧妙？<code>Vue</code>内部就是这么干的。</p>
<p>数组方法拦截器：</p>
<p>在<code>Vue</code>中创建了一个数组方法拦截器，它拦截在数组实例与<code>Array.prototype</code>之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用<code>Array.prototype</code>上的原生方法。</p>
<p>经过整理，<code>Array</code>原型中可以改变数组自身内容的方法有7个，分别是：<code>push</code>,<code>pop</code>,<code>shift</code>,<code>unshift</code>,<code>splice</code>,<code>sort</code>,<code>reverse</code>。那么源码中的拦截器代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arrayProto = <span class="hljs-built_in">Array</span>.prototype<br><span class="hljs-comment">// 创建一个对象作为拦截器</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arrayMethods = <span class="hljs-built_in">Object</span>.create(arrayProto)<br><br><span class="hljs-comment">// 改变数组自身内容的7个方法</span><br><span class="hljs-keyword">const</span> methodsToPatch = [<br>  <span class="hljs-string">&#x27;push&#x27;</span>,<br>  <span class="hljs-string">&#x27;pop&#x27;</span>,<br>  <span class="hljs-string">&#x27;shift&#x27;</span>,<br>  <span class="hljs-string">&#x27;unshift&#x27;</span>,<br>  <span class="hljs-string">&#x27;splice&#x27;</span>,<br>  <span class="hljs-string">&#x27;sort&#x27;</span>,<br>  <span class="hljs-string">&#x27;reverse&#x27;</span><br>]<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Intercept mutating methods and emit events</span><br><span class="hljs-comment"> */</span><br>methodsToPatch.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> original = arrayProto[method]      <span class="hljs-comment">// 缓存原生方法</span><br>  <span class="hljs-built_in">Object</span>.defineProperty(arrayMethods, method, &#123;<br>    enumerable: <span class="hljs-literal">false</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    writable: <span class="hljs-literal">true</span>,<br>    value:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutator</span>(<span class="hljs-params">...args</span>)</span>&#123;<br>      <span class="hljs-keyword">const</span> result = original.apply(<span class="hljs-built_in">this</span>, args)<br>      <span class="hljs-keyword">return</span> result<br>    &#125;<br>  &#125;)<br>&#125;)<br><br></code></pre></td></tr></table></figure>

<p>在上面的代码中，首先创建了继承自<code>Array</code>原型的空对象<code>arrayMethods</code>，接着在<code>arrayMethods</code>上使用<code>object.defineProperty</code>方法将那些可以改变数组自身的7个方法遍历逐个进行封装。最后，当我们使用<code>push</code>方法的时候，其实用的是<code>arrayMethods.push</code>，而<code>arrayMethods.push</code>就是封装的新函数<code>mutator</code>，也就后说，实标上执行的是函数<code>mutator</code>，而<code>mutator</code>函数内部执行了<code>original</code>函数，这个<code>original</code>函数就是<code>Array.prototype</code>上对应的原生方法。 那么，接下来我们就可以在<code>mutato</code>r函数中做一些其他的事，比如说发送变化通知。</p>
<p>使用拦截器：</p>
<p>上一小节的图中，我们把拦截器做好还不够，还要把它挂载到数组实例与<code>Array.prototype</code>之间，这样拦截器才能够生效。</p>
<p>其实挂载不难，我们只需把数据的<code>__proto__</code>属性设置为拦截器<code>arrayMethods</code>即可，源码实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span> (value) &#123;<br>    <span class="hljs-built_in">this</span>.value = value<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>      <span class="hljs-keyword">const</span> augment = hasProto<br>        ? protoAugment<br>        : copyAugment<br>      augment(value, arrayMethods, arrayKeys)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">this</span>.walk(value)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> hasProto = <span class="hljs-string">&#x27;__proto__&#x27;</span> <span class="hljs-keyword">in</span> &#123;&#125;<br><br><span class="hljs-keyword">const</span> arrayKeys = <span class="hljs-built_in">Object</span>.getOwnPropertyNames(arrayMethods)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Augment an target Object or Array by intercepting</span><br><span class="hljs-comment"> * the prototype chain using __proto__</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">protoAugment</span> (<span class="hljs-params">target, src: Object, keys: any</span>) </span>&#123;<br>  target.__proto__ = src<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Augment an target Object or Array by defining</span><br><span class="hljs-comment"> * hidden properties.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* istanbul ignore next */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyAugment</span> (<span class="hljs-params">target: Object, src: Object, keys: Array&lt;string&gt;</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = keys.length; i &lt; l; i++) &#123;<br>    <span class="hljs-keyword">const</span> key = keys[i]<br>    def(target, key, src[key])<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上面代码中首先判断了浏览器是否支持<code>__proto__</code>，如果支持，则调用<code>protoAugment</code>函数把<code>value.__proto__ = arrayMethods</code>；如果不支持，则调用<code>copyAugment</code>函数把拦截器中重写的7个方法循环加入到<code>value</code>上。</p>
<p>拦截器生效以后，当数组数据再发生变化时，我们就可以在拦截器中通知变化了，也就是说现在我们就可以知道数组数据何时发生变化了，OK，以上我们就完成了对<code>Array</code>型数据的可观测。</p>
<p>收集依赖：</p>
<p>把依赖收集到哪里？？？</p>
<p>我们说了，数组数据的依赖也在<code>getter</code>中收集，而给数组数据添加<code>getter/setter</code>都是在<code>Observer</code>类中完成的，所以我们也应该在<code>Observer</code>类中收集依赖，源码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span> (value) &#123;<br>    <span class="hljs-built_in">this</span>.value = value<br>    <span class="hljs-built_in">this</span>.dep = <span class="hljs-keyword">new</span> Dep()    <span class="hljs-comment">// 实例化一个依赖管理器，用来收集数组依赖</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>      <span class="hljs-keyword">const</span> augment = hasProto<br>        ? protoAugment<br>        : copyAugment<br>      augment(value, arrayMethods, arrayKeys)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">this</span>.walk(value)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码中，在<code>Observer</code>类中实例化了一个依赖管理器，用来收集数组依赖</p>
<p>如何收集依赖？？？</p>
<p>，数组的依赖也在<code>getter</code>中收集，那么在<code>getter</code>中到底该如何收集呢？这里有一个需要注意的点，那就是依赖管理器定义在<code>Observer</code>类中，而我们需要在<code>getter</code>中收集依赖，也就是说我们必须在<code>getter</code>中能够访问到<code>Observer</code>类中的依赖管理器，才能把依赖存进去。源码是这么做的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span> (<span class="hljs-params">obj,key,val</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> childOb = observe(val)<br>  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    get()&#123;<br>      <span class="hljs-keyword">if</span> (childOb) &#123;<br>        childOb.dep.depend()<br>      &#125;<br>      <span class="hljs-keyword">return</span> val;<br>    &#125;,<br>    set(newVal)&#123;<br>      <span class="hljs-keyword">if</span>(val === newVal)&#123;<br>        <span class="hljs-keyword">return</span><br>      &#125;<br>      val = newVal;<br>      dep.notify()   <span class="hljs-comment">// 在setter中通知依赖更新</span><br>    &#125;<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Attempt to create an observer instance for a value,</span><br><span class="hljs-comment"> * returns the new observer if successfully observed,</span><br><span class="hljs-comment"> * or the existing observer if the value already has one.</span><br><span class="hljs-comment"> * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。</span><br><span class="hljs-comment"> * 如果 Value 已经存在一个Observer实例，则直接返回它</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span> (<span class="hljs-params">value, asRootData</span>)</span>&#123;<br>  <span class="hljs-keyword">if</span> (!isObject(value) || value <span class="hljs-keyword">instanceof</span> VNode) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> ob<br>  <span class="hljs-keyword">if</span> (hasOwn(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="hljs-keyword">instanceof</span> Observer) &#123;<br>    ob = value.__ob__<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    ob = <span class="hljs-keyword">new</span> Observer(value)<br>  &#125;<br>  <span class="hljs-keyword">return</span> ob<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面代码中，我们首先通过<code>observe</code>函数为被获取的数据<code>arr</code>尝试创建一个<code>Observer</code>实例，在<code>observe</code>函数内部，先判断当前传入的数据上是否有<code>__ob__</code>属性，因为在上篇文章中说了，如果数据有<code>__ob__</code>属性，表示它已经被转化成响应式的了，如果没有则表示该数据还不是响应式的，那么就调用<code>new Observer(value)</code>将其转化成响应式的，并把数据对应的<code>Observer</code>实例返回。</p>
<p>而在<code>defineReactive</code>函数中，首先获取数据对应的<code>Observer</code>实例<code>childOb</code>，然后在<code>getter</code>中调用<code>Observer</code>实例上依赖管理器，从而将依赖收集起来。</p>
<p>到现在为止，依赖已经收集好了，并且也已经存放好了，那么我们该如何通知依赖呢？</p>
<p>其实不难，在前文说过，我们应该在拦截器里通知依赖，要想通知依赖，首先要能访问到依赖。要访问到依赖也不难，因为我们只要能访问到被转化成响应式的数据<code>value</code>即可，因为<code>vaule</code>上的<code>__ob__</code>就是其对应的<code>Observer</code>类实例，有了<code>Observer</code>类实例我们就能访问到它上面的依赖管理器，然后只需调用依赖管理器的<code>dep.notify()</code>方法，让它去通知依赖更新即可。源码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Intercept mutating methods and emit events</span><br><span class="hljs-comment"> */</span><br>methodsToPatch.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> original = arrayProto[method]<br>  def(arrayMethods, method, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutator</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> result = original.apply(<span class="hljs-built_in">this</span>, args)<br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-built_in">this</span>.__ob__<br>    <span class="hljs-comment">// notify change</span><br>    ob.dep.notify()<br>    <span class="hljs-keyword">return</span> result<br>  &#125;)<br>&#125;)<br><br></code></pre></td></tr></table></figure>

<p>上面代码中，由于我们的拦截器是挂载到数组数据的原型上的，所以拦截器中的<code>this</code>就是数据<code>value</code>，拿到<code>value</code>上的<code>Observer</code>类实例，从而你就可以调用<code>Observer</code>类实例上面依赖管理器的<code>dep.notify()</code>方法，以达到通知依赖的目的。</p>
<p>OK，以上就基本完成了<code>Array</code>数据的变化侦测。</p>
<h5 id="深度侦测："><a href="#深度侦测：" class="headerlink" title="深度侦测："></a>深度侦测：</h5><p>在前文所有讲的<code>Array</code>型数据的变化侦测都仅仅说的是数组自身变化的侦测，比如给数组新增一个元素或删除数组中一个元素，而在<code>Vue</code>中，不论是<code>Object</code>型数据还是<code>Array</code>型数据所实现的数据变化侦测都是深度侦测，所谓深度侦测就是不但要侦测数据自身的变化，还要侦测数据中所有子数据的变化。举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<br>  &#123;<br>    name:<span class="hljs-string">&#x27;NLRX&#x27;</span>，<br>    age:<span class="hljs-string">&#x27;18&#x27;</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure>

<p>数组中包含了一个对象，如果该对象的某个属性发生了变化也应该被侦测到，这就是深度侦测。</p>
<p>这个实现起来比较简单，源码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>  value: any;<br>  dep: Dep;<br><br>  <span class="hljs-keyword">constructor</span> (value: any) &#123;<br>    <span class="hljs-built_in">this</span>.value = value<br>    <span class="hljs-built_in">this</span>.dep = <span class="hljs-keyword">new</span> Dep()<br>    def(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>, <span class="hljs-built_in">this</span>)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>      <span class="hljs-keyword">const</span> augment = hasProto<br>        ? protoAugment<br>        : copyAugment<br>      augment(value, arrayMethods, arrayKeys)<br>      <span class="hljs-built_in">this</span>.observeArray(value)   <span class="hljs-comment">// 将数组中的所有元素都转化为可被侦测的响应式</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">this</span>.walk(value)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Observe a list of Array items.</span><br><span class="hljs-comment">   */</span><br>  observeArray (items: <span class="hljs-built_in">Array</span>&lt;any&gt;) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = items.length; i &lt; l; i++) &#123;<br>      observe(items[i])<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span> (<span class="hljs-params">value, asRootData</span>)</span>&#123;<br>  <span class="hljs-keyword">if</span> (!isObject(value) || value <span class="hljs-keyword">instanceof</span> VNode) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> ob<br>  <span class="hljs-keyword">if</span> (hasOwn(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="hljs-keyword">instanceof</span> Observer) &#123;<br>    ob = value.__ob__<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    ob = <span class="hljs-keyword">new</span> Observer(value)<br>  &#125;<br>  <span class="hljs-keyword">return</span> ob<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面代码中，对于<code>Array</code>型数据，调用了<code>observeArray()</code>方法，该方法内部会遍历数组中的每一个元素，然后通过调用<code>observe</code>函数将每一个元素都转化成可侦测的响应式数据。</p>
<p>而对应<code>object</code>数据，在上一篇文章中我们已经在<code>defineReactive</code>函数中进行了递归操作。</p>
<h5 id="数组新增元素的侦测"><a href="#数组新增元素的侦测" class="headerlink" title="数组新增元素的侦测"></a>数组新增元素的侦测</h5><p>对于数组中已有的元素我们已经可以将其全部转化成可侦测的响应式数据了，但是如果向数组里新增一个元素的话，我们也需要将新增的这个元素转化成可侦测的响应式数据。</p>
<p>这个实现起来也很容易，我们只需拿到新增的这个元素，然后调用<code>observe</code>函数将其转化即可。我们知道，可以向数组内新增元素的方法有3个，分别是：<code>push</code>、<code>unshift</code>、<code>splice</code>。我们只需对这3中方法分别处理，拿到新增的元素，再将其转化即可。源码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">methodsToPatch.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>&#123;<br>  <span class="hljs-comment">// cache original method</span><br>  <span class="hljs-keyword">const</span> original = arrayProto[method]<br>  def(arrayMethods, method, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutator</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> result = original.apply(<span class="hljs-built_in">this</span>, args)<br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-built_in">this</span>.__ob__<br>    <span class="hljs-keyword">let</span> inserted<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;push&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;unshift&#x27;</span>:<br>        inserted = args   <span class="hljs-comment">// 如果是push或unshift方法，那么传入参数就是新增的元素</span><br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;splice&#x27;</span>:<br>        inserted = args.slice(<span class="hljs-number">2</span>) <span class="hljs-comment">// 如果是splice方法，那么传入参数列表中下标为2的就是新增的元素</span><br>        <span class="hljs-keyword">break</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (inserted) ob.observeArray(inserted) <span class="hljs-comment">// 调用observe函数将新增的元素转化成响应式</span><br>    <span class="hljs-comment">// notify change</span><br>    ob.dep.notify()<br>    <span class="hljs-keyword">return</span> result<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>不足：</p>
<p>前文中我们说过，对于数组变化侦测是通过拦截器实现的，也就是说只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是别忘了，我们在日常开发中，还可以通过数组的下标来操作数据，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;       <span class="hljs-comment">// 通过数组下标修改数组中的数据</span><br>arr.length = <span class="hljs-number">0</span>    <span class="hljs-comment">// 通过修改数组长度清空数组</span><br></code></pre></td></tr></table></figure>

<p>而使用上述例子中的操作方式来修改数组是无法侦测到的。 同样，<code>Vue</code>也注意到了这个问题， 为了解决这一问题，<code>Vue</code>增加了两个全局API:<code>Vue.set</code>和<code>Vue.delete</code>，这两个API的实现原理将会在后面学习全局API的时候说到</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>在本篇文章中，首先我们分析了对于<code>Array</code>型数据也在<code>getter</code>中进行依赖收集；其次我们发现，当数组数据被访问时我们轻而易举可以知道，但是被修改时我们却很难知道，为了解决这一问题，我们创建了数组方法拦截器，从而成功的将数组数据变的可观测。接着我们对数组的依赖收集及数据变化如何通知依赖进行了深入分析；最后我们发现<code>Vue</code>不但对数组自身进行了变化侦测，还对数组中的每一个元素以及新增的元素都进行了变化侦测，我们也分析了其实现原理。</p>
<p>以上就是对<code>Array</code>型数据的变化侦测分析。</p>
<p>撸码一时爽，一直撸码一直爽！！！</p>
]]></content>
      <tags>
        <tag>vue源码理解——变化侦测篇</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析webpack原理</title>
    <url>/2021/03/18/%E6%B5%85%E6%9E%90webpack%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><img src="https://images.weserv.nl/?url=https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1624457798984-be18a7212fad.jpg" alt="img"></p>
<p>现在随着前端开发的复杂度和规模越来越大，鹰不能抛开工程化来独立开发，比如：react的jsx代码必须编译后才能在浏览器中使用，比如sass和less代码浏览器是不支持的。如果摒弃这些开发框架，开发效率会大幅下降。</p>
<p>在众多前端工程化工具中，webpack脱颖而出成为了当今最流行的前端构建工具。</p>
<h4 id="webpack的原理"><a href="#webpack的原理" class="headerlink" title="webpack的原理"></a>webpack的原理</h4><h5 id="1、核心概念"><a href="#1、核心概念" class="headerlink" title="1、核心概念"></a>1、核心概念</h5><p>（1）entry：一个可执行模块或者库的入口</p>
<p>（2）chunk：多个文件组成一个代码块，可以将可执行的模块和他所依赖的模块组成一个chunk，这是打包</p>
<p>（3）loader：文件转换器。比如：sass转成css</p>
<p>（4）plugin：扩展webpack功能的插件。在webpack构建的生命周期节点上加入扩展hook，添加功能。</p>
<h4 id="2、webpack构建流程（原理）"><a href="#2、webpack构建流程（原理）" class="headerlink" title="2、webpack构建流程（原理）"></a>2、webpack构建流程（原理）</h4><p>从启动构建到输出结果一系列过程：</p>
<p>（1）初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。</p>
<p>（2）开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。</p>
<p>（3）确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。</p>
<p>（4）编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</p>
<p>（5）完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry配置生成代码块chunk。</p>
<p>（6）输出完成：输出所有的chunk到文件系统。</p>
<p>注意：在构建生命周期中有一系列插件在做合适的时机做合适事情，比如UglifyPlugin会在loader转换递归完对结果使用UglifyJs压缩覆盖之前的结果。</p>
<p><strong>三、业务场景和对应解决方案</strong></p>
<p><strong>1、单页应用</strong></p>
<p>一个单页应用需要配置一个entry指明执行入口，<a href="https://github.com/gwuhaolin/web-webpack-plugin">web-webpack-plugin</a>里的<code>WebPlugin</code>可以自动的完成这些工作：webpack会为entry生成一个包含这个入口的所有依赖文件的chunk，但是还需要一个html来加载chunk生成的js，如果还提取出css需要HTML文件中引入提取的css。</p>
<p>一个简单的webpack配置文件栗子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; WebPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;web-webpack-plugin&#x27;</span>);<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: &#123;<br>    app: <span class="hljs-string">&#x27;./src/doc/index.js&#x27;</span>,<br>    home: <span class="hljs-string">&#x27;./src/doc/home.js&#x27;</span><br>  &#125;,<br>  plugins: [<br>    <span class="hljs-comment">// 一个WebPlugin对应生成一个html文件</span><br>    <span class="hljs-keyword">new</span> WebPlugin(&#123;<br>      <span class="hljs-comment">//输出的html文件名称</span><br>      filename: <span class="hljs-string">&#x27;index.html&#x27;</span>,<br>      <span class="hljs-comment">//这个html依赖的`entry`</span><br>      requires: [<span class="hljs-string">&#x27;app&#x27;</span>,<span class="hljs-string">&#x27;home&#x27;</span>],<br>    &#125;),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>说明：require: [‘app’, ‘home’]指明这个html依赖哪些entry，entry生成的js和css会自动注入到html中。</p>
<p>还支持配置这些资源注入方式，支持如下属性：</p>
<p>（1）_dist只有在生产环境中才引入的资源；</p>
<p>（2）_dev只有在开发环境中才引入的资源；</p>
<p>（3）_inline把资源的内容潜入到html中；</p>
<p>（4）_ie只有IE浏览器才需要引入的资源。</p>
<p>这些属性可以通过在js里配置，看个简单例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> WebPlugin(&#123;<br>    filename: <span class="hljs-string">&#x27;index.html&#x27;</span>,<br>    requires: &#123;<br>         app:&#123;<br>              _dist:<span class="hljs-literal">true</span>,<br>              _inline:<span class="hljs-literal">false</span>,<br>         &#125;<br>    &#125;,<br>&#125;),<br></code></pre></td></tr></table></figure>

<p>这些属性还可以在模板中设置，使用模板好处就是可以灵活的控制资源的注入点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">new WebPlugin(&#123;<br>      filename: &#x27;index.html&#x27;,<br>      template: &#x27;./template.html&#x27;,<br>&#125;),<br><br>//template模板<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-cn&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;app?_inline&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;ie-polyfill?_ie&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;react-body&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><code>WebPlugin</code>插件借鉴了<code>fis3</code>的思想，<strong>补足了webpack缺失的以HTML为入口的功能</strong>。想了解<code>WebPlugin</code>的更多功能，见<a href="https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md#%E8%BE%93%E5%87%BAhtml%E6%96%87%E4%BB%B6-demo">文档</a>。</p>
<p><strong>2、一个项目管理多个单页面</strong></p>
<p>一个项目中会包含多个单页应用，虽然多个单页面应用可以合成一个，但是这样做会导致用户没有访问的部分也加载了，如果项目中有很多的单页应用。为每一个单页应用配置一个entry和WebPlugin？如果又新增，又要新增webpack配置，这样做麻烦，这时候有一个插件web-webpack-plugin里的AutoWebPlugin方法可以解决这些问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    plugins: [<br>        <span class="hljs-comment">// 所有页面的入口目录</span><br>        <span class="hljs-keyword">new</span> AutoWebPlugin(<span class="hljs-string">&#x27;./src/&#x27;</span>),<br>    ]<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>分析：1、<code>AutoWebPlugin</code>会把<code>./src/</code>目录下所有每个文件夹作为一个单页页面的入口，自动为所有的页面入口配置一个WebPlugin输出对应的html。</p>
<p>2、要新增一个页面就在<code>./src/</code>下新建一个文件夹包含这个单页应用所依赖的代码，<code>AutoWebPlugin</code>自动生成一个名叫文件夹名称的html文件。</p>
<p><strong>3、代码分隔优化</strong></p>
<p>一个好的代码分割对浏览器首屏效果提升很大。</p>
<p>最常见的react体系：</p>
<p><strong>（1）先抽出基础库</strong><code>react</code> <code>react-dom</code> <code>redux</code> <code>react-redux</code>到一个单独的文件而不是和其它文件放在一起打包为一个文件，这样做的好处是只要你不升级他们的版本这个文件永远不会被刷新。如果你把这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致文件hash值变化从而导致缓存失效浏览器重复下载这些包含基础库的代码。所以把<strong>基础库打包成一个文件</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// vender.js 文件抽离基础库到单独的一个文件里防止跟随业务代码被刷新</span><br><span class="hljs-comment">// 所有页面都依赖的第三方库</span><br><span class="hljs-comment">// react基础</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><span class="hljs-comment">// redux基础</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;<br><span class="hljs-comment">// webpack配置</span><br>&#123;<br>  entry: &#123;<br>    vendor: <span class="hljs-string">&#x27;./path/to/vendor.js&#x27;</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>（2）通过<a href="https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin">CommonsChunkPlugin</a>可以提取出多个代码块都依赖的代码形成一个单独的<code>chunk</code>。在应用有多个页面的场景下提取出所有页面公共的代码减少单个页面的代码，在不同页面之间切换时所有页面公共的代码之前被加载过而不必重新加载。所以<strong>通过<a href="https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin">CommonsChunkPlugin</a>可以提取出多个代码块都依赖的代码形成一个单独的<code>chunk。</code></strong></p>
<p><strong>4、构建服务端渲染</strong></p>
<p>服务端渲染的代码要运行在nodejs环境，和浏览器不同的是，服务端渲染代码需要采用commonjs规范同时不应该包含除js之外的文件比如css。</p>
<p>webpack配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  target: <span class="hljs-string">&#x27;node&#x27;</span>,<br>  entry: &#123;<br>    <span class="hljs-string">&#x27;server_render&#x27;</span>: <span class="hljs-string">&#x27;./src/server_render&#x27;</span>,<br>  &#125;,<br>  output: &#123;<br>    filename: <span class="hljs-string">&#x27;./dist/server/[name].js&#x27;</span>,<br>    libraryTarget: <span class="hljs-string">&#x27;commonjs2&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>      &#125;,<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(scss|css|pdf)$/</span>,<br>        loader: <span class="hljs-string">&#x27;ignore-loader&#x27;</span>,<br>      &#125;,<br>    ]<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>分析一下：</p>
<p>（1）target: ‘node’指明构建出代码要运行在node环境中。</p>
<p>（2）libraryTarget: ‘commonjs2’ 指明输出的代码要是commonjs规范。</p>
<p>（3）{test: /.(scss|css|pdf)$/,loader: ‘ignore-loader’} 是为了防止不能在node里执行服务端渲染也用不上的文件被打包进去。</p>
<p><strong>5、fis3迁移到webpack</strong></p>
<p>fis3和webpack有很多相似地方也有不同的地方，相似地方：都采用commonjs规范，不同地方：导入css这些非js资源的方式。</p>
<p>fis3通过@require ‘./index.scss’，而webpack是通过require(‘./index.scss’)。</p>
<p>如果想把fis3平滑迁移到webpack，可以使用comment-require-loader。</p>
<p>比如：你想在webpack构建是使用采用了fis3方式的<code>imui</code>模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">loaders:[&#123;<br>     test: <span class="hljs-regexp">/\.js$/</span>,<br>     loaders: [<span class="hljs-string">&#x27;comment-require-loader&#x27;</span>],<br>     include: [path.resolve(__dirname, <span class="hljs-string">&#x27;node_modules/imui&#x27;</span>),]<br>&#125;]<br></code></pre></td></tr></table></figure>



<p><strong>四、自定义webpack扩展</strong></p>
<p>如果你在社区找不到你的应用场景的解决方案，那就需要自己动手了写loader或者plugin了。<br>在你编写自定义webpack扩展前你需要想明白到底是要做一个<code>loader</code>还是<code>plugin</code>呢？可以这样判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">如果你的扩展是想对一个个单独的文件进行转换那么就编写loader剩下的都是plugin。<br></code></pre></td></tr></table></figure>

<p>其中对文件进行转换可以是像：</p>
<p>1、babel-loader把es6转为es5；</p>
<p>2、file-loader把文件替换成对应的url；</p>
<p>3、raw-loader注入文本文件内容到代码中。</p>
<p><strong>1、编写webpack loader</strong></p>
<p>编写<code>loader</code>非常简单，以comment-require-loader为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">content</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> replace(content);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><code>loader</code>的入口需要导出一个函数，这个函数要干的事情就是转换一个文件的内容。<br>函数接收的参数<code>content</code>是一个文件在转换前的字符串形式内容，需要返回一个新的字符串形式内容作为转换后的结果，所有通过模块化倒入的文件都会经过<code>loader</code>。从这里可以看出<code>loader</code>只能处理一个个单独的文件而不能处理代码块。可以参考<a href="https://webpack.js.org/concepts/loaders">官方文档</a></p>
<p><strong>2、编写webpack plugin</strong></p>
<p><code>plugin</code>应用场景广泛，所以稍微复杂点。以end-webpack-plugin为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EndWebpackPlugin</span> </span>&#123;<br><br>    <span class="hljs-keyword">constructor</span>(doneCallback, failCallback) &#123;<br>        <span class="hljs-built_in">this</span>.doneCallback = doneCallback;<br>        <span class="hljs-built_in">this</span>.failCallback = failCallback;<br>    &#125;<br><br>    apply(compiler) &#123;<br>        <span class="hljs-comment">// 监听webpack生命周期里的事件，做相应的处理</span><br>        compiler.plugin(<span class="hljs-string">&#x27;done&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stats</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">this</span>.doneCallback(stats);<br>        &#125;);<br>        compiler.plugin(<span class="hljs-string">&#x27;failed&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">this</span>.failCallback(err);<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = EndWebpackPlugin;<br></code></pre></td></tr></table></figure>

<p>loader的入口需要导出一个class，在new EndWebpackPlugin()的时候通过构造函数传入这个插件需要的参数，在webpack启动的时候会先实例化plugin，再调用plugin的apply方法，插件在apply函数里监听webpack生命周期里的事件，做相应的处理。</p>
<p>webpack plugin的两个核心概念：</p>
<p>（1）compiler：从webpack启动到退出只存在一个Compiler，compiler存放着webpack的配置。</p>
<p>（2）compilation：由于webpack的监听文件变化自动编译机制，compilation代表一次编译。</p>
<p><code>Compiler</code> 和 <code>Compilation</code> 都会广播一系列事件。webpack生命周期里有非常多的事件</p>
<p>以上只是一个最简单的demo，更复杂的可以查看 <a href="https://github.com/webpack/docs/wiki/how-to-write-a-plugin">how to write a plugin</a>或参考<a href="https://github.com/gwuhaolin/web-webpack-plugin">web-webpack-plugin</a>。</p>
<p><strong>五、总结</strong></p>
<p>webpack其实比较简单，用一句话概括本质：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">webpack是一个打包模块化js的工具，可以通过loader转换文件，通过plugin扩展功能。<br></code></pre></td></tr></table></figure>

<p>如果webpack让你感到复杂，一定是各种loader和plugin的原因。</p>
<p><strong>六、一些问题</strong></p>
<p><strong>1、webpack与grunt、gulp的不同？</strong></p>
<p>三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。</p>
<p>grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。</p>
<p>webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。</p>
<p>总结：（1）从构建思路来说：gulp和grunt需要开发者将整个前端构建过程拆分成多个<code>Task</code>，并合理控制所有<code>Task</code>的调用关系 webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工；</p>
<p>（2）对于知识背景：gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路。</p>
<p><strong>2、 与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？</strong></p>
<p>同样是基于入口的打包工具还有以下几个主流的：webpack，rollup，parcel。</p>
<p>从应用场景上来看：（1）webpack适合大型复杂的前端站点构建；（2）rollup适合基础库的打包，比如vue，react；（3）parcel适用于简单的实验室项目，但是打包出错很难调试。</p>
<p><strong>3、有哪些常见的Loader？他们是解决什么问题的？</strong></p>
<p>（1）babel-loader：把es6转成es5；</p>
<p>（2）css-loader：加载css，支持模块化，压缩，文件导入等特性；</p>
<p>（3）style-loader：把css代码注入到js中，通过dom操作去加载css；</p>
<p>（4）eslint-loader：通过Eslint检查js代码；</p>
<p>（5）image-loader：加载并且压缩图片晚间；</p>
<p>（6）file-loader：文件输出到一个文件夹中，在代码中通过相对url去引用输出的文件；</p>
<p>（7）url-loader：和file-loader类似，文件很小的时候可以base64方式吧文件内容注入到代码中。</p>
<p>（8）source-map-loader：加载额外的source map文件，方便调试。</p>
<p><strong>4、有哪些常见的Plugin？他们是解决什么问题的？</strong></p>
<p>（1）uglifyjs-webpack-plugin：通过UglifyJS去压缩js代码；</p>
<p>（2）commons-chunk-plugin：提取公共代码；</p>
<p>（3）define-plugin：定义环境变量。</p>
<p><strong>5、loader和plugin的不同</strong></p>
<p>作用不同：（1）loader让webpack有加载和解析非js的能力；（2）plugin可以扩展webpack功能，在webpack运行周期中会广播很多事件，Plugin可以监听一些事件，通过webpack的api改变结果。</p>
<p>用法不同：（1）loader在module.rule中配置。类型为数组，每一项都是Object；（2）plugin是单独配置的，类型为数组，每一项都是plugin实例，参数通过构造函数传入。</p>
<p><strong>6、webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全</strong></p>
<p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
<p>（1）初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</p>
<p>（2）开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</p>
<p>（3）确定入口：根据配置中的 entry 找出所有的入口文件；</p>
<p>（4）编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</p>
<p>（5）完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</p>
<p>（6）输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</p>
<p>（7）输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p>
<p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p>
<p><strong>7、是否写过Loader和Plugin？描述一下编写loader或plugin的思路？</strong></p>
<p>编写Loader时要遵循单一原则，每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。</p>
<p>Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>
<p><strong>8、webpack的热更新是如何做到的？说明其原理？</strong></p>
<p>webpack的热更新又称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到<strong>不用刷新浏览器而将新变更的模块替换掉旧的模块</strong>。</p>
<p>原理：</p>
<p><img src="https://www.mwcxs.top/static/upload/pics/2019/2/28FRQimjwzfPAJnjuwHaXYHTyO.png" alt="img"></p>
<p>分析：</p>
<p>（1）第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</p>
<p>（2）第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。</p>
<p>（3）第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。</p>
<p>（4）第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在<strong>浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端</strong>，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。</p>
<p>（5）webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，<strong>webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新</strong>。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。</p>
<p>（6）HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。</p>
<p>（7）而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。</p>
<p>（8）最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。</p>
<p><strong>9、如何利用webpack来优化前端性能？（提高性能和体验）</strong></p>
<p>用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。</p>
<p>（1）压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css。使用webpack4，打包项目使用production模式，会自动开启代码压缩。</p>
<p>（2）利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径</p>
<p>（3）删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现或者使用<strong>es6模块开启删除死代码</strong>。</p>
<p>（4）优化图片，对于小图可以使用 base64 的方式写入文件中</p>
<p>（5）按照路由拆分代码，实现按需加载，提取公共代码。</p>
<p>（6）给打包出来的文件名添加哈希，实现浏览器缓存文件</p>
<p><strong>10、如何提高webpack的构建速度？</strong></p>
<p>（1）多入口的情况下，使用commonsChunkPlugin来提取公共代码；</p>
<p>（2）通过externals配置来提取常用库；</p>
<p>（3）使用happypack实现多线程加速编译；</p>
<p>（4）使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。原理上webpack-uglify-parallel采用多核并行压缩来提升压缩速度；</p>
<p>（5）使用tree-shaking和scope hoisting来剔除多余代码。</p>
<p><strong>11、怎么配置单页应用？怎么配置多页应用？</strong></p>
<p>单页应用可以理解为<strong>webpack的标准模式</strong>，直接在entry中指定单页应用的入口即可。</p>
<p>多页应用的话，可以使用webpack的 <strong>AutoWebPlugin来完成简单自动化的构建</strong>，但是前提是项目的目录结构必须遵守他预设的规范。</p>
<p><strong>12、npm打包时需要注意哪些？如何利用webpack来更好的构建？</strong></p>
<p>NPM模块需要注意以下问题：</p>
<p>（1）要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则</p>
<p>（2）Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以<strong>打包的最后结果应该是采用ES5编写的</strong>。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。</p>
<p>（3）Npm包大小应该是尽量小（有些仓库会限制包大小）</p>
<p>（4）<strong>发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装</strong>。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。</p>
<p>（5）UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。</p>
<p>基于以上需要注意的问题，我们可以对于webpack配置做以下扩展和优化：</p>
<p>（1）CommonJS模块化规范的解决方案： **设置output.libraryTarget=’commonjs2’**使输出的代码符合CommonJS2 模块化规范，以供给其它模块导入使用；</p>
<p>（2）输出ES5代码的解决方案：<strong>使用babel-loader把 ES6 代码转换成 ES5 的代码</strong>。再通过开启devtool: ‘source-map’输出SourceMap以发布调试。</p>
<p>（3）Npm包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是<strong>修改.babelrc文件，为其加入transform-runtime插件</strong></p>
<p>（4）不能将依赖模块打包到NPM模块中的解决方案：<strong>使用externals配置项来告诉webpack哪些模块不需要打包</strong>。</p>
<p>（5）对于依赖的资源文件打包的解决方案：通过css-loader和extract-text-webpack-plugin来实现，配置如下：</p>
<p><img src="https://www.mwcxs.top/static/upload/pics/2019/2/28IN5rUsvjZdD-j1y65yZ0zpOz.png" alt="img"></p>
<p><strong>13、如何在vue项目中实现按需加载？</strong></p>
<p>经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。</p>
<p>不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，<strong>在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了</strong>。</p>
<p><img src="https://www.mwcxs.top/static/upload/pics/2019/2/28ay2qKVM8pK9YUkX9Ccm7GT8U.png" alt="img"></p>
<p>单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。</p>
]]></content>
      <tags>
        <tag>浅析webpack原理</tag>
      </tags>
  </entry>
  <entry>
    <title>React</title>
    <url>/2021/03/18/recat/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="$ 前言"></a>$ 前言</h3><p>  最近在考虑框架转型，鉴于作为一名JSer，要时时刻刻保持对新技术和流行技术的敏感性，而 React、Vue、Angular 已基本占领现前端市场，React作为领头大哥，建议年轻的JSer们都要学习使用或至少了解这门技术。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8646214-f35c42e6276e7a16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/453/format/webp" alt="img"></p>
<h3 id="版本声明"><a href="#版本声明" class="headerlink" title="$ 版本声明"></a>$ 版本声明</h3><p>  本文使用版本 <strong>React  v16.2.0</strong></p>
<h3 id="什么是-React"><a href="#什么是-React" class="headerlink" title="$ 什么是 React ?"></a>$ 什么是 React ?</h3><p>  React是一个声明式的，高效的，并且灵活的<strong>用于构建用户界面的 JavaScript 库</strong></p>
<p>  一个最简单的React例子</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx">ReactDom.render(<br>    &lt;h1&gt;Hello World&lt;/h1&gt;,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p>  <code>ReactDom.render</code>接受两个参数，第一个是要被插入的内容，第二个是插入到DOM或者说<code>index.html</code>的位置</p>
<h3 id="一个与Html对比的简单组件"><a href="#一个与Html对比的简单组件" class="headerlink" title="$ 一个与Html对比的简单组件"></a>$ 一个与Html对比的简单组件</h3><p>  如下是一个 <code>React 组件</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShoppingList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Componnet</span> </span>&#123;<br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div className=<span class="hljs-string">&quot;shopping-list&quot;</span>&gt;<br>                &lt;h1&gt;Shoping List <span class="hljs-keyword">for</span> &#123;<span class="hljs-built_in">this</span>.props.name&#125;&lt;/h1&gt;<br>                &lt;ul&gt;<br>                    &lt;li&gt;Instagram&lt;/li&gt;<br>                    &lt;li&gt;WhatApp&lt;/li&gt;<br>                    &lt;li&gt;Oculus&lt;/li&gt;<br>                &lt;/ul&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Example usage:  &lt;ShoppingList name=&quot;Mark&quot; /&gt;</span><br></code></pre></td></tr></table></figure>

<p>  在这里，ShoppingList是一个 React组件类，或 React组件类型。组件接受参数，称为属性 <code>props</code>, 并通过 <code>render</code>方法返回一个现实的视图层次结构。</p>
<p>  <code>render</code> 方法返回您要渲染的内容描述，然后React接受该描述并将其渲染到屏幕上，特别是，<code>render</code> 返回一个React 元素，这是一个渲染内容的轻量级的描述。大多数<br> React 开发人员使用 <code>JSX</code> 语法，也是上述案例写到的语法。</p>
<p>   <code>JSX</code> 语法的转换规则为： <code>&lt;div /&gt;</code> 语法在构建是被转换为 <code>React.createElement(&#39;div&#39;)</code>。因此，上面的例子等价于：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">return</span> React.createElement(<span class="hljs-string">&#x27;div&#x27;</span>, &#123;className: <span class="hljs-string">&#x27;shopping-list&#x27;</span>&#125;,<br>    React.createElement(<span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-comment">/* h1 children ... */</span>),<br>    React.createElement(<span class="hljs-string">&#x27;ul&#x27;</span>, <span class="hljs-comment">/* ul children ... */</span>)<br>);<br></code></pre></td></tr></table></figure>

<p>  既然 <code>JSX</code> 在 React 开发者中这么流行，那 <code>JSX</code> 又是什么呢？</p>
<h3 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="$ JSX 语法"></a>$ JSX 语法</h3><p>  <code>JSX</code> 它是 <code>Javascript</code> 的一种拓展语法，能够让你的 <code>Javascript</code> 中和正常描述 HTML一样编写 HTML。</p>
<p>  你可以用 <code>花括号</code> 将任意 <code>Javascript</code> 表达式嵌入到 <code>JSX</code> 中。例如：表达式 <code>1 + 2</code>, 变量 <code>user.firstName</code>, 和函数 <code>formatName(User)</code> 等都可以嵌入使用</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatName</span>(<span class="hljs-params">user</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> user.firstName + <span class="hljs-string">&#x27; &#x27;</span> + user.lastName;<br>&#125;<br><br><span class="hljs-keyword">const</span> user = &#123;<br>    firstName: <span class="hljs-string">&#x27;harper&#x27;</span>,<br>    lastName: <span class="hljs-string">&#x27;Perez&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> element = &#123;<br>    &lt;h1&gt; Hello, &#123;formatName(user)&#125;! &lt;/h1&gt;<br>&#125;<br><br>ReactDOM.render (<br>    element,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p>  请注意，为了方便阅读开发者们常将 <code>JSX</code>分割成多行包裹起来，因为这可以避免<a href="!%5Bimage.png%5D(https://upload-images.jianshu.io/upload_images/8646214-7743ed84018f8ac7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)">分号自动插入</a>的陷阱，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&#123; <span class="hljs-number">1</span><br><span class="hljs-number">2</span> &#125; <span class="hljs-number">3</span><br><span class="hljs-comment">// is transformed to</span><br>&#123; <span class="hljs-number">1</span><br>;<span class="hljs-number">2</span> ;&#125; <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure>

<h5 id="JSX-也是一个表达式"><a href="#JSX-也是一个表达式" class="headerlink" title="JSX 也是一个表达式"></a>JSX 也是一个表达式</h5><p>  编译之后， <code>JSX</code> 表达式也就成了一个常规的 <code>javascript</code> 对象</p>
<p>  也正因为如此，我们可以在 <code>if</code> 语句或这是 <code>for</code> 循环语句中使用 <code>JSX</code>，用它给变量赋值，当做参数接受，或者作为函数的返回值</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getGreeting</span>(<span class="hljs-params">user</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (user) &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello. &#123;formatName(User&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, Stranger<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="用-JSX-指定属性值"><a href="#用-JSX-指定属性值" class="headerlink" title="用  JSX 指定属性值"></a>用  JSX 指定属性值</h5><p>  你可以用花括号嵌入一个 JavaScript 表达式作为属性值</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 用引号形式</span><br><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">tableIndex</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br><span class="hljs-comment">// 用表达式，并且表达式用花括号包裹</span><br><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">img</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure>

<h5 id="用-JSX-指定子元素"><a href="#用-JSX-指定子元素" class="headerlink" title="用 JSX 指定子元素"></a>用 JSX 指定子元素</h5><p>  如果是空标签，可以直接用 <code>/&gt;</code> 闭合</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;user.avatarUrl&#125;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>  如果包含子标签：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Good to see you here.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>比起 <code>HTML</code>，<code>JSX</code> 更接近于<code>Javascript</code>，所以<code>React DOM</code>规范使用驼峰（camelCase）属性命名约定，而不是HTML属性名称，当然，html的部分属性名称也作为保留字，不可使用，例如 <code>class</code>；<br> 因此，<code>class</code> 在 JSX 中 变为 <code>className</code>,  <code>tableindex</code> 变为 <code>tableIndex</code>。</p>
</blockquote>
<h5 id="用-JSX-防止注入攻击"><a href="#用-JSX-防止注入攻击" class="headerlink" title="用 JSX 防止注入攻击"></a>用 JSX 防止注入攻击</h5><p>  在JSX 中嵌入用户输入是安全的:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> title = response.potentiallyMaliciousInput;<br><span class="hljs-comment">// 这样是安全的</span><br><span class="hljs-keyword">const</span> element  = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>  默认情况下， 在渲染之前, React DOM 会格式化(<a href="http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html">escapes</a>) JSX中的所有值. 从而保证用户无法注入任何应用之外的代码. 在被渲染之前，所有的数据都被转义成为了字符串处理。 以避免 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS(跨站脚本)</a> 攻击。</p>
<h3 id="元素渲染到DOM"><a href="#元素渲染到DOM" class="headerlink" title="$ 元素渲染到DOM"></a>$ 元素渲染到DOM</h3><p>  正常情况下，你的 <code>index.html</code> 文件下会有这么一个<code>div</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;root&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>  这个<code>root</code> DOM 节点挂在所有React DOM的位置。正常情况下，对于一个React单页面应用构建，只需要一个单独的根DOM节点即可。但如果要把React整合到现有的APP中，则可能会使用到多个DOM节点。</p>
<p>  React利用<code>render</code>方法将React元素渲染到DOM上，一旦元素被渲染到页面了之后，就不能在修改器子元素或任何元素的属性，就像电影里的一帧，在某以特定的时间点的UI效果，那元素的更新呢？没错，就是重新 <code>render</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>&#123;<br>    cosnt element = &#123;<br>        &lt;div&gt;<br>            &lt;h1&gt;Hello, world&lt;/h1&gt;<br>            &lt;h2&gt;It is &#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleTimeString()&#125;.&lt;/h2&gt;<br>        &lt;/div&gt;<br>    &#125;；<br>    ReactDom.render (<br>        element,<br>        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>    )<br>&#125;<br><br><span class="hljs-built_in">setInterval</span>(tick, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>实际上，大多数 React 应用只会调用一次ReactDom.render()，而实现组件更新的办法就是将代码封装在<strong>有状态的组件</strong>中。</p>
</blockquote>
<h5 id="React-只更新必须更新的部分"><a href="#React-只更新必须更新的部分" class="headerlink" title="React 只更新必须更新的部分"></a>React 只更新必须更新的部分</h5><p>  这正是 React 的强大之处。React DOM 会将元素及其子元素与之前版本逐一对比，并只对有必要更新的 DOM 进行更新, 以达到 DOM 所需的状态。</p>
<p>  开发过程中，更应该每个时间点UI的表现, 而不是关注随着时间不断更新UI的状态, 可以减少很多奇怪的 bug</p>
<h3 id="组件和属性"><a href="#组件和属性" class="headerlink" title="$ 组件和属性"></a>$ 组件和属性</h3><p>  组件 <code>components</code> 和属性 <code>props</code>，其中，属性是单词 <code>property</code> 的代码简写。</p>
<h5 id="定义组件的两种办法"><a href="#定义组件的两种办法" class="headerlink" title="定义组件的两种办法"></a>定义组件的两种办法</h5><p>   定义组件有两种方式</p>
<ol>
<li><strong>函数式组件定义</strong></li>
<li><strong>类组件定义</strong><br>  最简单的定义组件的方法就是写一个 <code>Javascript</code> 函数</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>)  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, props.name<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>  这就是一个有效的组件，它接首了一个 <code>props</code> 参数，并返回了一个React元素，这是一个函数式组件，表面上看，他就是一个 <code>Javascript</code>函数。</p>
<p>  类组件的定义则依赖ES6 的 <code>class</code> 来定义，下面这种定义方法和上方是等效的;</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    render() &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="渲染一个组件"><a href="#渲染一个组件" class="headerlink" title="渲染一个组件"></a>渲染一个组件</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// DOM标签作为组件</span><br><span class="hljs-keyword">const</span> element = &lt;div /&gt;;<br><span class="hljs-comment">// React 元素作为组件</span><br><span class="hljs-keyword">const</span> element = &lt;Welcome name=<span class="hljs-string">&quot;Sara&quot;</span> /&gt;;<br></code></pre></td></tr></table></figure>

<p>  当React 遇到一个代表用户定义组件的元素时，它将 <code>JSX</code> 属性以一个单独对象即<br> <code>props对象</code> 的形式传递给相应的组件，例如</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.mname] <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Wlecome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Sara&quot;</span> /&gt;</span></span>;<br>ReactDOM.render(<br>    element,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p>【<strong>理解</strong>】</p>
<ol>
<li>调用 <code>ReactDOM.render()</code> 方法并向其传入了<code>&lt;Welcome name=&quot;Sara&quot; /&gt;</code>元素</li>
<li>Raect 调用 <code>Welcome</code> 组件，并向其传入了 <code>&#123;name： ‘Sara’&#125;</code> 作为 <code>props对象</code></li>
<li><code>Welcome</code> 组件返回 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code></li>
<li>React DOM 迅速更新 DOM，使其显示为 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code></li>
</ol>
<blockquote>
<p>组件名称总是以大写字母开始， 如本例子中 <code>&lt;Welcome /&gt;</code>, 而不是 <code>&lt;welcome /&gt;</code></p>
</blockquote>
<h5 id="构成组件"><a href="#构成组件" class="headerlink" title="构成组件"></a>构成组件</h5><p>  既然组件是单独的一个React元素，那他能单独工作，因此我们能在一个React 元素中多次引用到相同的组件, 举个例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;Welcome name=<span class="hljs-string">&quot;Sara&quot;</span> /&gt;<br>        &lt;Welcome name=<span class="hljs-string">&quot;Lucy&quot;</span> /&gt;<br>        &lt;Welcome name=<span class="hljs-string">&quot;Edite&quot;</span> /&gt;<br>    )<br>&#125;<br><br>ReactDOM.render(<br>    &lt;App /&gt;,<br>    document.getElementBuId(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p>  通常情况下， React apps 都有一个单独的顶层的 <code>App</code> 组件。如果是在已有的应用中整合React，也需要由下至上的从小的组件开始逐步整合到视图顶层的组件中。</p>
<blockquote>
<p>组件必须返回一个单独的根元素，这就是为什么我们要添加一个 <code>&lt;div&gt;</code>来包裹所有的<code>&lt;Welcome /&gt;</code> 元素的原因</p>
</blockquote>
<h5 id="提取组件"><a href="#提取组件" class="headerlink" title="提取组件"></a>提取组件</h5><p>  对于一个React 元素，如果其中含有可复用或可能会重复使用的内容，不要害怕把它单拿出来多个更小的组件。</p>
<p>  提取组件可能看起来是一个繁琐的工作，但是在大型的 <code>App</code> 中可以回报给我们的是大量的可复用组件。一个好的经验准则是如果你 UI 的一部分需要用多次 (<code>Button</code>，<code>Panel</code>，<code>Avatar</code>)，或者本身足够复杂(<code>App</code>，<code>FeedStory</code>，<code>Comment</code>)，最好的做法是使其成为可复用组件。</p>
<h5 id="Props-是只读的"><a href="#Props-是只读的" class="headerlink" title="Props 是只读的"></a>Props 是只读的</h5><p>  无论你用<a href="http://www.css88.com/react/docs/components-and-props.html#functional-and-class-components">函数或类</a>的方法来声明组件,</p>
<p>  虽然 React 很灵活，但是它有一条严格的规则：**所有 React 组件都必须是纯函数，并禁止修改其自身 props **。所谓的纯函数就是：传入函数参数不会在函数执行过程中发生改变，比如自增操作 <code>a++</code>。</p>
<p>  如果<code>props</code>是只读的，那传递给子元素（子组件）的参数岂不是不能修改了？那子元素如何与父元素做交互呢？React还给我们提供了状态属性 <code>state</code>供我们在子组件内部修改值</p>
<h3 id="状态和生命周期"><a href="#状态和生命周期" class="headerlink" title="状态和生命周期"></a>状态和生命周期</h3><p>  状态<code>state</code>, 生命周期 <code>liftcircle</code>.<br>  之前说过，一旦元素被渲染了之后就不可改变了，但我们可以通过重新渲染的方法使页面得以刷新，同样我们提到过最常用的方法是编写一个可复用的具有状态的组件，这里的状态，就是我们将要说的 <code>state</code></p>
<p>  我们对上述提过的计时器<code>tick</code> 中的计时功能封装成一个函数式组件如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Clock</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;<br>            &lt;h1&gt;Hello, world!&lt;/h1&gt;<br>            &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;<br>        &lt;/div&gt;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  然后把他当做一个元素放入 <code>tick</code> 中进行渲染</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs tsx">function tick() &#123;<br>    ReactDOM.render(<br>        &lt;Clock date&#x3D;&#123;new Date()&#125; &#x2F;&gt;,<br>        document.getElementById(&#39;root&#39;)<br>    )<br>&#125;<br><br>setInterval(tick, 1000);<br></code></pre></td></tr></table></figure>

<p>  在这个例子中，我们将计时功能代码封装成了一个独立的可复用的组件，并通过属性date的方式将参数传入，但还不能到达我们想要的结果，那就是不能再组件内部修改参数值，组件中显示的数据依旧受控于父组件中<code>date</code>属性传递过来的值，那如果我们把这个<code>date</code>属性也添加到<code>Clock</code>内部呢？来看下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">ReactDOM.render(<br>    &lt;Clock /&gt;,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p>  这时父组件中只保留了对计时组件<code>Clock</code>的一个单纯的引用。剩下的事情全部依托以组件<code>Clock</code>自己去实现。要怎么实现这个需求？这里React提出了另一个数据对象，即<code>state</code>，它用来保存组件内部的数据，与<code>props</code>类似，不同的是<code>state</code>是组件私有的，并且由组件本身完全控制。它能实现数据在组件内部的修改和更新。怎么使用这个<code>state</code>？继续往下讲之前我们先拓展一个知识</p>
<p>  我们知道组件有两种定义方式，即函数式组件和类组件，虽然函数式组件更加简洁更加接近原生 <code>javascript</code>，但类组件却拥有一些额外的属性，这个<strong>类组件专有特性</strong>，就是<strong>状态</strong>和<strong>生命周期钩子</strong>，到这里也能清楚知道状态的关键作用，然而函数式组件没有这两个特性，因此，在需要使用到状态<code>state</code>情况下，我们需要将函数式组件转换成类组件</p>
<h5 id="函数式组件转化成类组件"><a href="#函数式组件转化成类组件" class="headerlink" title="函数式组件转化成类组件"></a>函数式组件转化成类组件</h5><p>  尝试把一个函数式组件转化成类组件，官网给出了以下步骤，以<code>Clock</code>组件为例</p>
<ol>
<li>创建一个继承自 <code>React.Component</code> 类的 <code>ES6 class</code> 同名类</li>
<li>添加一个名为 <code>render()</code> 的空方法</li>
<li>把原函数中的所有内容移至 <code>render()</code> 中</li>
<li>在 <code>render()</code> 方法中使用 <code>this.props</code> 替代 <code>props</code></li>
<li>删除保留的空函数声明</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-title">extents</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;h1&gt;Hello, world&lt;/h1&gt;<br>                &lt;h2&gt;It is &#123;<span class="hljs-built_in">this</span>.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  到此，<code>Clock</code> 组件已经成功被我们修改成了一个类组件，我们便可以在其中添加本地状态<code>state</code>和生命周期钩子</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-comment">// 用类构造函数constructor初始化 this.state</span><br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-comment">// 使用super()将props传递给基础构造函数</span><br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;;<br>    &#125;<br><br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;h1&gt;Hello, world&lt;/h1&gt;<br>                &lt;h2&gt;It is &#123;<span class="hljs-built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  这样，我们的类组件<code>Clock</code> 就拥有了自己的属性 <code>this.state.date</code>，也就不需要引用组件向其传递值了，因此，我么可以把组件引用中的<code>date</code>属性删掉，最终，我们将其渲染到DOM上，只使用组件引用，其他都交给组件<code>Clock</code>自己去实现</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">ReactDOM.render(<br>    &lt;Clock /&gt;,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p>  到这里就结束了？细心的你会发现，组件<code>Clock</code>只是实现了当前时间的显示，而我们要改装的功能是一个计时器，计时功能去哪里了？没实现啊？我们需要在组件<code>Clock</code>中找到一个合适的时机去实现这个功能，为此，React团队引入了 声明周期方法，也叫生命周期钩子</p>
<h5 id="在类组件中添加生命周期方法"><a href="#在类组件中添加生命周期方法" class="headerlink" title="在类组件中添加生命周期方法"></a>在类组件中添加生命周期方法</h5><p>  在一个具有许多组件的应用程序中，在组件被销毁时释放所占用的资源是非常重要的。就像浏览器的垃圾回收机制，近期内不需要再用的资源，应该及时清除。</p>
<p>  当 <code>Clock</code> 第一次渲染到DOM时，我们要<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval">设置一个定时器</a> 。 这在 React 中称为 “挂载(mounting)” 。它有一个生命钩子<code>componentDidMount()</code></p>
<p>当 <code>Clock</code> 产生的 DOM 被销毁时，我们也想<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval">清除该计时器</a>。 这在 React 中称为 “卸载(unmounting)” 。它的生命钩子是<code>componentWillUnmount()</code></p>
<p>  我们的计时器是在页面加载之后，页面生成初始化状态，然后由计时器去触发状态的刷新，因此，在挂载完成是去设置计时器是个非常不错的选择</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx">componentDidMount() &#123;<br>    <span class="hljs-built_in">this</span>.timerID = <span class="hljs-built_in">setInterval</span>(<br>        () =&gt; <span class="hljs-built_in">this</span>.tick(), <span class="hljs-number">1000</span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  这样我们就实现了组件计时功能，或许你注意到了，在该例中，我们把<code>timerID</code>存放在<code>this</code>中而不是<code>this.state</code>中。</p>
<p>  其实，<code>this.props</code>和<code>this.state</code>也是数据对象与普通对象一样用来存放数据，只是他们被React团队赋予了新的职能， <code>this.props</code>由React本身设定，用来存放在组件引用时的属性键值对对象集，不允许Coder们自己去修改；而<code>this.state</code>也具有特殊的含义，即存放组件本身的、用于视觉输出的数据，但也不是说在编写React程序的时候就必须用用这两个，我们依然可以自己定义普通的数据结构。</p>
<p>  既然<code>state</code>是用于存放组件视觉输出的数据，那在<code>render()</code>方法中没有被引用的，就不应该出现在<code>state</code>中了。</p>
<p>  养成良好的编码习惯，编写好计时器时，及时的编写卸载事件。卸载时我们清除的数据也是从<code>this</code>中拿的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">componentWillUnmount() &#123;<br>    clearInterval(<span class="hljs-keyword">this</span>.timerID);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  挂载时我们声明了一个<code>tick()</code>方法，接下来我们就要实现这个方法，是用来触发UI更新。嗯哼？UI更新？我们的页面状态<code>state</code>不是已经更新了吗？为啥还要UI更新？</p>
<p>  这里有一个非常重要的方法：<code>setState()</code>。我们先把代码补充完整再说明</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx">componentDidMount() &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>tick() &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>        date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>    &#125;)<br>&#125;<br><br>componentWillUnmount() &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>  <code>setState()</code>是React触发页面更新的第二个办法，第一个办法开篇即说过，即<code>render()</code>方法。<code>setState</code>作用就是通知React检查带状态的组件中是否含有脏值。此时react会生成一个虚拟DOM与之前的版本进行对比，只有有必要更新时才会更新。关于 <a href="https://www.jianshu.com/p/54a8a0688197">state 与 setState过程</a> 在我的另一篇文章中有详细说明，有兴趣的可以翻过去看看。</p>
<p>  为什么不把<code>tick()</code>方法写到<code>componentDidMount()</code>中？因为<code>tick()</code>只是一个普通方法，他不需要在生命周期中触发，也不用自动触发。只要谁调用了触发即可。因此不需要也不能放在生命周期钩子函数中。</p>
<p>  现在这个时钟每秒都会走了。整理一下，我们整个计时器代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(props) &#123;<br>    <span class="hljs-built_in">super</span>(props);<br>    <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;;<br>  &#125;<br><br>  componentDidMount() &#123;<br>    <span class="hljs-built_in">this</span>.timerID = <span class="hljs-built_in">setInterval</span>(<br>      () =&gt; <span class="hljs-built_in">this</span>.tick(),<br>      <span class="hljs-number">1000</span><br>    );<br>  &#125;<br><br>  componentWillUnmount() &#123;<br>    <span class="hljs-built_in">clearInterval</span>(<span class="hljs-built_in">this</span>.timerID);<br>  &#125;<br><br>  tick() &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>    &#125;);<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &lt;h1&gt;Hello, world!&lt;/h1&gt;<br>        &lt;h2&gt;It is &#123;<span class="hljs-built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br><br>ReactDOM.render(<br>  &lt;Clock /&gt;,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>

<p>整个流程的执行过程是这样的：</p>
<ol>
<li>当 <code>&lt;Clock /&gt;</code> 被传入<code>ReactDOM.render()</code> 时,  React 会调用 <code>Clock</code>组件的构造函数。 因为 <code>Clock</code> 要显示的是当前时间，所以它将使用包含当前时间的对象来初始化 <code>this.state</code>。我们稍后会更新此状态。</li>
<li>然后 React 调用了 <code>Clock</code> 组件的 <code>render()</code> 方法。 React 从该方法返回内容中得到要显示在屏幕上的内容。然后，React 然后更新 DOM 以匹配 <code>Clock</code> 的渲染输出。</li>
<li>当 <code>Clock</code> 输出被插入到 DOM 中时，React 调用 <code>componentDidMount()</code> 生命周期钩子。在该方法中，<code>Clock</code> 组件请求浏览器设置一个定时器来一次调用 <code>tick()</code>。</li>
<li>浏览器会每隔一秒调用一次 <code>tick()</code>方法。在该方法中， <code>Clock</code> 组件通过 <code>setState()</code> 方法并传递一个包含当前时间的对象来安排一个 UI 的更新。通过 <code>setState()</code>, React 得知了组件 <code>state</code>(状态)的变化, 随即再次调用 <code>render()</code> 方法，获取了当前应该显示的内容。 这次，<code>render()</code> 方法中的 <code>this.state.date</code> 的值已经发生了改变， 从而，其输出的内容也随之改变。React 于是据此对 DOM 进行更新。</li>
<li>如果通过其他操作将 <code>Clock</code> 组件从 DOM 中移除了, React 会调用 <code>componentWillUnmount()</code> 生命周期钩子, 所以计时器也会被停止。</li>
</ol>
<h5 id="正确的使用State（状态）"><a href="#正确的使用State（状态）" class="headerlink" title="正确的使用State（状态）"></a>正确的使用State（状态）</h5><p>  对于<code>setState()</code> 有三件事情是我们应该要知道的</p>
<p><strong>（1）不要直接修改state</strong><br>  真正触发React对比不同版本的虚拟DOM是<code>setState()</code> 方法，直接修改<code>state</code>页面不会刷新，这一点与原生<code>javascript</code>区别较大，需要理解。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这么做不会触发React更新页面</span><br><span class="hljs-keyword">this</span>.state.comment = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-comment">// 使用 setState() 代替</span><br><span class="hljs-keyword">this</span>.setState(&#123; comment: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure>

<p>  【注意】在组件中，唯一可以初始化分配<code>this.state</code>的地方就是构造函数<code>constructor()&#123;&#125;</code></p>
<p><strong>（2）state（状态）更新可能是异步的</strong><br>  React为了优化性能，有可能会将多个<code>setState()</code> 调用合并为一次更新。这就导致 <code>this.props</code> 和<code>this.state</code> 可能是异步更新的，你不能依赖他们的值计算下一个<code>state(状态)</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// counter 计数更新会失败</span><br><span class="hljs-keyword">this</span>.setState(&#123;<br>    counter: <span class="hljs-keyword">this</span>.state.counter <span class="hljs-keyword">this</span>.props.increment<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>  如果我们有这种需求，可以使用以下<code>setState()</code>办法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// ES6 箭头函数法</span><br><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">prevState, props</span>) =&gt;</span> (&#123;<br>    counter: prevState.counter + props.increment<br>&#125;));<br><span class="hljs-comment">// 常规函数法</span><br><span class="hljs-built_in">this</span>.setState(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prevState, props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        counter: prevState.counter + props.increment<br>    &#125;;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><strong>（3）state（状态）更新会被合并</strong><br> 当你调用<code>setState()</code>, React将合并你提供的对象到当前状态中。例如，你的状态可能包含几个独立的变量，然后你用几个独立的setState方法去调用更新，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs tsx">constructor(props) &#123;<br>    super(props);<br>    this.state &#x3D; &#123;<br>        posts: [],<br>        comments: []<br>    &#125;;<br>&#125;<br><br>componentDidMount() &#123;<br>    fetchPosts().then(response &#x3D;&gt; &#123;<br>        this.setState(&#123;<br>            posts: response.posts<br>        &#125;);<br>    &#125;);<br><br>    fetchComments().then(response &#x3D;&gt; &#123;<br>        this.setState(&#123;<br>            comments: response.comments<br>        &#125;);<br>    &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>  合并是<strong>浅合并</strong>，所以，<code>this.setState(&#123;comments&#125;)</code>在合并过程中不会改变<code>this.state.posts</code>的值，但是会完全替换<code>this.state.comments</code> 的值</p>
<h5 id="数据向下流动"><a href="#数据向下流动" class="headerlink" title="数据向下流动"></a>数据向下流动</h5><p>  无论是作为父组件还是子组件，它都无法或者一个组件是否有状体，同时也不需要关心另一个组件是定义为函数组件还是类组件。这就是为什么<code>state</code>经常被称为 <strong>本地状态</strong>  或 <strong>封装状态</strong>  的原因， 他不能被拥有并设置它的组件以外的任何组件访问。那如果需要访问怎么处理？<br> <strong>（1）作为其子组件的props（属性）</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在组件中使用</span><br>&lt;h2&gt;It <span class="hljs-keyword">is</span> &#123;<span class="hljs-keyword">this</span>.state.date.toLocaleTimeString()&#125;&lt;/h2&gt;<br><span class="hljs-comment">// 传递给子组件作为props</span><br>&lt;FormattedDate date=&#123;<span class="hljs-keyword">this</span>.state.date&#125; /&gt;<br></code></pre></td></tr></table></figure>

<p>  虽然<code>FormattedDate</code>组件通过<code>props</code>接收了<code>date</code>的值，但它仍然不能获知该值是来自于<code>Clock</code>的<code>state</code>, 还是 <code>Clock</code>的<code>props</code>, 或者一个手动创建的变量.</p>
<p>  这种数据关系，一般称为”从上到下”或”单向”的数据流。任何<code>state(状态)</code>始终由某个特定组件所有，并且从该<code>state</code>导出的任何数据 或 UI 只能影响树”下方”的组件</p>
<p>  如果把组件树想像为 <code>props(属性)</code> 的瀑布，所有组件的 <code>state(状态)</code> 就如同一个额外的水源汇入主流，且只能随着主流的方向向下流动。</p>
<h5 id="各组件完全独立"><a href="#各组件完全独立" class="headerlink" title="各组件完全独立"></a>各组件完全独立</h5><p>  借用上文的<code>Clock</code>组件，我们创建一个<code>App</code>组件，并在其中渲染三个<code>Clock</code>:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="hljs-comment">// 之前说过组件只能返回一个根节点，所以用&lt;div&gt;包起来</span><br>        &lt;div&gt;<br>            &lt;Clock /&gt;<br>            &lt;Clock /&gt;<br>            &lt;Clock /&gt;<br>        &lt;/div&gt;<br>    );<br>&#125;<br>ReactDOM.render(<br>    &lt;App /&gt;,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>

<p>  每个<code>Clock</code>都设立它自己的计时器并独立更新，如果<code>App</code>中有一个数据变量，也能被三个<code>Clock</code>相互独立修改。</p>
<p>  至于何时使用有状态组件，何时使用无状态组件，被认为是组件的一个实现细节，取决于你当时的需求，你可以在有状态组件中使用无状态组件，也可以在无状态组件中使用有状态组件</p>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="$ 事件处理"></a>$ 事件处理</h3><p>  通过 React 元素处理事件跟在 DOM 元素上处理事件非常相似。但是有一些语法上的区别：</p>
<ol>
<li>React 事件使用驼峰命名，而不是全部小写</li>
<li>通过 JSX , 传递一个函数作为事件处理程序，而不是一个字符串</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">// html usage<br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;todo()&quot;</span>&gt;</span>click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>// React usage<br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;todo&#125;</span>&gt;</span>click me&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol>
<li>在React中不能通过返回<code>false</code>来阻止默认行为。必须明确的调用<code>preventDefault</code></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">// html usage<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;clicked&#x27;); return false&quot;</span>&gt;</span><br>    Click me<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>



<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// React usage</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActionLink</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleClick</span>(<span class="hljs-params">e</span>) </span>&#123;<br>        e.preventDefault();<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;clicked.&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;a href=<span class="hljs-string">&quot;#&quot;</span> onClick=&#123;handleClick&#125;&gt;<br>            Click me<br>        &lt;/a&gt;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  在这里，React团队帮Coder们实现了e事件的跨浏览器兼容问题。当使用React时，我们也不需要调用<code>addEventListener</code>在DOM 元素被创建后添加事件监听器。相反，只要当元素被初始渲染的时候提供一个监听器就可以了。</p>
<p>  当使用ES6类定义一个组件时，通常的一个事件处理程序就是类上的一个方法，看个例子，<code>Toggle</code> 组件渲染一个按钮，让用户在 “ON” 和 “OFF” 状态之间切换：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Toggle</span> <span class="hljs-title">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.state = &#123;isToggleOn: <span class="hljs-literal">true</span>&#125;;<br><br>    <span class="hljs-comment">// 这个绑定是必要的，使`this`在回调中起作用</span><br>    <span class="hljs-keyword">this</span>.handleClick = <span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>);<br>  &#125;<br><br>  handleClick() &#123;<br>    <span class="hljs-keyword">this</span>.setState(prevState =&gt; (&#123;<br>      isToggleOn: !prevState.isToggleOn<br>    &#125;));<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;button onClick=&#123;<span class="hljs-keyword">this</span>.handleClick&#125;&gt;<br>        &#123;<span class="hljs-keyword">this</span>.state.isToggleOn ? <span class="hljs-string">&#x27;ON&#x27;</span> : <span class="hljs-string">&#x27;OFF&#x27;</span>&#125;<br>      &lt;/button&gt;<br>    );<br>  &#125;<br>&#125;<br><br>ReactDOM.render(<br>  &lt;Toggle /&gt;,<br>  document.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>

<h5 id="绑定类方法"><a href="#绑定类方法" class="headerlink" title="绑定类方法"></a>绑定类方法</h5><p>  在JSX回调中你必须注意 <code>this</code> 的指向。 在 JavaScript 中，类方法默认没有 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind">绑定</a> 的。如果你忘记绑定 <code>this.handleClick</code> 并将其传递给<code>onClick</code>，那么在直接调用该函数时，<code>this</code> 会是 <code>undefined</code> 。</p>
<p> 这不是 React 特有的行为；这是 <code>JavaScript</code> 中的函数如何工作的一部分，可以使用属性初始值设置来正确地 绑定(<code>bind</code>) 回调，但这是实验性做法，不建议使用，以后有可能会废弃，如果你没有使用属性初始化语法<br> （1）可以在回调中使用一个 <code>arrow functions</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    handleClick() &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this is: &#x27;</span>, <span class="hljs-built_in">this</span>)<br>    &#125;<br><br>    render() &#123;<br>        <span class="hljs-comment">// 这个语法确保 `this` 被绑定在 handleClick 中</span><br>        <span class="hljs-keyword">return</span> (<br>            &lt;button onClick=&#123;<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-built_in">this</span>.handleClick(e)&#125;&gt;<br>                Click me<br>            &lt;/button&gt;<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>（2）使用<code>Function.prototype.bind</code> 方法，相对简洁方便</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">&lt;button onClick=&#123;<span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>)&#125;&gt;<br>    Click me<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<h5 id="传递参数给事件处理程序"><a href="#传递参数给事件处理程序" class="headerlink" title="传递参数给事件处理程序"></a>传递参数给事件处理程序</h5><p>  在循环内部，通常需要将一个额外的参数传递给事件处理程序，常用的有一下两种方案;</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">&lt;button onClick=&#123;(e)  =&gt; <span class="hljs-keyword">this</span>.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;<br>&lt;button onClick=&#123;<span class="hljs-keyword">this</span>.deleteRow.bind(<span class="hljs-keyword">this</span>.id)&#125;&gt;Delete Row&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<p>  上面两个例子中，参数 <code>e</code> 作为 React 事件对象将会被作为第二个参数进行传递。通过箭头函数的方式，事件对象必须显式的进行传递，但是通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="$ 条件渲染"></a>$ 条件渲染</h3><blockquote>
<p>在 React 中，你可以创建不同的组件封装你所需要的行为。然后，只渲染它们之中的一些，取决于你的应用的状态。</p>
</blockquote>
<h5 id="整个组件的条件渲染"><a href="#整个组件的条件渲染" class="headerlink" title="整个组件的条件渲染"></a>整个组件的条件渲染</h5><p>  React 中的条件渲染就可在JS中的条件语句一样，使用JS操作符如<code>if</code>或者条件控制符来创建渲染当前的元素，并且让React更新匹配的UI。比如我们有一个需求，需要判断用户是否登录，来显示不同组件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserGreeting</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome back!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GustGrreeting</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Please sign up.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> isLoggedIn = props.isLoggedIn;<br>    <span class="hljs-keyword">if</span> (isLoggedIn) &#123;<br>        <span class="hljs-keyword">return</span> &lt;UserGreeting /&gt;<br>    &#125; <br>    <span class="hljs-keyword">return</span> &lt;GuestGreeting /&gt;<br>&#125;<br><br>ReactDOM.render(<br>    &lt;Greeting isLoggedIn=&#123;<span class="hljs-literal">false</span>&#125; /&gt;,<br>    document.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>

<h5 id="使用元素变量条件渲染部分内容"><a href="#使用元素变量条件渲染部分内容" class="headerlink" title="使用元素变量条件渲染部分内容"></a>使用元素变量条件渲染部分内容</h5><p>  你可以用变量来存储元素。这可以帮助您有条件地渲染组件的一部分，而输出的其余部分不会更改。下方两个组件用于显示登出和登入按钮</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LoginButton</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span>(<br>        &lt;button onClick=&#123;props.onClick&#125;&gt;Login&lt;/button&gt;<br>    )<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LogoutButton</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;button onClick=&#123;props.onclick&#125;&gt;Logout&lt;/button&gt;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  登入登出按钮已做好，接下来需要实现有切换功能的一个有状态的组件，为了更系统化学习，我们把前面的<code>Greeting</code>组件一起加进来</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginControl</span> <span class="hljs-title">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-keyword">super</span>(props);<br>        <span class="hljs-keyword">this</span>.state = &#123;<br>            isLoginedIn: <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br><br>    handleLoginClick() &#123;<br>        <span class="hljs-keyword">this</span>.setState(&#123;   isLoggedIn: <span class="hljs-literal">true</span> &#125;);<br>    &#125;<br><br>    handleLogoutClick() &#123;<br>        <span class="hljs-keyword">this</span>.setState(&#123; isLoggedIn: <span class="hljs-literal">false</span> &#125;);<br>    &#125;<br><br>    render() &#123;<br>        <span class="hljs-keyword">const</span> isLoggedIn = <span class="hljs-keyword">this</span>.state.isLoggedIn;<br><br>        let button = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (isLoggedIn) &#123;<br>            button = &lt;LogoutButton onClick=&#123;<span class="hljs-keyword">this</span>.handleLogoutClick.bind(<span class="hljs-keyword">this</span>)&#125; /&gt;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            button = &lt;LoginButton onclick=&#123;<span class="hljs-keyword">this</span>.handleLoginClick.bind(<span class="hljs-keyword">this</span>)&#125; /&gt;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;&#123;button&#125;&lt;/div&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br><br>reactDOM.render(<br>    &lt;LoginControl /&gt;,<br>    document.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p>  使用<code>if</code>是很常见的一种做法，当然也有一些更简短的语。<code>JSX</code>中有几种内联条件的方法，</p>
<p><strong>（1）使用逻辑与&amp;&amp;操作符的内联if用法</strong><br>  我们可以在 <code>JSX</code> 中嵌入任何表达式，方法是将其包裹在花括号中，同样适用于JS的逻辑与&amp;&amp;运算符</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mailbox</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> unreadMessages = props.unreadMessages;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;<br>            &lt;h1&gt;Hello!&lt;/h1&gt;<br>            &#123; unreadMeaasges.length &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                &lt;h2&gt; You have &#123;unreadMessages.length&#125; unread messages.<br>            &#125;<br>        &lt;/div&gt;<br>    )<br>&#125;<br><br>cosnt message = [<span class="hljs-string">&#x27;React&#x27;</span>, <span class="hljs-string">&#x27;Re: React&#x27;</span>, <span class="hljs-string">&#x27;Re:Re: React&#x27;</span>];<br>ReactDOM.render(<br>    &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;,<br>    document.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>

<p>  该案例是可以正常运行的，因为在 <code>JavaScript</code> 中， <code>true &amp;&amp; expression</code> 总是会评估为 <code>expression</code> ，而 <code>false &amp;&amp; expression</code> 总是执行为 <code>false</code> 。并且我们可以在表达式中嵌入表达式</p>
<p><strong>（2）使用条件操作符的内联If-Else</strong><br>  条件操作符 即三目表达式：<code>condition ？ trueExpression : falseExpression</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 条件渲染字符串</span><br>&lt;div&gt;The user <span class="hljs-keyword">is</span> &#123;isLoggedIn ? <span class="hljs-string">&#x27;currently&#x27;</span> : <span class="hljs-string">&#x27;not&#x27;</span>&#125; logged <span class="hljs-keyword">in</span>.&lt;/div&gt;<br><span class="hljs-comment">// 条件渲染组件</span><br>&lt;div&gt;<br>    &#123;isLoggedIn ? (<br>        &lt;LogoutButton onClick=&#123;<span class="hljs-keyword">this</span>.handleLogoutClick&#125; /&gt;<br>    ) : (<br>        &lt;LoginButton onClick=&#123;<span class="hljs-keyword">this</span>.handleLoginClick&#125; /&gt;<br>    )&#125;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>  总之，遵循一个原则，哪种方式易于阅读，就选择哪种写法。并且，但条件变得越来越复杂时，可能是提取组件的好时机。</p>
<h5 id="阻止组件渲染"><a href="#阻止组件渲染" class="headerlink" title="阻止组件渲染"></a>阻止组件渲染</h5><p>  在极少数情况下，您可能希望组件隐藏自身，即使它是由另一个组件渲染的。为此，返回 <code>null</code> 而不是其渲染输出。注意这里是不渲染，不是不显示。</p>
<p>  在下面的例子中，根据名为<code>warn</code>的 <code>props</code> 值，呈现 <code>&lt;WarningBanner /&gt;</code> 。如果 <code>props</code> 值为 <code>false</code> ，则该组件不渲染：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WarningBanner</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (props.warn) &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> (<br>        &lt;div className=<span class="hljs-string">&quot;warning&quot;</span>&gt;Warning&lt;/div&gt;<br>    )<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">showWarning</span>: <span class="hljs-literal">true</span> &#125;<br>    &#125;<br><br>    handleToggleClick() &#123;<br>        <span class="hljs-built_in">this</span>.setState(<span class="hljs-function"><span class="hljs-params">prevState</span> =&gt;</span> (&#123;<br>            showWarning: !prevState.showWarning<br>        &#125;));<br>    &#125;<br><br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;Warningbanner warn=&#123;<span class="hljs-built_in">this</span>.state.showWarning&#125; /&gt;<br>                &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.handleToggleClick.bind(<span class="hljs-built_in">this</span>)&#125;&gt;<br>                    &#123; <span class="hljs-built_in">this</span>.state.showWarning ?   <span class="hljs-string">&#x27;Hide&#x27;</span> : <span class="hljs-string">&#x27;Show&#x27;</span>&#125;<br>                 &lt;/button&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br><br>ReactDOM.render(<br>    &lt;Page /&gt;,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p>  从组件的 <code>render</code> 方法返回 <code>null</code> 不会影响组件生命周期方法的触发。 例如， <code>componentWillUpdate</code> 和<code>componentDidUpdate</code> 仍将被调用。因此需要组件刚载入时就要判断执行返回<code>null</code></p>
<h3 id="后语"><a href="#后语" class="headerlink" title="$ 后语"></a>$ 后语</h3><p>  本文为React系统性需学习上半文，下半文主要包括：</p>
<ol>
<li>列表(<code>List</code>) 和 键(<code>keys</code>)</li>
<li>表单(<code>Forms</code>)</li>
<li>状态提升(<code>Lifting State Up</code>)</li>
<li>组合 VS 继承 (<code>Composition vs inheritance</code>)</li>
</ol>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Ts</title>
    <url>/2021/03/18/typeScript/</url>
    <content><![CDATA[<h3 id="TypeScript开发"><a href="#TypeScript开发" class="headerlink" title="TypeScript开发"></a>TypeScript开发</h3><p>全局安装typescript，使用安装命令可以使用<code>npm</code>也可以使用<code>yarn</code>： </p>
<p>命令：</p>
<p>npm install typescript -g</p>
<p>yarn global add typescript</p>
<h5 id="demo-ts"><a href="#demo-ts" class="headerlink" title="demo.ts"></a>demo.ts</h5><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jeskson</span>(<span class="hljs-params"></span>) </span>&#123;<br> <span class="hljs-keyword">let</span> web: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;hello world&quot;</span><br> <span class="hljs-built_in">console</span>.log(web)<br>&#125;<br><br>jeskson()<br><br><span class="hljs-comment">// tsc</span><br>tes demo.ts<br>node demo.js<br></code></pre></td></tr></table></figure>

<p>npm install -g ts-node</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>TS的数据类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// ES6的数据类型：</span><br>基本数据类型：<span class="hljs-built_in">Boolean</span>,<span class="hljs-built_in">Number</span>,<span class="hljs-built_in">String</span>,<span class="hljs-built_in">Symbol</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-literal">null</span><br><br>引用类型：<span class="hljs-built_in">Array</span>,<span class="hljs-built_in">Function</span>,<span class="hljs-built_in">Object</span><br><br><span class="hljs-comment">// TS的数据类型，增加</span><br><span class="hljs-built_in">any</span>(任意类型)  <span class="hljs-built_in">void</span>(空类型)  <span class="hljs-built_in">enum</span>（枚举类型）Tuple（元祖类型）<br></code></pre></td></tr></table></figure>

<p>类型注解：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> hello : <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Hello TypeScript&#x27;</span><br></code></pre></td></tr></table></figure>

<p>原始类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> bl: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span><br><span class="hljs-keyword">let</span> num: <span class="hljs-built_in">number</span> = <span class="hljs-number">123</span><br><span class="hljs-keyword">let</span> str: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;123&quot;</span><br></code></pre></td></tr></table></figure>

<p>数组泛型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> arrType: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> arrType1: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; = [<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>];<br><span class="hljs-keyword">let</span> arrType2: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">any</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-literal">true</span>];<br></code></pre></td></tr></table></figure>

<p>用接口表示数组</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Person&#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> NumberArray &#123;<br>       [index:<span class="hljs-built_in">number</span>]: Person;         <br>&#125;<br><span class="hljs-keyword">let</span> arrType3: NumberArray = [&#123;name:<span class="hljs-string">&#x27;张三&#x27;</span>，age: <span class="hljs-number">20</span>&#125;]<br><span class="hljs-keyword">let</span> arrType4：<span class="hljs-built_in">Array</span>&lt;Person&gt; = [&#123;name:<span class="hljs-string">&#x27;张三&#x27;</span>，age: <span class="hljs-number">20</span>&#125;]<br><span class="hljs-keyword">let</span> arrType5：Person[] = [&#123;name:<span class="hljs-string">&#x27;张三&#x27;</span>，age: <span class="hljs-number">20</span>&#125;]<br></code></pre></td></tr></table></figure>

<blockquote>
<p>类数组</p>
</blockquote>
<p>类数组（Array-like Object）不是数组类型:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> args: <span class="hljs-built_in">number</span>[] = <span class="hljs-built_in">arguments</span>;<br>&#125;<br><br><span class="hljs-comment">// index.ts(2,7): error TS2322: Type &#x27;IArguments&#x27; is not assignable to type &#x27;number[]&#x27;.</span><br><span class="hljs-comment">//   Property &#x27;push&#x27; is missing in type &#x27;IArguments&#x27;.</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> args: IArguments = <span class="hljs-built_in">arguments</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>元组类型</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> tuple: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>] = [<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;1&#x27;</span>]<br><span class="hljs-comment">// 此时,如果改变数组的元素类型或添加元素数量,编辑器都会报错</span><br><span class="hljs-comment">// TS允许向元组中使用数组的push方法插入新元素(但不允许访问)</span><br></code></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数声明（Function Declaration）和函数表达式（Function Expression）</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 函数声明（Function Declaration）</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-comment">// 函数表达式（Function Expression）</span><br><span class="hljs-keyword">let</span> mySum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br><span class="hljs-comment">// 函数声明的类型定义</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x:<span class="hljs-built_in">number</span>,y:<span class="hljs-built_in">number</span></span>):<span class="hljs-title">number</span></span>&#123;<br>       <span class="hljs-keyword">return</span> x+y  <br>&#125;<br><span class="hljs-comment">// 输入多余的或者少于要求的参数，是不被允许的</span><br><br><span class="hljs-comment">// 函数表达式</span><br><span class="hljs-keyword">let</span> mySun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x:<span class="hljs-built_in">number</span>,y:<span class="hljs-built_in">number</span></span>):<span class="hljs-title">number</span></span>&#123;<br>      <span class="hljs-keyword">return</span> x + y  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>用接口定义函数的形状</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SearchFunc&#123;<br>       （source:<span class="hljs-built_in">string</span>,subString:<span class="hljs-built_in">string</span>）:<span class="hljs-built_in">boolean</span><br>&#125;    <br><br><span class="hljs-keyword">let</span> mySearch:SearchFunc;<br>mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">source: <span class="hljs-built_in">string</span>,subString:<span class="hljs-built_in">string</span></span>)</span>&#123;<br>     <span class="hljs-keyword">return</span> source.search(subString) !== <span class="hljs-number">-1</span>  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName?: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (lastName) &#123;<br>        <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> firstName;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> tomcat = buildName(<span class="hljs-string">&#x27;dada&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">let</span> tom = buildName(<span class="hljs-string">&#x27;dada&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>参数默认值</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span>(<span class="hljs-params">firstName:<span class="hljs-built_in">string</span>,lastName:<span class="hljs-built_in">string</span>=&#x27;Cat&#x27;</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>&#125;<br><span class="hljs-keyword">let</span> tomcat = buildName(<span class="hljs-string">&#x27;dada&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">let</span> tom = buildName(<span class="hljs-string">&#x27;dada&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>剩余参数</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 可以使用 ...rest 的方式获取函数中的剩余参数</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">array,...items</span>)</span>&#123;<br>     items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>&#123;<br>        array.push(item)<br>  &#125;)  <br>&#125;<br><br><span class="hljs-keyword">let</span> a = [];<br>push(a,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">array:<span class="hljs-built_in">any</span>[],...items:<span class="hljs-built_in">any</span>[]</span>)</span>&#123;<br>     items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>&#123;<br>         array.push(item);<br>    &#125;)  <br>&#125;<br><br><span class="hljs-keyword">let</span> a = []<br>push(a,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>

<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用重载定义多个 <code>reverse</code> 的函数类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> count : <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">interface</span> dada &#123;<br> uname: <span class="hljs-built_in">string</span>,<br> age: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">const</span> jeskson :dada = &#123;<br> uname: <span class="hljs-string">&#x27;jeskson&#x27;</span>,<br> age: <span class="hljs-number">12</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>对象类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> gege: &#123;<br> name: <span class="hljs-built_in">string</span>,<br> age: <span class="hljs-built_in">number</span><br>&#125; = &#123;<br> name: <span class="hljs-string">&#x27;jeskson&#x27;</span>,<br> age: <span class="hljs-number">12</span><br>&#125;<br><span class="hljs-keyword">const</span> person : <span class="hljs-built_in">string</span> [] = [<span class="hljs-string">&#x27;dada&#x27;</span>, <span class="hljs-string">&#x27;jeskson&#x27;</span>, <span class="hljs-string">&#x27;掘金魔王哪吒&#x27;</span>]<br><span class="hljs-keyword">class</span> Person&#123;&#125;<br><span class="hljs-keyword">const</span> dada : Person = <span class="hljs-keyword">new</span> Person()<br><br><span class="hljs-keyword">const</span> dada :<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">string</span> = <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;jeskson&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>

<p>静态类型：对象类型，数组类型，类类型，函数类型</p>
<h3 id="类型注解与类型推断"><a href="#类型注解与类型推断" class="headerlink" title="类型注解与类型推断"></a>类型注解与类型推断</h3><p>局部变量：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> count : <span class="hljs-built_in">number</span>;<br>count=<span class="hljs-number">12</span>;<br></code></pre></td></tr></table></figure>

<p>如果ts能够自动分析判断变量类型，就不需要，否则就需要使用类型注解。</p>
<blockquote>
<p>函数参数和函数的返回类型的注解</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNum</span>(<span class="hljs-params">a : <span class="hljs-built_in">number</span>, two : <span class="hljs-built_in">number</span></span>) : <span class="hljs-title">number</span> </span>&#123;<br> <span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-keyword">const</span> total = getNum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>never</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs tsx">function errorFunction() : never &#123;<br> throw new Error()<br> console.log(&#39;hello world&#39;)<br>&#125;<br><br>function forNever() : never &#123;<br> while(true) &#123;&#125;<br> console.log(&#39;hello world&#39;)<br>&#125;<br><br>function add(&#123;one,two&#125; : &#123;one : number,two : number&#125;) &#123;<br> return one + two<br>&#125;<br>const total &#x3D; add(&#123;one:1,two:2&#125;)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>数组类型注解</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> numberArr : <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><br><span class="hljs-keyword">const</span> stringArr : <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]<br><br><span class="hljs-keyword">const</span> undefinedArr : <span class="hljs-literal">undefined</span>[] = [<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>]<br><br><span class="hljs-keyword">const</span> arr : (<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>)[] = [<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;string&#x27;</span>,<span class="hljs-number">2</span>]<br><br><span class="hljs-keyword">const</span> dada : &#123;name:<span class="hljs-built_in">string</span>,age:<span class="hljs-built_in">number</span>&#125;[] = [<br> &#123;name:<span class="hljs-string">&#x27;jeskson&#x27;</span>,age:<span class="hljs-number">12</span>&#125;,<br> &#123;name:<span class="hljs-string">&#x27;魔王哪吒&#x27;</span>,age:<span class="hljs-number">12</span>&#125;,<br>]<br><br><span class="hljs-comment">// 类别别名</span><br><span class="hljs-comment">// type alias</span><br><span class="hljs-keyword">type</span> typeMy = &#123;name:<span class="hljs-built_in">string</span>,age:<span class="hljs-built_in">number</span>&#125;<br><br><span class="hljs-keyword">const</span> dada : typeMy[] = [&#123;name:<span class="hljs-string">&#x27;jeskson&#x27;</span>,age:<span class="hljs-number">12</span>&#125;]<br></code></pre></td></tr></table></figure>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>加强版：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> dada : (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[] = [<span class="hljs-string">&#x27;魔王哪吒&#x27;</span>,<span class="hljs-string">&#x27;jeskson&#x27;</span>,<span class="hljs-number">12</span>]<br><br><span class="hljs-comment">// 不常用-元组</span><br><span class="hljs-keyword">const</span> dada1 : [<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>,<span class="hljs-built_in">number</span>] = [<span class="hljs-string">&quot;jeskson&quot;</span>,<span class="hljs-number">12</span>,<span class="hljs-string">&quot;dadaqianduan&quot;</span>]<br></code></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> dada &#123;<br> name: <span class="hljs-string">&#x27;jeskson&#x27;</span>;<br> age: <span class="hljs-number">12</span>;<br> work ?: <span class="hljs-built_in">string</span>;<br> say():<span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> obj <span class="hljs-keyword">implements</span> dada &#123;<br> name=<span class="hljs-string">&quot;dada&quot;</span><br> age=<span class="hljs-number">12</span><br> work=<span class="hljs-string">&quot;it&quot;</span><br> say()&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;dadaqianduan&quot;</span><br> &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> selected = <span class="hljs-function">(<span class="hljs-params">person: dada</span>)=&gt;</span>&#123;<br>&#125;<br><br><span class="hljs-comment">// obj.name &amp;&amp; console.log(obj.name)</span><br></code></pre></td></tr></table></figure>

<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> Da &#123;<br> content = <span class="hljs-string">&quot;掘金魔王哪吒&quot;</span><br> sayHello() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.content<br> &#125;<br>&#125;<br><br>consot da = <span class="hljs-keyword">new</span> Da()<br><span class="hljs-built_in">console</span>.log(da.sayHello())<br><span class="hljs-keyword">class</span> Person &#123;<br> name: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person()<br>person.name = <span class="hljs-string">&quot;jeskson&quot;</span><br><span class="hljs-built_in">console</span>.log(person.name)<br></code></pre></td></tr></table></figure>

<p>类的构造函数</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> Person &#123;<br> <span class="hljs-keyword">public</span> name : <span class="hljs-built_in">string</span>;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span></span>)&#123;<br>  <span class="hljs-built_in">this</span>.name = name<br> &#125;<br>&#125;<br><br><span class="hljs-comment">// 优化</span><br><span class="hljs-keyword">class</span> Person &#123;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name:<span class="hljs-built_in">string</span></span>)&#123;&#125;<br>&#125;<br><span class="hljs-keyword">class</span> Teacher <span class="hljs-keyword">extends</span> Person&#123;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> age:<span class="hljs-built_in">number</span></span>)&#123;<br>  <span class="hljs-built_in">super</span>(<span class="hljs-string">&#x27;jeskson&#x27;</span>)<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;jeskson&#x27;</span>)<br><br><span class="hljs-keyword">const</span> dada = <span class="hljs-keyword">new</span> Teacher(<span class="hljs-number">12</span>)<br><span class="hljs-built_in">console</span>.log(dada.age)<br><span class="hljs-built_in">console</span>.log(person.name)<br></code></pre></td></tr></table></figure>

<h3 id="Getter-Setter-static"><a href="#Getter-Setter-static" class="headerlink" title="Getter,Setter,static"></a>Getter,Setter,static</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> Da &#123;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> _age:<span class="hljs-built_in">number</span></span>)&#123;&#125;<br> get age() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._age<br> &#125;<br> set age(age:<span class="hljs-built_in">number</span>) &#123;<br>  <span class="hljs-built_in">this</span>._age = age<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> dada = <span class="hljs-keyword">new</span> Da(<span class="hljs-number">12</span>)<br><span class="hljs-keyword">class</span> Da&#123;<br> <span class="hljs-keyword">static</span> sayHello() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;魔王哪吒&quot;</span><br> &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(Da.sayHello())<br></code></pre></td></tr></table></figure>

<p>只读属性：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> Person&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> _name:<span class="hljs-built_in">string</span><br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-built_in">this</span>._name = name<br> &#125;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;jeskson&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(person.name);<br></code></pre></td></tr></table></figure>

<p>抽象类，使用继承抽象类：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> Da &#123;<br> <span class="hljs-keyword">abstract</span> say()<br>&#125;<br><span class="hljs-keyword">class</span> da <span class="hljs-keyword">extends</span> Da &#123;<br> say() &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;jeskson&#x27;</span>)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>tsc -init</code>生成<code>tsconfig.json</code>文件：</p>
<p><code>compilerOptions</code>配置项</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-string">&quot;files&quot;</span>: []<br><br>removeComments 为 <span class="hljs-literal">true</span>，去掉注释<br>strict为<span class="hljs-literal">true</span>，书写规范<br><br><span class="hljs-comment">// 允许你的注解类型any不用特意标明</span><br><span class="hljs-string">&quot;noImplicitAny&quot;</span>: <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// 不允许有null值出现</span><br><span class="hljs-string">&quot;strictNullChecks&quot;</span>: <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// 入口文件</span><br><span class="hljs-string">&quot;rootDir&quot;</span>: <span class="hljs-string">&quot;./src&quot;</span><br><span class="hljs-comment">// 编译好的文件</span><br><span class="hljs-string">&quot;outDir&quot;</span>: <span class="hljs-string">&quot;./build&quot;</span><br><br><span class="hljs-comment">// Generates corresponding &#x27;.map&#x27; file</span><br><span class="hljs-comment">// 信息文件，存储位置信息</span><br><span class="hljs-string">&quot;sourceMap&quot;</span>: <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// Report errors on unused locals</span><br><span class="hljs-string">&quot;noUnusedLocals&quot;</span>: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<h3 id="联合类型和类型保护"><a href="#联合类型和类型保护" class="headerlink" title="联合类型和类型保护"></a>联合类型和类型保护</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Teacher&#123;<br> teacher: <span class="hljs-built_in">boolean</span>;<br> say:<span class="hljs-function">()=&gt;</span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">interface</span> Student&#123;<br> teacher: <span class="hljs-built_in">boolean</span>;<br> say:<span class="hljs-function">()=&gt;</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">//联合类型，类型保护，类型断言</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">da</span>(<span class="hljs-params">study: Teacher | Student</span>) </span>&#123;<br> <span class="hljs-keyword">if</span>(study.teacher) &#123;<br>  (study <span class="hljs-keyword">as</span> Teacher).say();<br> &#125;<span class="hljs-keyword">else</span>&#123;<br>  (study <span class="hljs-keyword">as</span> Student).say();<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">params: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>)</span>&#123;<br> <span class="hljs-keyword">return</span> params;<br>&#125;<br>fn&lt;<span class="hljs-built_in">string</span>&gt;([<span class="hljs-string">&quot;12&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>]);<br></code></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> Select &#123;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> da: <span class="hljs-built_in">string</span>[]</span>) &#123;&#125;<br> getDa(index:<span class="hljs-built_in">number</span>):<span class="hljs-built_in">string</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.da[index];<br> &#125;<br>&#125;<br><span class="hljs-keyword">const</span> dada = <span class="hljs-keyword">new</span> Select([<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>]);<br>onsole.log(dada.getDa(<span class="hljs-number">1</span>));<br><span class="hljs-keyword">class</span> Select&lt;T&gt; &#123;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> da: T[]</span>)&#123;&#125;<br> getDa(index: <span class="hljs-built_in">number</span>): T&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.da[index];<br> &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> Girl &#123;<br> name: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">class</span> SelectGirl&lt;T <span class="hljs-keyword">extends</span> Girl&gt; &#123;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> girls: T[]</span>) &#123;&#125;<br> getGirl(index: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.girls[index].name;<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> SelectGirl&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&gt; &#123;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> girls: T[]</span>) &#123;&#125;<br> getGirl(index: <span class="hljs-built_in">number</span>): T &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.girls[index];<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="NameSpace"><a href="#NameSpace" class="headerlink" title="NameSpace"></a>NameSpace</h3><p><code>npm init -y</code>生成<code>package.json</code>文件</p>
<p><code>tsc -init</code>生成<code>tsconfig.json</code>文件</p>
<blockquote>
<p>安装VsCode编辑器：</p>
</blockquote>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">image.png</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Person &#123;<br> name: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">const</span> teacher: Person = &#123;<br> name: <span class="hljs-string">&#x27;jeskson&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>基础类型和对象类型</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 基础类型 null, undefined, symbol, boolean, void</span><br><span class="hljs-keyword">const</span> count:<span class="hljs-built_in">number</span> = <span class="hljs-number">12</span>;<br><span class="hljs-keyword">const</span> name:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;掘金魔王哪吒&#x27;</span>;<br><br><span class="hljs-comment">// 对象类型</span><br><span class="hljs-keyword">const</span> teacher: &#123;<br> name: <span class="hljs-built_in">string</span>;<br> age: <span class="hljs-built_in">number</span>;<br>&#125; = &#123;<br> name: <span class="hljs-string">&#x27;jeskson&#x27;</span>,<br> age: <span class="hljs-number">12</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> nums:<span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><br><span class="hljs-keyword">const</span> goTotal: <span class="hljs-function">()=&gt;</span><span class="hljs-built_in">number</span> = <span class="hljs-function">() =&gt;</span> &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>类型注解和类型推断</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// type annotation 类型注解</span><br><br><span class="hljs-keyword">let</span> count:<span class="hljs-built_in">number</span>;<br>count=<span class="hljs-number">123</span>;<br><br><span class="hljs-comment">// type inference 类型推断，TS会自动的尝试分析变量的类型</span><br><span class="hljs-comment">// 推动不出来，就自己加</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTotal</span>(<span class="hljs-params">firstNumber:<span class="hljs-built_in">number</span>, secondNumber:<span class="hljs-built_in">number</span></span>) </span>&#123;<br> <span class="hljs-keyword">return</span> firstNumber + secondNumber;<br>&#125;<br><span class="hljs-keyword">const</span> total = getTotal(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>函数相关类型t</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 实战</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTotal</span>(<span class="hljs-params">firstNumber:<span class="hljs-built_in">number</span>, secondNumber:<span class="hljs-built_in">number</span></span>):<span class="hljs-title">number</span> </span>&#123;<br> <span class="hljs-keyword">return</span> firstNumber + secondNumber;<br>&#125;<br><span class="hljs-keyword">const</span> total = getTotal(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// void这个函数不应该有返回值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// never 表示这个函数永远不能执行完成</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errorEmitter</span>(<span class="hljs-params"></span>): <span class="hljs-title">never</span> </span>&#123;<br> <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;&#125; <span class="hljs-comment">// 或抛出异常</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">&#123;first,second&#125;:&#123;first:<span class="hljs-built_in">number</span>;second:<span class="hljs-built_in">number</span>&#125;</span>):<span class="hljs-title">number</span></span>&#123;<br> <span class="hljs-keyword">return</span> first+second;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNumber</span>(<span class="hljs-params">&#123;first&#125;:&#123;first:<span class="hljs-built_in">number</span>&#125;</span>)</span>&#123;<br> <span class="hljs-keyword">return</span> first;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>小结：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 基础类型 boolean,number,string,void,undefined,symbol,null</span><br><br><span class="hljs-keyword">let</span> count: <span class="hljs-built_in">number</span>;<br>count = <span class="hljs-number">12</span>;<br><br><span class="hljs-comment">// 对象类型 &#123;&#125;,Class,function,[]</span><br><span class="hljs-keyword">const</span> fun = <span class="hljs-function">(<span class="hljs-params">str:<span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(str,<span class="hljs-number">10</span>);<br>&#125;<br><span class="hljs-keyword">const</span> fun1: <span class="hljs-function">(<span class="hljs-params">str:<span class="hljs-built_in">string</span></span>)=&gt;</span><span class="hljs-built_in">number</span> = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(str,<span class="hljs-number">10</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br></code></pre></td></tr></table></figure>

<blockquote>
<p>数组和元组</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr: (<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>)[] = [<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> stringArr: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-keyword">const</span> undefinedArr:<span class="hljs-literal">undefined</span>[] = [<span class="hljs-literal">undefined</span>];<br><br><span class="hljs-keyword">const</span> objectArr: &#123;name:<span class="hljs-built_in">string</span>,age:<span class="hljs-built_in">number</span>&#125;[] = [&#123;<br> name: <span class="hljs-string">&#x27;掘金魔王哪吒&#x27;</span>,<br> age: <span class="hljs-number">12</span><br>&#125;]<br><br><span class="hljs-comment">// type alias 类型别名</span><br><span class="hljs-keyword">type</span> User = &#123;name:<span class="hljs-built_in">string</span>;age:<span class="hljs-built_in">number</span>&#125;;<br><span class="hljs-keyword">const</span> objectArr: User[] = [&#123;<br> name: <span class="hljs-string">&#x27;掘金魔王哪吒&#x27;</span>,<br> age: <span class="hljs-number">12</span><br>&#125;]<br><br><span class="hljs-keyword">class</span> Teacher &#123;<br> name: <span class="hljs-built_in">string</span>;<br> age: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">const</span> objectArr: Teacher[] = [<br> <span class="hljs-keyword">new</span> Teacher();<br> &#123;<br>  name: <span class="hljs-string">&#x27;jeskson&#x27;</span>,<br>  age: <span class="hljs-number">12</span><br> &#125;<br>];<br></code></pre></td></tr></table></figure>

<p>元组</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> teacherInfo: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">&#x27;dadaqianduan&#x27;</span>,<span class="hljs-string">&#x27;1024bibi.com&#x27;</span>,<span class="hljs-number">12</span>];<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Interface接口</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Person &#123;<br> <span class="hljs-comment">// readonly name: string;</span><br> name: <span class="hljs-built_in">string</span>;<br> age?: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">const</span> getPersonName = (person: Person): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br> <span class="hljs-built_in">console</span>.log(person.name);<br>&#125;;<br><span class="hljs-keyword">const</span> setPersonName = (person: Person, name: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">void</span>=&gt;</span>&#123;<br> persono.name = name;<br>&#125;;<br><span class="hljs-keyword">const</span> person = &#123;<br> name: <span class="hljs-string">&#x27;掘金魔王哪吒&#x27;</span>,<br> age: <span class="hljs-number">12</span><br>&#125;;<br>getPersonName(person);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>类的定义与继承</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> Person &#123;<br> name=<span class="hljs-string">&#x27;掘金魔王哪吒&#x27;</span>;<br> getName() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br> &#125;<br>&#125;<br><span class="hljs-keyword">class</span> Teacher textends Person &#123;<br> getTeacherName() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;teacher&#x27;</span>;<br> &#125;<br> getName() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;1024bibi.com&#x27;</span> + <span class="hljs-built_in">super</span>.getName()<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> teacher = <span class="hljs-keyword">new</span> Teacher();<br><span class="hljs-comment">// 重写，字类可以重写父类的东西</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>类中的访问类型和构造器</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// private protected public </span><br><span class="hljs-keyword">class</span> Person &#123;<br> <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>;<br> sayHi() &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1024bibi.com&#x27;</span>)<br> &#125;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person();<br>person.name = <span class="hljs-string">&#x27;掘金魔王哪吒&#x27;</span><br><span class="hljs-built_in">console</span>.log(person.name);<br><br><span class="hljs-comment">// public 允许我在类的内外被调用</span><br><span class="hljs-comment">// private 允许在类内被使用</span><br><span class="hljs-comment">// protected 允许在类内以及继承的子类中是使用</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>constructor</code></li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> Person &#123;<br> <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;dadaqianduan&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(person.name);<br><span class="hljs-comment">// 简化写法</span><br><span class="hljs-keyword">class</span> Person &#123;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) &#123;&#125;<br>&#125;<br><span class="hljs-keyword">class</span> Teacher <span class="hljs-keyword">extends</span> Person &#123;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> age:<span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-built_in">super</span>(<span class="hljs-string">&#x27;dadaqianduan&#x27;</span>);<br> &#125;<br>&#125;<br><br><span class="hljs-comment">// 如果父类没有构造器，也使用空的 super()</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>静态属性，Setter和Getter</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> Person &#123;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span></span>) &#123;&#125;<br> get getName() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;dadaqianduan&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(person.getName);<br><span class="hljs-keyword">class</span> Person &#123;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> _name: <span class="hljs-built_in">string</span></span>) &#123;&#125;<br> get name() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._name;<br> &#125;<br> set name(name: <span class="hljs-built_in">string</span>) &#123;<br>  <span class="hljs-built_in">this</span>._name = name;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>设计模式：单例模式，一个类只允许通过这个类，获取一个单例实例</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> Demo &#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> instance: Demo;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name:<span class="hljs-built_in">string</span></span>) &#123;&#125;<br> <br> <span class="hljs-keyword">static</span> getInstance(name: <span class="hljs-built_in">string</span>) &#123;<br>  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.instance) &#123;<br>   <span class="hljs-built_in">this</span>.instance = <span class="hljs-keyword">new</span> Demo(<span class="hljs-string">&#x27;1024bibi.com&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.instance;<br> &#125;<br>&#125;<br><br><span class="hljs-comment">//const demo1 = new Demo();</span><br><span class="hljs-comment">//const demo2 = new Demo();</span><br><br><span class="hljs-keyword">const</span> demo1 = Demo.getInstance();<br></code></pre></td></tr></table></figure>

<blockquote>
<p>抽象类</p>
</blockquote>
<p>抽象类只能被继承，不能被实例化</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> Da &#123;<br> width: <span class="hljs-built_in">number</span>;<br> getType() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;dadaqianduan&#x27;</span>;<br> &#125;<br> <span class="hljs-keyword">abstract</span> getAra(): <span class="hljs-built_in">number</span>;<br>&#125;<br>npm init -y<br></code></pre></td></tr></table></figure>

<p>生成<code>package.json</code>文件：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">&#123;<br> <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;TypeScript&quot;</span>,<br> <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br> <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br> <span class="hljs-string">&quot;main&quot;</span>: <span class="hljs-string">&quot;index.js&quot;</span>,<br> <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;test: &quot;</span>echo \<span class="hljs-string">&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br> &#125;,<br> <span class="hljs-string">&quot;keywords&quot;</span>: [],<br> <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br> <span class="hljs-string">&quot;license&quot;</span>: <span class="hljs-string">&quot;ISC&quot;</span><br>&#125;<br>tsc --init<br><span class="hljs-comment">// Successfully created a tsconfig.json file</span><br><br><span class="hljs-comment">// npm uninstall ts-node -g</span><br>npm install -D ts-node<br>npm install typescript -D<br></code></pre></td></tr></table></figure>

<h3 id="TypeScript中的配置文件"><a href="#TypeScript中的配置文件" class="headerlink" title="TypeScript中的配置文件"></a>TypeScript中的配置文件</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 编译配置文件</span><br><span class="hljs-comment">// tsconfig.json</span><br>要编译的文件<br><span class="hljs-string">&quot;include&quot;</span> [<span class="hljs-string">&quot;./demo.ts&quot;</span>],<br></code></pre></td></tr></table></figure>

<h3 id="联合类型和类型保护-1"><a href="#联合类型和类型保护-1" class="headerlink" title="联合类型和类型保护"></a>联合类型和类型保护</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Bird &#123;<br> fly: <span class="hljs-built_in">boolean</span>;<br> sing: <span class="hljs-function">()=&gt;</span>&#123;&#125;;<br>&#125;<br><span class="hljs-keyword">interface</span> Dog &#123;<br> fly: <span class="hljs-built_in">boolean</span>;<br> bark: <span class="hljs-function">()=&gt;</span>&#123;&#125;;<br>&#125;<br><span class="hljs-comment">// 类型断言的方式</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trainAnial</span>(<span class="hljs-params">animal: Bird | Dog</span>) </span>&#123;<br> <span class="hljs-keyword">if</span>(animal.fly) &#123;<br>  (animal <span class="hljs-keyword">as</span> Bird).sing();<br> &#125; <span class="hljs-keyword">else</span> &#123;<br>  (animal <span class="hljs-keyword">as</span> Dog).bark();<br> &#125;<br>&#125;<br><br><span class="hljs-comment">// in 语法来做类型保护</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trainAnialSecond</span>(<span class="hljs-params">animal: Bird | Dog</span>) </span>&#123;<br> <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;sing&#x27;</span> <span class="hljs-keyword">in</span> animal) &#123;<br>  animal.sing();<br> &#125; <span class="hljs-keyword">else</span> &#123;<br>  animal.bark();<br> &#125;<br>&#125;<br><span class="hljs-comment">// typeof 语法来做类型保护</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">first: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, second: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) </span>&#123;<br> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> first === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> second === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;first&#125;</span><span class="hljs-subst">$&#123;second&#125;</span>`</span>;<br> &#125;<br> <span class="hljs-keyword">return</span> first + second;<br>&#125;<br><br><span class="hljs-comment">// 使用instanceof语法来做类型保护</span><br><span class="hljs-keyword">class</span> NumberObj &#123;<br> count: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSecond</span>(<span class="hljs-params">first: <span class="hljs-built_in">object</span> | NumberObj, second: <span class="hljs-built_in">object</span> | NumberObj</span>) </span>&#123;<br> <span class="hljs-keyword">if</span>(first <span class="hljs-keyword">instanceof</span> NumberObj &amp;&amp; second <span class="hljs-keyword">instanceof</span> NumberObj) &#123;<br>  <span class="hljs-keyword">return</span> first.count + second.count;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Enum枚举类型"><a href="#Enum枚举类型" class="headerlink" title="Enum枚举类型"></a>Enum枚举类型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> Status = &#123;<br> OFFLINE: <span class="hljs-number">0</span>,<br> ONLINE: <span class="hljs-number">1</span>,<br> DELETED: <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getResult</span>(<span class="hljs-params">status</span>) </span>&#123;<br> <span class="hljs-keyword">if</span>(status === Status.OFFLINE)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;offline&#x27;</span>;<br> &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(status === Status.ONLINE) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;online&#x27;</span>;<br> &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(status === Status.DELETED) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;deleted&#x27;</span>;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;error&#x27;</span>;<br>&#125;<br><span class="hljs-built_in">enum</span> Status &#123;<br> OFFLINE,<br> ONLINE,<br> DELETED2<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getResult</span>(<span class="hljs-params">status</span>) </span>&#123;<br> <span class="hljs-keyword">if</span>(status === Status.OFFLINE)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;offline&#x27;</span>;<br> &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(status === Status.ONLINE) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;online&#x27;</span>;<br> &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(status === Status.DELETED) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;deleted&#x27;</span>;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;error&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="函数泛型"><a href="#函数泛型" class="headerlink" title="函数泛型"></a>函数泛型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 泛型generic泛指的 类型</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">join</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">P</span>&gt;(<span class="hljs-params">first: T, second: P</span>) </span>&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;first&#125;</span><span class="hljs-subst">$&#123;second&#125;</span>`</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anotherJoin</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">first: T,second: T</span>): <span class="hljs-title">T</span> </span>&#123;<br> <span class="hljs-keyword">return</span> first;<br>&#125;<br><br><span class="hljs-comment">// T[]</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">params: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) </span>&#123;<br> <span class="hljs-keyword">return</span> params;<br>&#125;<br><span class="hljs-comment">// join&lt;number,string&gt;(1,&#x27;1&#x27;);</span><br><span class="hljs-comment">// map&lt;string&gt;([&#x27;123&#x27;]);</span><br>join(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="类中如何使用泛型"><a href="#类中如何使用泛型" class="headerlink" title="类中如何使用泛型"></a>类中如何使用泛型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Item &#123;<br> name: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">class</span> DataManager&lt;T <span class="hljs-keyword">extends</span> Item&gt; &#123;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> data: T[]</span>) &#123;&#125;<br> getItem(index: <span class="hljs-built_in">number</span>):<span class="hljs-built_in">string</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.data[index].name;<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> DataManager(&#123;<br> &#123;<br>  name: <span class="hljs-string">&#x27;jeskson&#x27;</span><br> &#125;<br>]&#125;;<br><br><span class="hljs-comment">// 用泛型可以声明一些类型：</span><br><span class="hljs-comment">// 如何使用泛型作为一个具体的类型注解</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">params: T</span>) </span>&#123;<br> <span class="hljs-keyword">return</span> params;<br>&#125;<br><span class="hljs-keyword">const</span> func: &lt;T&gt;<span class="hljs-function">(<span class="hljs-params">param: T</span>) =&gt;</span> T = hello;<br></code></pre></td></tr></table></figure>

<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs tsx">&quot;use strict&quot;<br>var Header &#x3D; (function() &#123;<br> function Header() &#123;<br>  var elem &#x3D; document.createElement(&#39;div&#39;);<br>  elem.innerText &#x3D; &#39;This is Header&#39;;<br>  document.body.appendChild(elem);<br> &#125;<br> return Header;<br>&#125;());<br><br>var Content &#x3D; (function()&#x3D;&gt;&#123;<br> function Content() &#123;<br>  var elem &#x3D; document.createElement(&#39;div&#39;);<br>  elem.innerText &#x3D; &#39;This is Content&#39;;<br>  document.body.appendChild(elem);<br> &#125;<br> return Content<br>&#125;());<br></code></pre></td></tr></table></figure>

<h3 id="使用Parcel打包TS代码"><a href="#使用Parcel打包TS代码" class="headerlink" title="使用Parcel打包TS代码"></a>使用Parcel打包TS代码</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">yarn add --dev parcel<span class="hljs-meta">@next</span><br></code></pre></td></tr></table></figure>

<h3 id="泛型中keyof语法的使用"><a href="#泛型中keyof语法的使用" class="headerlink" title="泛型中keyof语法的使用"></a>泛型中keyof语法的使用</h3><blockquote>
<p>某一数据类型的key的数组集合，既适用于数组，也适用于对象</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> testInter &#123;<br>    name: <span class="hljs-built_in">string</span>,<br>    age: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">let</span> testArr: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&#x27;dada&#x27;</span>, <span class="hljs-string">&#x27;dada1&#x27;</span>];<br><span class="hljs-keyword">let</span> testObj: testInter = &#123;name: <span class="hljs-string">&#x27;tate&#x27;</span>, age: <span class="hljs-number">26</span>&#125;<br><br><span class="hljs-comment">// 数组</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showKey</span>&lt;<span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>, <span class="hljs-title">T</span>&gt; (<span class="hljs-params">key: K, obj: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> key;<br>&#125;<br>showKey&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;(<span class="hljs-number">1</span>, testArr);<br><br><span class="hljs-comment">// 对象</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showKey</span>&lt;<span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>, <span class="hljs-title">T</span>&gt; (<span class="hljs-params">keyItem: K, obj: T</span>): <span class="hljs-title">K</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> keyItem;<br>&#125;<br><span class="hljs-keyword">let</span> val = showKey(<span class="hljs-string">&#x27;name&#x27;</span>, testObj)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showKey</span>&lt;<span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>, <span class="hljs-title">T</span>&gt; (<span class="hljs-params">items: K[], obj: T</span>): <span class="hljs-title">T</span>[<span class="hljs-title">K</span>][] </span>&#123;<br>    <span class="hljs-keyword">return</span> items.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> obj[item])<br>&#125;<br><span class="hljs-keyword">interface</span> Person &#123;<br> name: <span class="hljs-built_in">string</span>;<br> age: <span class="hljs-built_in">number</span>;<br> gender: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">class</span> Teacher &#123;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> info: Person</span>) &#123;&#125;<br> getInfo(key: <span class="hljs-built_in">string</span>) &#123;<br>  <span class="hljs-keyword">if</span>(key===<span class="hljs-string">&#x27;name&#x27;</span> || key===<span class="hljs-string">&#x27;age&#x27;</span> || key===<span class="hljs-string">&#x27;gender&#x27;</span>) &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.info[key];<br>  &#125;<br> &#125;<br>&#125;<br> <br><span class="hljs-keyword">const</span> teacher = <span class="hljs-keyword">new</span> Teacher(&#123;<br> name: <span class="hljs-string">&#x27;jeskson&#x27;</span>,<br> age: <span class="hljs-number">12</span>,<br> gender: <span class="hljs-string">&#x27;male&#x27;</span><br>&#125;);<br><span class="hljs-keyword">const</span> test = teacher.genInfo(<span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-keyword">class</span> Teacher &#123;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> info: Person</span>) &#123;&#125;<br> <span class="hljs-comment">// getInfo&lt;T extends keyof Person&gt;(key:string) &#123;</span><br> getInfo&lt;T <span class="hljs-keyword">extends</span> keyof Person&gt;(key: T):Person[T]&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.info[key];<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 类的装饰器</span><br><span class="hljs-comment">// 装饰器本身是一个函数</span><br><span class="hljs-comment">// 装饰器通过@符号来使用</span><br><span class="hljs-comment">// 普通方法，target对应的是类的prototype</span><br><span class="hljs-comment">// 静态方法，target对应的是类的构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNameDecorator</span>(<span class="hljs-params">target:<span class="hljs-built_in">any</span>,key:<span class="hljs-built_in">string</span></span>)</span>&#123;<br> <span class="hljs-built_in">console</span>.log(target,key);<br>&#125;<br><span class="hljs-keyword">class</span> Test &#123;<br> name: <span class="hljs-built_in">string</span>;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br> &#125;<br> <span class="hljs-meta">@getNameDecorator</span><br> <span class="hljs-keyword">static</span> getName() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;123&#x27;</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="接口Interface"><a href="#接口Interface" class="headerlink" title="接口Interface"></a>接口Interface</h3><p>有时候我们传入的参数可能会包含很多的属性，但编译器只会检查那些必须的属性是否存在，以及类型是否匹配，而接口就是用来描述这样的结构。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">config: &#123;name:<span class="hljs-built_in">string</span>,age:<span class="hljs-built_in">number</span>&#125;</span>) </span>&#123;<br> <span class="hljs-built_in">console</span>.log(config.name+config.age);<br>&#125;<br><span class="hljs-built_in">console</span>.log(Person(&#123;name:<span class="hljs-string">&#x27;魔王哪吒&#x27;</span>,age:<span class="hljs-number">12</span>&#125;));<br><span class="hljs-comment">// 重构</span><br><span class="hljs-keyword">interface</span> Config &#123;<br> name: <span class="hljs-built_in">string</span>;<br> age: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">config: Config</span>) </span>&#123;<br> <span class="hljs-built_in">console</span>.log(config.name+config.age);<br>&#125;<br><span class="hljs-comment">// 接口类型检查会检测属性有没有在Config接口中而进行限制</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>可选属性</p>
</blockquote>
<p>接口中的属性有时候是不必须的，有的用得到，有的用不到的情况下，是可选属性，这样对可能存在的属性进行预先定义。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Config &#123;<br> name: <span class="hljs-built_in">string</span>;<br> age?: <span class="hljs-built_in">number</span>;<br> <span class="hljs-comment">// [propName: string]: any 转字符串索引签名</span><br>&#125;<br><span class="hljs-comment">// [propName: string]: any</span><br><span class="hljs-comment">// 这个索引签名是为了你能够预见某个对象可能有某些特殊的用途而准备的</span><br><span class="hljs-comment">// 属性名写错，可以通过索引签名的方式进行屏蔽错误</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>只读属性</p>
</blockquote>
<p>对于一些对象属性只能在对象刚刚创建的时候修改其值，在属性前用readonly来指定只读属性：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Point &#123;<br>  <span class="hljs-keyword">readonly</span> x: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">readonly</span> y: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">let</span> p:Point = &#123; x: <span class="hljs-number">12</span>, y: <span class="hljs-number">14</span> &#125;<br>p.x = <span class="hljs-number">15</span> <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>函数类型</p>
</blockquote>
<p>接口能够描述JavaScript中对象拥有的各种各样的外形</p>
<p>函数类型接口：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Fun &#123;<br> (source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Boolean</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>接口继承</p>
</blockquote>
<p>接口是可以相互继承的，能够从一个接口里复制成员到另一个接口里。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Animal &#123;<br> name: <span class="hljs-built_in">string</span>;<br> say(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> Person <span class="hljs-keyword">extends</span> Animal &#123;<br> work(): <span class="hljs-built_in">void</span>;<br> closer: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">class</span> Pro <span class="hljs-keyword">implements</span> Person &#123;<br> closer: <span class="hljs-built_in">string</span>;<br> name: <span class="hljs-built_in">string</span>;<br> say(): <span class="hljs-built_in">void</span> &#123;<br> <br> &#125;<br> work(): <span class="hljs-built_in">void</span> &#123;<br> <br> &#125;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span>, closer:<span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.closer = closer;<br> &#125;<br>&#125;<br><span class="hljs-keyword">let</span> g:Person = <span class="hljs-keyword">new</span> Pro(<span class="hljs-string">&quot;jeskson&quot;</span>,<span class="hljs-string">&quot;it&quot;</span>);<br>g.say();<br>g.work();<br></code></pre></td></tr></table></figure>

<ul>
<li>对象类型接口</li>
<li>函数类型接口</li>
</ul>
<p>接口的定义方式：使用interface关键字</p>
<p>接口中可定义：</p>
<ul>
<li>确定属性</li>
<li>可选属性</li>
<li>任意属性</li>
<li>只读属性</li>
</ul>
<ol>
<li>确定属性</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> UserInfo &#123;<br> name: <span class="hljs-built_in">string</span>;<br> age: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> myInfo: UserInfo = &#123;<br> name: <span class="hljs-string">&#x27;魔王哪吒&#x27;</span>,<br> age: <span class="hljs-number">12</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>接口中约束好的确定属性，定义对象变量的时候，不能少，也不能多🙅‍</p>
</blockquote>
<ol>
<li>可选属性</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> UserInfo &#123;<br> name: <span class="hljs-built_in">string</span>;<br> age: <span class="hljs-built_in">number</span>;<br> sex?: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> myInfo: UserInfo = &#123;<br> name: <span class="hljs-string">&#x27;魔王哪吒&#x27;</span>,<br> age: <span class="hljs-number">12</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>接口中的可选属性，是表示在对象变量中可以不存在</p>
</blockquote>
<ol>
<li>任意属性</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> UserInfo &#123;<br> name: <span class="hljs-built_in">string</span>;<br> age: <span class="hljs-built_in">number</span>;<br> sex?: <span class="hljs-built_in">string</span>;<br> [proName: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> myInfo: UserInfo = &#123;<br>  name: <span class="hljs-string">&quot;dadaqianduan&quot;</span>,<br>  age: <span class="hljs-number">12</span>,<br>  test1: <span class="hljs-string">&#x27;123&#x27;</span>,<br>  test2: <span class="hljs-string">&#x27;abc&#x27;</span>,<br>  test3: <span class="hljs-number">123</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是任意属性类型的子类，定义了任意属性后，对象变量中的属性个数才可以出现比接口的属性数量多的情况。</p>
</blockquote>
<ol>
<li>只读属性</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> UserInfo &#123;<br>  <span class="hljs-keyword">readonly</span> id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>  sex?: <span class="hljs-built_in">string</span>;<br>  [propName: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;<br>&#125;<br><span class="hljs-keyword">const</span> myInfo: UserInfo = &#123;<br>  id: <span class="hljs-number">1</span>,<br>  name: <span class="hljs-string">&quot;dada&quot;</span>,<br>  age: <span class="hljs-number">12</span>,<br>  test1: <span class="hljs-string">&quot;123&quot;</span>,<br>  test2: <span class="hljs-string">&quot;abc&quot;</span>,<br>  test3: <span class="hljs-number">123</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>只读属性，也是确定属性，在对象变量定义的时候必须有值，后面不能修改</p>
</blockquote>
<ul>
<li>对象接口，以查询商品列表接口API示例：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ResponseData &#123;<br>    resCode: <span class="hljs-built_in">number</span>;<br>    resData: ResultData[];<br>    message: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> ResultData &#123;<br>    productId: <span class="hljs-built_in">number</span>;<br>    productName: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> resultData = &#123;<br>    resCode: <span class="hljs-number">0</span>,<br>    resData: [<br>        &#123; productId: <span class="hljs-number">1</span>, productName:<span class="hljs-string">&quot;TypeScipt实战&quot;</span> &#125;,<br>        &#123; productId: <span class="hljs-number">2</span>, productName:<span class="hljs-string">&quot;TypeScipt从入门到精通&quot;</span> &#125;,<br>    ],<br>    message: <span class="hljs-string">&quot;success&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">res: ResponseData</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(res.resCode, res.message)<br>    res.resData.forEach(<span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(obj.productId, obj.productName)<br>    &#125;)<br>&#125;<br><br>render(resultData);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>只要传入的对象满足接口的必要条件就可以被允许,即使传入多余的字段也可以通过类型检查</p>
</blockquote>
<ul>
<li>绕过检查的方法有3种:</li>
</ul>
<ol>
<li>将对象字面量赋值给一个变量</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> result = &#123;<br>    resCode: <span class="hljs-number">0</span>,<br>    resData: [<br>        &#123; productId: <span class="hljs-number">1</span>, productName:<span class="hljs-string">&quot;TypeScipt实战&quot;</span>, remark: <span class="hljs-string">&quot;备注&quot;</span>&#125;,<br>        &#123; productId: <span class="hljs-number">2</span>, productName:<span class="hljs-string">&quot;TypeScipt从入门到精通&quot;</span> &#125;,<br>    ],<br>    message: <span class="hljs-string">&quot;success&quot;</span><br>&#125;<br>render(result)<br></code></pre></td></tr></table></figure>

<ol>
<li>使用类型断言</li>
</ol>
<blockquote>
<p>使用类型断言方式,明确告诉编译器类型是什么,编译器就会绕过类型检查</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">render(&#123;<br>    resCode: <span class="hljs-number">0</span>,<br>    resData: [<br>        &#123; productId: <span class="hljs-number">1</span>, productName:<span class="hljs-string">&quot;TypeScipt实战&quot;</span>, remark:<span class="hljs-string">&quot;&quot;</span>&#125;,<br>        &#123; productId: <span class="hljs-number">2</span>, productName:<span class="hljs-string">&quot;TypeScipt从入门到精通&quot;</span> &#125;,<br>    ],<br>    message: <span class="hljs-string">&quot;success&quot;</span><br>&#125; <span class="hljs-keyword">as</span> ResponseData)<br><br>render(&lt;ResponseData&gt;&#123;<br>    resCode: <span class="hljs-number">0</span>,<br>    resData: [<br>        &#123; productId: <span class="hljs-number">1</span>, productName:<span class="hljs-string">&quot;TypeScipt实战&quot;</span>, remark: <span class="hljs-string">&quot;备注&quot;</span>&#125;,<br>        &#123; productId: <span class="hljs-number">2</span>, productName:<span class="hljs-string">&quot;TypeScipt从入门到精通&quot;</span> &#125;,<br>    ],<br>    message: <span class="hljs-string">&quot;success&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<ol>
<li>使用字符串索引签名</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ResultData &#123;<br>    productId: <span class="hljs-built_in">number</span>;<br>    productName: <span class="hljs-built_in">string</span>;<br>    [remark: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;  <span class="hljs-comment">// 字符串索引签名</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>函数接口</p>
</blockquote>
<ul>
<li>函数定义方式：</li>
</ul>
<ol>
<li>在TS中，使用一个变量直接定义函数</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> add: <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span><br>= (x, y)&#123;<br>  <span class="hljs-keyword">return</span> x+y;<br>&#125;;<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>

<ol>
<li>使用接口定义函数</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Add &#123;<br>    (x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">let</span> myFunc: Add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> x+y;<br>&#125;;<br>myFunc(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<ol>
<li>使用类型别名来定义函数</li>
</ol>
<p>类型别名使用type关键字</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Add = <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>可索引类型的接口</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 数字索引接口</span><br><span class="hljs-keyword">interface</span> numberIndex &#123;<br>    [x: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-comment">// 相当于声明了一个字符串类型的数组</span><br><span class="hljs-keyword">let</span> chars: numberIndex = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>]<br><span class="hljs-comment">// 声明一个字符串索引类型的接口</span><br><span class="hljs-keyword">interface</span> stringIndex &#123;<br>    [x: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-comment">// 两种索引签名混用</span><br><span class="hljs-keyword">interface</span> stringIndex &#123;<br>    [x: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span><br>    [z: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>    <span class="hljs-comment">// // Numeric index type &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> stringIndex &#123;<br>    [x: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span><br>    [z: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span> <span class="hljs-comment">// Numeric index type &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="上手TypeScipt"><a href="#上手TypeScipt" class="headerlink" title="上手TypeScipt"></a>上手TypeScipt</h3><p>对于npm的用户</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">npm install -g typescript<br></code></pre></td></tr></table></figure>

<p>构建第一个TypeScript文件，dada.ts 文件：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dada</span>(<span class="hljs-params">person</span>) </span>&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + person;<br>&#125;<br><span class="hljs-keyword">let</span> user = <span class="hljs-string">&quot;jeskson&quot;</span>;<br><span class="hljs-built_in">document</span>.body.innerHTML = dada(uer);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>编译代码</p>
</blockquote>
<p>在命令行上，运行TypeScript编译器：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">tsc dada.ts<br></code></pre></td></tr></table></figure>

<blockquote>
<p>添加类型注解<code>: string</code></p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dada</span>(<span class="hljs-params">person: <span class="hljs-built_in">string</span></span>) </span>&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;jeskson&quot;</span>+person;<br>&#125;<br><span class="hljs-keyword">let</span> user = <span class="hljs-string">&quot;jeskson&quot;</span>;<br><span class="hljs-built_in">document</span>.body.innerHTML = dada(user);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>类型注解</p>
</blockquote>
<p>TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式。</p>
<p>接口</p>
<p>允许我们在实现接口的时候只要保证包含了接口要求的结构就可以</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// implements语句</span><br><span class="hljs-keyword">interface</span> Person &#123;<br> firstName: <span class="hljs-built_in">string</span>;<br> lastName: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">peson: Person</span>) </span>&#123;<br> <span class="hljs-keyword">return</span> person.firstName + person.lastName;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = &#123; firstName: <span class="hljs-string">&quot;jeskson&quot;</span>, lastName: <span class="hljs-string">&quot;User&quot;</span> &#125;;<br><br><span class="hljs-built_in">document</span>.body.innerHTML = func(user);<br></code></pre></td></tr></table></figure>

<p>类，支持基于类的面向对象编程</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> Student &#123;<br> fullName: <span class="hljs-built_in">string</span>;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> firstName: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> lastName: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-built_in">this</span>.fullName = firstName + lastName;<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> Person &#123;<br> firstName: <span class="hljs-built_in">string</span>;<br> lastName: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dada</span>(<span class="hljs-params">person: Person</span>) </span>&#123;<br> <span class="hljs-keyword">return</span> person.firstName+person.lastName;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;jeskson&quot;</span>,<span class="hljs-string">&quot;魔王哪吒&quot;</span>);<br><span class="hljs-built_in">document</span>.body.innerHTML = dada(user);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>运行TypeScript Web应用</p>
</blockquote>
<p>在<code>index.html</code>里输入内容:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>    &lt;head&gt;&lt;title&gt;TypeScript dada&lt;<span class="hljs-regexp">/title&gt;&lt;/</span>head&gt;<br>    &lt;body&gt;<br>        &lt;script src=<span class="hljs-string">&quot;dada.js&quot;</span>&gt;&lt;/script&gt;<br>    &lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>在JS中,可以任意修改对象属性,TS中不允许</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 这是因为,仅声明了对象obj的类型注解是object</span><br><span class="hljs-keyword">let</span> obj: <span class="hljs-built_in">object</span> = &#123;x: <span class="hljs-string">&#x27;a&#x27;</span>, y: <span class="hljs-string">&#x27;b&#x27;</span>&#125;<br>obj.x = <span class="hljs-number">3</span>    <span class="hljs-comment">// Property &#x27;x&#x27; does not exist on type &#x27;object&#x27;.</span><br><span class="hljs-keyword">let</span> obj: &#123;x: <span class="hljs-built_in">string</span>, y: <span class="hljs-built_in">string</span>&#125; = &#123;x: <span class="hljs-string">&#x27;a&#x27;</span>, y: <span class="hljs-string">&#x27;b&#x27;</span>&#125;<br>obj.x = <span class="hljs-string">&#x27;c&#x27;</span><br></code></pre></td></tr></table></figure>

<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>具有唯一的值,可以显式声明,也可直接创建</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> symbol1: <span class="hljs-built_in">Symbol</span> = <span class="hljs-built_in">Symbol</span>()  <span class="hljs-comment">// 显示声明</span><br><span class="hljs-keyword">let</span> symbol2 = <span class="hljs-built_in">Symbol</span>()  <span class="hljs-comment">// 直接创建</span><br><br><span class="hljs-comment">// 验证:是否是同一个对象</span><br><span class="hljs-built_in">console</span>.log(symbol1 === symbol2)    <span class="hljs-comment">// fasle</span><br></code></pre></td></tr></table></figure>

<h3 id="undefined-和-null"><a href="#undefined-和-null" class="headerlink" title="undefined 和 null"></a>undefined 和 null</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 一旦声明了undefined,就不能再被赋值为任何其他的数据类型了</span><br><span class="hljs-keyword">let</span> udf: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span><br><span class="hljs-keyword">let</span> nu: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span><br><br><span class="hljs-keyword">let</span> undf: <span class="hljs-literal">undefined</span> = <span class="hljs-number">1</span> <br><span class="hljs-comment">// Type &#x27;1&#x27; is not assignable to type &#x27;undefined&#x27;.</span><br><br><span class="hljs-comment">// 默认情况下,undefined和null也不能被赋值给任何其他类型</span><br><br><span class="hljs-keyword">let</span> num1: <span class="hljs-built_in">number</span> = <span class="hljs-literal">undefined</span>    <br><span class="hljs-comment">// Type &#x27;undefined&#x27; is not assignable to type &#x27;number&#x27;.</span><br><br><span class="hljs-keyword">let</span> num2: <span class="hljs-built_in">number</span> = <span class="hljs-literal">null</span> <br><span class="hljs-comment">// Type &#x27;null&#x27; is not assignable to type &#x27;number&#x27;.</span><br></code></pre></td></tr></table></figure>

<ul>
<li>在TS中,<code>undefined和null</code>是任何类型的子类型,所以可以被赋值给其他类型</li>
<li>设置允许被赋值为其他类型</li>
</ul>
<blockquote>
<p>打开<code>tsconfig.js,将strictNullChecks = false(默认true)</code></p>
</blockquote>
<h3 id="void-any-never"><a href="#void-any-never" class="headerlink" title="void,any,never"></a><code>void,any,never</code></h3><ul>
<li>在<code>js</code>中,<code>void</code>操作符可以使任何一个表达式返回<code>undefined</code></li>
<li><code>void 0 // 将返回undefined</code></li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// void</span><br><span class="hljs-keyword">let</span> voidFunc = <span class="hljs-function">() =&gt;</span> &#123;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>any</code>:如果不指定<code>TS</code>的变量类型,默认为<code>any</code>类型,可以赋值为任何类型</li>
<li><code>never</code>:永远不会有返回值的类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 函数抛出异常,永远不会有返回值,类型为never</span><br><span class="hljs-keyword">let</span> error = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;error&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 死循环函数永远没有返回值,类型为never</span><br><span class="hljs-keyword">let</span> endless = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="对数组中的对象按对象的值进行去重"><a href="#对数组中的对象按对象的值进行去重" class="headerlink" title="对数组中的对象按对象的值进行去重"></a>对数组中的对象按对象的值进行去重</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> listData = [<br>  &#123; firstName: <span class="hljs-string">&quot;dada&quot;</span>, lastName: <span class="hljs-string">&quot;abc&quot;</span>, size: <span class="hljs-number">18</span> &#125;<br>&#125;<br><span class="hljs-comment">//js</span><br><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>listData = listData.reduce(<span class="hljs-function">(<span class="hljs-params">item, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!obj[next.lastName]) &#123;<br>    item.push(next);<br>    obj[next.lastName] = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> item;<br>&#125;, []);<br><span class="hljs-comment">//ts</span><br><span class="hljs-keyword">const</span> obj: &#123;[key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">boolean</span>;&#125; = &#123;&#125;;<br>listData = listData.reduce&lt;ListDataItem[]&gt;(<span class="hljs-function">(<span class="hljs-params">item, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!obj[next.lastName]) &#123;<br>    item.push(next);<br>    obj[next.lastName] = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> item;<br>&#125;,[]);<br></code></pre></td></tr></table></figure>

<h3 id="在微信小程序开发中使用Typescript"><a href="#在微信小程序开发中使用Typescript" class="headerlink" title="在微信小程序开发中使用Typescript"></a>在微信小程序开发中使用<code>Typescript</code></h3><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">image.png</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">image.png</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">image.png</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3aPj0GhFQDC6bQkW63sHHticGmYfWw117KQ67xjc6cNxaby0fKic4yFcbADXHpMu1RpWoCo8TSu6KCTVAgR6DZicw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">image.png</p>
<h3 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h3><p>“内部模块”现在称为“命令空间”，“外部模块”现在简称为“模块”，模块字其自身的作用域里执行，而不是在全局作用域里。</p>
<p>这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用export形式之一导出它们。</p>
<p>相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用 <code>import</code> 形式之一。</p>
<p>模块的概念：</p>
<p>我们可以把一些公共的功能单独抽离成一个文件作为一个模块，模块里面的变量，函数，类等默认是私有的，如果我们要在外部访问模块里面的数据，我们需要通过<code>export</code>暴露模块里面的数据。暴露后使用<code>import</code>引入模块就可以使用模块里面暴露的数据。</p>
<h3 id="命名空间-1"><a href="#命名空间-1" class="headerlink" title="命名空间"></a>命名空间</h3><p>命名空间和模块的区别</p>
<ul>
<li>命名空间：内部模块，主要用于组织代码，避免命名冲突</li>
<li>模块：ts的外部模块的简称</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">namespace</span> A &#123;<br><span class="hljs-keyword">interface</span> Animal &#123;<br> name: <span class="hljs-built_in">string</span>;<br> eat(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">class</span> Dog <span class="hljs-keyword">implements</span> Animal &#123;<br> name: <span class="hljs-built_in">string</span>;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-built_in">this</span>.name = theName;<br> &#125;<br> eat() &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;dog&#x27;</span>);<br> &#125;<br>&#125;<br><span class="hljs-keyword">class</span> Cat <span class="hljs-keyword">implements</span> Animal &#123;<br> name: <span class="hljs-built_in">string</span>;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-built_in">this</span>.name = theName;<br> &#125;<br> eat() &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;cat&#x27;</span>);<br> &#125;<br>&#125;<br><span class="hljs-keyword">let</span> dog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&#x27;dogdog&#x27;</span>);<br>dog.eat();<br>&#125;<br><span class="hljs-keyword">import</span> &#123;A,B&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./modules/animal&#x27;</span>;<br><br><span class="hljs-keyword">var</span> dog = <span class="hljs-keyword">new</span> A.Dog(<span class="hljs-string">&#x27;hei&#x27;</span>);<br>dog.eat();<br></code></pre></td></tr></table></figure>

<h3 id="装饰器-1"><a href="#装饰器-1" class="headerlink" title="装饰器"></a>装饰器</h3><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。</p>
<p>通俗的讲装饰器就是一个方法，可以注入到类，方法，属性参数上扩展类，属性，方法，参数的功能。</p>
<p>常见的装饰器有：<strong>类装饰器，属性装饰器，方法装饰器，参数装饰器</strong></p>
<p>装饰器的写法：</p>
<ul>
<li>普通装饰器（无法传参）</li>
<li>装饰器工厂（可传参）</li>
</ul>
<blockquote>
<p>方法参数装饰器：</p>
</blockquote>
<p>参数装饰器表达式会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元素数据，传入下列3个参数：    </p>
<ul>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>
<li>方法的名字</li>
<li>参数在函数参数列表中的索引</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logParams</span>(<span class="hljs-params">params:<span class="hljs-built_in">any</span></span>)</span>&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target:<span class="hljs-built_in">any</span>,methodName:<span class="hljs-built_in">any</span>,paramsIndex:<span class="hljs-built_in">any</span></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(params);<br>  <span class="hljs-built_in">console</span>.log(target);<br>  <span class="hljs-built_in">console</span>.log(methodName);<br>  <span class="hljs-built_in">console</span>.log(paramsIndex);<br> &#125;<br>&#125;<br><span class="hljs-keyword">class</span> HttpClient&#123;<br> <span class="hljs-keyword">public</span> url:<span class="hljs-built_in">any</span>|<span class="hljs-literal">undefined</span>;<br> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>)&#123;&#125;<br> getDate(<span class="hljs-meta">@logParams</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>) uuid:<span class="hljs-built_in">any</span>)&#123;<br>  <span class="hljs-built_in">console</span>.log(uuid);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">keyof与<span class="hljs-built_in">Object</span>.keys相似，keyof取<span class="hljs-keyword">interface</span>的键<br><span class="hljs-keyword">interface</span> Point &#123;<br> x: <span class="hljs-built_in">number</span>;<br> y: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-comment">// type keys = &quot;x&quot; | &quot;y&quot;</span><br><span class="hljs-keyword">type</span> keys = keyof Point;<br><span class="hljs-comment">// 无法确认返回类型</span><br><span class="hljs-comment">// 无法对 key 做约束</span><br><span class="hljs-keyword">const</span> data = &#123;<br> a: <span class="hljs-number">1</span>,<br> b: <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">o: <span class="hljs-built_in">object</span>, name: <span class="hljs-built_in">string</span></span>) </span>&#123;<br> <span class="hljs-keyword">return</span> o[name]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用keyof：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">o: T, name: K</span>): <span class="hljs-title">T</span>[<span class="hljs-title">K</span>] </span>&#123;<br>  <span class="hljs-keyword">return</span> o[name]<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="`?: 运算符"></a>`?: 运算符</h3><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">T <span class="hljs-keyword">extends</span> U ? X : Y<br><br><span class="hljs-keyword">type</span> isTrue&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-literal">true</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a><code>tsconfig.json</code></h3><p><code>tsconfig.json</code>文件中指定了用来编译这个项目的根文件和编译选项</p>
<p><code>tsconfig.json</code>示例文件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//&quot;compilerOptions&quot;可以被忽略，这时编译器会使用默认值。</span><br><span class="hljs-comment">//使用&quot;files&quot;属性</span><br><span class="hljs-comment">//&quot;files&quot;指定一个包含相对或绝对文件路径的列表。</span><br>&#123;<br>    <span class="hljs-string">&quot;compilerOptions&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;module&quot;</span>: <span class="hljs-string">&quot;commonjs&quot;</span>,<br>        <span class="hljs-string">&quot;noImplicitAny&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;removeComments&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;preserveConstEnums&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;sourceMap&quot;</span>: <span class="hljs-literal">true</span><br>    &#125;,<br>    <span class="hljs-string">&quot;files&quot;</span>: [<br>        <span class="hljs-string">&quot;core.ts&quot;</span>,<br>        <span class="hljs-string">&quot;sys.ts&quot;</span>,<br>        <span class="hljs-string">&quot;types.ts&quot;</span>,<br>        <span class="hljs-string">&quot;scanner.ts&quot;</span>,<br>        <span class="hljs-string">&quot;parser.ts&quot;</span>,<br>        <span class="hljs-string">&quot;utilities.ts&quot;</span>,<br>        <span class="hljs-string">&quot;binder.ts&quot;</span>,<br>        <span class="hljs-string">&quot;checker.ts&quot;</span>,<br>        <span class="hljs-string">&quot;emitter.ts&quot;</span>,<br>        <span class="hljs-string">&quot;program.ts&quot;</span>,<br>        <span class="hljs-string">&quot;commandLineParser.ts&quot;</span>,<br>        <span class="hljs-string">&quot;tsc.ts&quot;</span>,<br>        <span class="hljs-string">&quot;diagnosticInformationMap.generated.ts&quot;</span><br>    ]<br>&#125;<br><span class="hljs-comment">//使用&quot;include&quot;和&quot;exclude&quot;属性</span><br><span class="hljs-comment">//如果&quot;files&quot;和&quot;include&quot;都没有被指定，编译器默认包含当前目录和子目录下所有的TypeScript文件</span><br><span class="hljs-comment">//排除在&quot;exclude&quot;里指定的文件</span><br>&#123;<br>    <span class="hljs-string">&quot;compilerOptions&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;module&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>,<br>        <span class="hljs-string">&quot;noImplicitAny&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;removeComments&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;preserveConstEnums&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;outFile&quot;</span>: <span class="hljs-string">&quot;../../built/local/tsc.js&quot;</span>,<br>        <span class="hljs-string">&quot;sourceMap&quot;</span>: <span class="hljs-literal">true</span><br>    &#125;,<br>    <span class="hljs-string">&quot;include&quot;</span>: [<br>        <span class="hljs-string">&quot;src/**/*&quot;</span><br>    ],<br>    <span class="hljs-string">&quot;exclude&quot;</span>: [<br>        <span class="hljs-string">&quot;node_modules&quot;</span>,<br>        <span class="hljs-string">&quot;**/*.spec.ts&quot;</span><br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Ts</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码理解——模板编译篇</title>
    <url>/2021/03/18/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A33/</url>
    <content><![CDATA[<h4 id="模板编译："><a href="#模板编译：" class="headerlink" title="模板编译："></a>模板编译：</h4><p>在前几篇文章中，我们介绍了<code>Vue</code>中的虚拟<code>DOM</code>以及虚拟<code>DOM</code>的<code>patch</code>(DOM-Diff)过程，而虚拟<code>DOM</code>存在的必要条件是得先有<code>VNode</code>，那么<code>VNode</code>又是从哪儿来的呢？这就是接下来几篇文章要说的模板编译。你可以这么理解：把用户写的模板进行编译，就会产生<code>VNode</code>。</p>
<h5 id="什么是模板编译"><a href="#什么是模板编译" class="headerlink" title="什么是模板编译"></a>什么是模板编译</h5><p>我们知道，在日常开发中，我们把写在<code>&lt;template&gt;&lt;/template&gt;</code>标签中的类似于原生<code>HTML</code>的内容称之为模板。这时你可能会问了，为什么说是“类似于原生<code>HTML</code>的内容”而不是“就是<code>HTML</code>的内容”？因为我们在开发中，在<code>&lt;template&gt;&lt;/template&gt;</code>标签中除了写一些原生<code>HTML</code>的标签，我们还会写一些变量插值，如，或者写一些<code>Vue</code>指令，如<code>v-on</code>、<code>v-if</code>等。而这些东西都是在原生<code>HTML</code>语法中不存在的，不被接受的。但是事实上我们确实这么写了，也被正确识别了，页面也正常显示了，这又是为什么呢？</p>
<p>这就归功于<code>Vue</code>的模板编译了，<code>Vue</code>会把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生<code>HTML</code>的内容进行编译，把原生<code>HTML</code>的内容找出来，再把非原生<code>HTML</code>找出来，经过一系列的逻辑处理生成渲染函数，也就是<code>render</code>函数，而<code>render</code>函数会将模板内容生成对应的<code>VNode</code>，而<code>VNode</code>再经过前几篇文章介绍的<code>patch</code>过程从而得到将要渲染的视图中的<code>VNode</code>，最后根据<code>VNode</code>创建真实的<code>DOM</code>节点并插入到视图中， 最终完成视图的渲染更新。</p>
<p>而把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生<code>HTML</code>的内容进行编译，把原生<code>HTML</code>的内容找出来，再把非原生<code>HTML</code>找出来，经过一系列的逻辑处理生成渲染函数，也就是<code>render</code>函数的这一段过程称之为模板编译过程。</p>
<h6 id="整体渲染流程"><a href="#整体渲染流程" class="headerlink" title="整体渲染流程"></a>整体渲染流程</h6><p>所谓渲染流程，就是把用户写的类似于原生<code>HTML</code>的模板经过一系列处理最终反应到视图中称之为整个渲染流程。这个流程在上文中其实已经说到了，下面我们以流程图的形式宏观的了解一下，流程图如下：</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425144813349.png" alt="image-20210425144813349"></p>
<p>从图中我们也可以看到，模板编译过程就是把用户写的模板经过一系列处理最终生成<code>render</code>函数的过程。</p>
<h6 id="模板编译内部流程"><a href="#模板编译内部流程" class="headerlink" title="模板编译内部流程"></a>模板编译内部流程</h6><p>那么模板编译内部是怎么把用户写的模板经过处理最终生成<code>render</code>函数的呢？这内部的过程是怎样的呢？</p>
<h6 id="抽象语法树AST"><a href="#抽象语法树AST" class="headerlink" title="抽象语法树AST"></a>抽象语法树AST</h6><p>我们知道，用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的模板对<code>Vue</code>来说就是一堆字符串，那么如何解析这一堆字符串并且从中提取出元素的标签、属性、变量插值等有效信息呢？这就需要借助一个叫做抽象语法树的东西。</p>
<p>所谓抽象语法树，在计算机科学中，<strong>抽象语法树</strong>（<strong>A</strong>bstract<strong>S</strong>yntax<strong>T</strong>ree，AST），或简称<strong>语法树</strong>（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于if-condition-then这样的条件跳转语句，可以使用带有两个分支的节点来表示。——来自百度百科</p>
<p>我就知道，这段话贴出来也是白贴，因为看了也看不懂，哈哈。那么我们就以最直观的例子来理解什么是抽象语法树。请看下图：</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425144910621.png" alt="image-20210425144910621"></p>
<p>从图中我们可以看到，一个简单的<code>HTML</code>标签的代码被转换成了一个<code>JS</code>对象，而这个对象中的属性代表了这个标签中一些关键有效信息。如图中标识。 有兴趣的同学可以在这个网站在线转换试试：<a href="https://astexplorer.net/">https://astexplorer.net/</a></p>
<h6 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程:"></a>具体流程:</h6><p>将一堆字符串模板解析成抽象语法树<code>AST</code>后，我们就可以对其进行各种操作处理了，处理完后用处理后的<code>AST</code>来生成<code>render</code>函数。其具体流程可大致分为三个阶段：</p>
<ol>
<li>模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树<code>AST</code>；</li>
<li>优化阶段：遍历<code>AST</code>，找出其中的静态节点，并打上标记；</li>
<li>代码生成阶段：将<code>AST</code>转换成渲染函数；</li>
</ol>
<p>这三个阶段在源码中分别对应三个模块，下面给出三个模块的源代码在源码中的路径：</p>
<ol>
<li>模板解析阶段——解析器——源码路径：<code>src/compiler/parser/index.js</code>;</li>
<li>优化阶段——优化器——源码路径：<code>src/compiler/optimizer.js</code>;</li>
<li>代码生成阶段——代码生成器——源码路径：<code>src/compiler/codegen/index.js</code>; 其对应的源码如下：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 源码位置: /src/complier/index.js</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createCompiler = createCompilerCreator(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseCompile</span> (<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  template: string,</span></span><br><span class="hljs-function"><span class="hljs-params">  options: CompilerOptions</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">CompiledResult</span> </span>&#123;<br>  <span class="hljs-comment">// 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST</span><br>  <span class="hljs-keyword">const</span> ast = parse(template.trim(), options)<br>  <span class="hljs-keyword">if</span> (options.optimize !== <span class="hljs-literal">false</span>) &#123;<br>    <span class="hljs-comment">// 优化阶段：遍历AST，找出其中的静态节点，并打上标记；</span><br>    optimize(ast, options)<br>  &#125;<br>  <span class="hljs-comment">// 代码生成阶段：将AST转换成渲染函数；</span><br>  <span class="hljs-keyword">const</span> code = generate(ast, options)<br>  <span class="hljs-keyword">return</span> &#123;<br>    ast,<br>    render: code.render,<br>    staticRenderFns: code.staticRenderFns<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>可以看到 <code>baseCompile</code> 的代码非常的简短主要核心代码。</p>
<ul>
<li><strong>const ast =parse(template.trim(), options)</strong>:<code>parse</code> 会用正则等方式解析 <code>template</code> 模板中的指令、<code>class</code>、<code>style</code>等数据，形成<code>AST</code>。</li>
<li><strong>optimize(ast, options)</strong>: <code>optimize</code> 的主要作用是标记静态节点，这是 <code>Vue</code> 在编译过程中的一处优化，挡在进行<code>patch</code> 的过程中， <code>DOM-Diff</code> 算法会直接跳过静态节点，从而减少了比较的过程，优化了 <code>patch</code> 的性能。</li>
<li><strong>const code =generate(ast, options)</strong>: 将 <code>AST</code> 转化成 <code>render</code>函数字符串的过程，得到结果是 <code>render</code>函数 的字符串以及 <code>staticRenderFns</code> 字符串。</li>
</ul>
<p>最终 <code>baseCompile</code> 的返回值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&#123;<br> 	ast: ast,<br> 	render: code.render,<br> 	staticRenderFns: code.staticRenderFns<br> &#125;<br></code></pre></td></tr></table></figure>

<p>最终返回了抽象语法树( ast )，渲染函数( render )，静态渲染函数( staticRenderFns )，且<code>render</code> 的值为<code>code.render</code>，<code>staticRenderFns</code> 的值为<code>code.staticRenderFns</code>，也就是说通过 <code>generate</code>处理 <code>ast</code>之后得到的返回值 <code>code</code> 是一个对象。</p>
<p>下面再给出模板编译内部具体流程图，便于理解。流程图如下： <img src="https://vue-js.com/learn-vue/assets/img/3.15d9566b.png" alt="img"></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>本篇文章首先引出了为什么会有模板编译，因为有了模板编译，才有了虚拟<code>DOM</code>，才有了后续的视图更新。接着介绍了什么是模板编译，以及介绍了把用户所写的模板经过层层处理直到最终渲染的视图中这个整体的渲染流程；最后介绍了模板编译过程中所需要使用的抽象语法树的概念以及分析了模板编译的具体实施流程，其流程大致分为三个阶段，分别是模板解析阶段、优化阶段和代码生成阶段。那么接下来的几篇文章将会把这三个阶段逐一进行分析介绍。</p>
<h5 id="1-整体流程"><a href="#1-整体流程" class="headerlink" title="1. 整体流程"></a>1. 整体流程</h5><p>上篇文章中我们说了，在模板解析阶段主要做的工作是把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签内写的模板使用正则等方式解析成抽象语法树（<code>AST</code>）。而这一阶段在源码中对应解析器（<code>parser</code>）模块。</p>
<p>解析器，顾名思义，就是把用户所写的模板根据一定的解析规则解析出有效的信息，最后用这些信息形成<code>AST</code>。我们知道在<code>&lt;template&gt;&lt;/template&gt;</code>模板内，除了有常规的<code>HTML</code>标签外，用户还会一些文本信息以及在文本信息中包含过滤器。而这些不同的内容在解析起来肯定需要不同的解析规则，所以解析器不可能只有一个，它应该除了有解析常规<code>HTML</code>的HTML解析器，还应该有解析文本的文本解析器以及解析文本中如果包含过滤器的过滤器解析器。</p>
<p>另外，文本信息和标签属性信息却又是存在于HTML标签之内的，所以在解析整个模板的时候它的流程应该是这样子的：HTML解析器是主线，先用HTML解析器进行解析整个模板，在解析过程中如果碰到文本内容，那就调用文本解析器来解析文本，如果碰到文本中包含过滤器那就调用过滤器解析器来解析。如下图所示：</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210428165451685.png" alt="image-20210428165451685"></p>
<h5 id="2-回到源码"><a href="#2-回到源码" class="headerlink" title="2. 回到源码"></a>2. 回到源码</h5><p>解析器的源码位于<code>/src/complier/parser</code>文件夹下，其主线代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 代码位置：/src/complier/parser/index.js</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Convert HTML string to AST.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span>(<span class="hljs-params">template, options</span>) </span>&#123;<br>   <span class="hljs-comment">// ...</span><br>  parseHTML(template, &#123;<br>    warn,<br>    expectHTML: options.expectHTML,<br>    isUnaryTag: options.isUnaryTag,<br>    canBeLeftOpenTag: options.canBeLeftOpenTag,<br>    shouldDecodeNewlines: options.shouldDecodeNewlines,<br>    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,<br>    shouldKeepComment: options.comments,<br>    start (tag, attrs, unary) &#123;<br><br>    &#125;,<br>    end () &#123;<br><br>    &#125;,<br>    chars (text: string) &#123;<br><br>    &#125;,<br>    comment (text: string) &#123;<br><br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面代码中可以看到，<code>parse</code> 函数就是解析器的主函数，在<code>parse</code> 函数内调用了<code>parseHTML</code> 函数对模板字符串进行解析，在<code>parseHTML</code> 函数解析模板字符串的过程中，如果遇到文本信息，就会调用文本解析器<code>parseText</code>函数进行文本解析；如果遇到文本中包含过滤器，就会调用过滤器解析器<code>parseFilters</code>函数进行解析。</p>
<h5 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h5><p>本篇文章主要梳理了模板解析的整体运行流程，模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为HTML解析器，文本解析器和过滤器解析器。而文本信息与过滤器信息又存在于HTML标签中，所以在解析器主线函数<code>parse</code>中先调用HTML解析器<code>parseHTML</code> 函数对模板字符串进行解析，如果在解析过程中遇到文本或过滤器信息则再调用相应的解析器进行解析，最终完成对整个模板字符串的解析。</p>
<p>了解了模板解析阶段的整体运行流程后，接下来，我们就对流程中所涉及到的三种解析器分别深入分析，逐个击破。</p>
<p>上篇文章中我们说到，在模板解析阶段主线函数<code>parse</code>中，根据要解析的内容不同会调用不同的解析器，</p>
<p>而在三个不同的解析器中最主要的当属<code>HTML</code>解析器，为什么这么说呢？因为<code>HTML</code>解析器主要负责解析出模板字符串中有哪些内容，然后根据不同的内容才能调用其他的解析器以及做相应的处理。那么本篇文章就来介绍一下<code>HTML</code>解析器是如何解析出模板字符串中包含的不同的内容的。</p>
<h5 id="解析器内部运行流程"><a href="#解析器内部运行流程" class="headerlink" title="解析器内部运行流程"></a>解析器内部运行流程</h5><h5 id="2-HTML解析器内部运行流程"><a href="#2-HTML解析器内部运行流程" class="headerlink" title="2. HTML解析器内部运行流程"></a>2. HTML解析器内部运行流程</h5><p>在源码中，<code>HTML</code>解析器就是<code>parseHTML</code>函数，在模板解析主线函数<code>parse</code>中调用了该函数，并传入两个参数，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 代码位置：/src/complier/parser/index.js</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Convert HTML string to AST.</span><br><span class="hljs-comment"> * 将HTML模板字符串转化为AST</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span>(<span class="hljs-params">template, options</span>) </span>&#123;<br>   <span class="hljs-comment">// ...</span><br>  parseHTML(template, &#123;<br>    warn,<br>    expectHTML: options.expectHTML,<br>    isUnaryTag: options.isUnaryTag,<br>    canBeLeftOpenTag: options.canBeLeftOpenTag,<br>    shouldDecodeNewlines: options.shouldDecodeNewlines,<br>    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,<br>    shouldKeepComment: options.comments,<br>    <span class="hljs-comment">// 当解析到开始标签时，调用该函数</span><br>    start (tag, attrs, unary) &#123;<br><br>    &#125;,<br>    <span class="hljs-comment">// 当解析到结束标签时，调用该函数</span><br>    end () &#123;<br><br>    &#125;,<br>    <span class="hljs-comment">// 当解析到文本时，调用该函数</span><br>    chars (text) &#123;<br><br>    &#125;,<br>    <span class="hljs-comment">// 当解析到注释时，调用该函数</span><br>    comment (text) &#123;<br><br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从代码中我们可以看到，调用<code>parseHTML</code>函数时为其传入的两个参数分别是：</p>
<ul>
<li>template:待转换的模板字符串；</li>
<li>options:转换时所需的选项；</li>
</ul>
<p>第一个参数是待转换的模板字符串，无需多言；重点看第二个参数，第二个参数提供了一些解析<code>HTML</code>模板时的一些参数，同时还定义了4个钩子函数。这4个钩子函数有什么作用呢？我们说了模板编译阶段主线函数<code>parse</code>会将<code>HTML</code>模板字符串转化成<code>AST</code>，而<code>parseHTML</code>是用来解析模板字符串的，把模板字符串中不同的内容出来之后，那么谁来把提取出来的内容生成对应的<code>AST</code>呢？答案就是这4个钩子函数。</p>
<p>把这4个钩子函数作为参数传给解析器<code>parseHTML</code>，当解析器解析出不同的内容时调用不同的钩子函数从而生成不同的<code>AST</code>。</p>
<p>当解析到开始标签时调用<code>start</code>函数生成元素类型的<code>AST</code>节点，代码如下；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 当解析到标签的开始位置时，触发start</span><br>start (tag, attrs, unary) &#123;<br>	<span class="hljs-keyword">let</span> element = createASTElement(tag, attrs, currentParent)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createASTElement</span> (<span class="hljs-params">tag,attrs,parent</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    type: <span class="hljs-number">1</span>,<br>    tag,<br>    attrsList: attrs,<br>    attrsMap: makeAttrsMap(attrs),<br>    parent,<br>    children: []<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>从上面代码中我们可以看到，<code>start</code>函数接收三个参数，分别是标签名<code>tag</code>、标签属性<code>attrs</code>、标签是否自闭合<code>unary</code>。当调用该钩子函数时，内部会调用<code>createASTElement</code>函数来创建元素类型的<code>AST</code>节点</li>
<li>当解析到结束标签时调用<code>end</code>函数；</li>
<li>当解析到文本时调用<code>chars</code>函数生成文本类型的<code>AST</code>节点；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 当解析到标签的文本时，触发chars</span><br>chars (text) &#123;<br>	<span class="hljs-keyword">if</span>(text是带变量的动态文本)&#123;<br>    <span class="hljs-keyword">let</span> element = &#123;<br>      type: <span class="hljs-number">2</span>,<br>      expression: res.expression,<br>      tokens: res.tokens,<br>      text<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">let</span> element = &#123;<br>      type: <span class="hljs-number">3</span>,<br>      text<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>当解析到标签的文本时，触发<code>chars</code>钩子函数，在该钩子函数内部，首先会判断文本是不是一个带变量的动态文本，如“hello ”。如果是动态文本，则创建动态文本类型的<code>AST</code>节点；如果不是动态文本，则创建纯静态文本类型的<code>AST</code>节点。</li>
<li>当解析到注释时调用<code>comment</code>函数生成注释类型的<code>AST</code>节点；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">/ 当解析到标签的注释时，触发comment<br>comment (text: string) &#123;<br>  <span class="hljs-keyword">let</span> element = &#123;<br>    type: <span class="hljs-number">3</span>,<br>    text,<br>    isComment: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>当解析到标签的注释时，触发<code>comment</code>钩子函数，该钩子函数会创建一个注释类型的<code>AST</code>节点。</li>
</ul>
<p>一边解析不同的内容一边调用对应的钩子函数生成对应的<code>AST</code>节点，最终完成将整个模板字符串转化成<code>AST</code>,这就是<code>HTML</code>解析器所要做的工作。</p>
<h5 id="3-如何解析不同的内容"><a href="#3-如何解析不同的内容" class="headerlink" title="3. 如何解析不同的内容"></a>3. 如何解析不同的内容</h5><p>要从模板字符串中解析出不同的内容，那首先要知道模板字符串中都会包含哪些内容。那么通常我们所写的模板字符串中都会包含哪些内容呢？经过整理，通常模板内会包含如下内容：</p>
<ul>
<li>文本，例如“难凉热血”</li>
<li>HTML注释，例如<!-- 我是注释 --></li>
<li>条件注释，例如<!-- [if !IE]> -->我是注释<!--< ![endif] --></li>
<li>DOCTYPE，例如<!DOCTYPE html></li>
<li>开始标签，例如<div></li>
<li>结束标签，例如</div></li>
</ul>
<p>这几种内容都有其各自独有的特点，也就是说我们要根据不同内容所具有的不同的的特点通过编写不同的正则表达式将这些内容从模板字符串中一一解析出来，然后再把不同的内容做不同的处理。</p>
<p>下面，我们就来分别看一下<code>HTML</code>解析器是如何从模板字符串中将以上不同种类的内容进行解析出来。</p>
<h5 id="3-1-解析HTML注释"><a href="#3-1-解析HTML注释" class="headerlink" title="3.1 解析HTML注释"></a>3.1 解析HTML注释</h5><p>解析注释比较简单，我们知道<code>HTML</code>注释是以<code>&lt;!--</code>开头，以<code>--&gt;</code>结尾，这两者中间的内容就是注释内容，那么我们只需用正则判断待解析的模板字符串<code>html</code>是否以<code>&lt;!--</code>开头，若是，那就继续向后寻找<code>--&gt;</code>，如果找到了，OK，注释就被解析出来了。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> comment = <span class="hljs-regexp">/^&lt;!\--/</span><br><span class="hljs-keyword">if</span> (comment.test(html)) &#123;<br>  <span class="hljs-comment">// 若为注释，则继续查找是否存在&#x27;--&gt;&#x27;</span><br>  <span class="hljs-keyword">const</span> commentEnd = html.indexOf(<span class="hljs-string">&#x27;--&gt;&#x27;</span>)<br><br>  <span class="hljs-keyword">if</span> (commentEnd &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 若存在 &#x27;--&gt;&#x27;,继续判断options中是否保留注释</span><br>    <span class="hljs-keyword">if</span> (options.shouldKeepComment) &#123;<br>      <span class="hljs-comment">// 若保留注释，则把注释截取出来传给options.comment，创建注释类型的AST节点</span><br>      options.comment(html.substring(<span class="hljs-number">4</span>, commentEnd))<br>    &#125;<br>    <span class="hljs-comment">// 若不保留注释，则将游标移动到&#x27;--&gt;&#x27;之后，继续向后解析</span><br>    advance(commentEnd + <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">continue</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面代码中，如果模板字符串<code>html</code>符合注释开始的正则，那么就继续向后查找是否存在<code>--&gt;</code>，若存在，则把<code>html</code>从第4位（”<!--"长度为4）开始截取，直到`--><code>处，截取得到的内容就是注释的真实内容，然后调用4个钩子函数中的</code>comment<code>函数，将真实的注释内容传进去，创建注释类型的</code>AST`节点。</p>
<p>上面代码中有一处值得注意的地方，那就是我们平常在模板中可以在<code>&lt;template&gt;&lt;/template&gt;</code>标签上配置<code>comments</code>选项来决定在渲染模板时是否保留注释，对应到上面代码中就是<code>options.shouldKeepComment</code>,如果用户配置了<code>comments</code>选项为<code>true</code>，则<code>shouldKeepComment</code>为<code>true</code>，则创建注释类型的<code>AST</code>节点，如不保留注释，则将游标移动到’–&gt;’之后，继续向后解析。</p>
<p><code>advance</code>函数是用来移动解析游标的，解析完一部分就把游标向后移动一部分，确保不会重复解析，其代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">advance</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  index += n   <span class="hljs-comment">// index为解析游标</span><br>  html = html.substring(n)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210428171551449.png" alt="image-20210428171551449"></p>
<p>调用 <code>advance</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">advance(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210428171638566.png" alt="image-20210428171638566"></p>
<p>从图中可以看到，解析游标<code>index</code>最开始在模板字符串的位置0处，当调用了<code>advance(3)</code>之后，解析游标到了位置3处，每次解析完一段内容就将游标向后移动一段，接着再从解析游标往后解析，这样就保证了解析过的内容不会被重复解析。</p>
<h5 id="3-2-解析条件注释"><a href="#3-2-解析条件注释" class="headerlink" title="3.2 解析条件注释"></a>3.2 解析条件注释</h5><p>解析条件注释也比较简单，其原理跟解析注释相同，都是先用正则判断是否是以条件注释特有的开头标识开始，然后寻找其特有的结束标识，若找到，则说明是条件注释，将其截取出来即可，由于条件注释不存在于真正的<code>DOM</code>树中，所以不需要调用钩子函数创建<code>AST</code>节点。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 解析是否是条件注释</span><br><span class="hljs-keyword">const</span> conditionalComment = <span class="hljs-regexp">/^&lt;!\[/</span><br><span class="hljs-keyword">if</span> (conditionalComment.test(html)) &#123;<br>  <span class="hljs-comment">// 若为条件注释，则继续查找是否存在&#x27;]&gt;&#x27;</span><br>  <span class="hljs-keyword">const</span> conditionalEnd = html.indexOf(<span class="hljs-string">&#x27;]&gt;&#x27;</span>)<br><br>  <span class="hljs-keyword">if</span> (conditionalEnd &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 若存在 &#x27;]&gt;&#x27;,则从原本的html字符串中把条件注释截掉，</span><br>    <span class="hljs-comment">// 把剩下的内容重新赋给html，继续向后匹配</span><br>    advance(conditionalEnd + <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">continue</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="3-3-解析DOCTYPE"><a href="#3-3-解析DOCTYPE" class="headerlink" title="3.3 解析DOCTYPE"></a>3.3 解析DOCTYPE</h5><p>解析<code>DOCTYPE</code>的原理同解析条件注释完全相同，此处不再赘述，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> doctype = <span class="hljs-regexp">/^&lt;!DOCTYPE [^&gt;]+&gt;/i</span><br><span class="hljs-comment">// 解析是否是DOCTYPE</span><br><span class="hljs-keyword">const</span> doctypeMatch = html.match(doctype)<br><span class="hljs-keyword">if</span> (doctypeMatch) &#123;<br>  advance(doctypeMatch[<span class="hljs-number">0</span>].length)<br>  <span class="hljs-keyword">continue</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="3-4-解析开始标签"><a href="#3-4-解析开始标签" class="headerlink" title="3.4 解析开始标签"></a>3.4 解析开始标签</h5><p>相较于前三种内容的解析，解析开始标签会稍微复杂一点，但是万变不离其宗，它的原理还是相通的，都是使用正则去匹配提取。</p>
<p>首先使用开始标签的正则去匹配模板字符串，看模板字符串是否具有开始标签的特征，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 匹配开始标签的正则</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> ncname = <span class="hljs-string">&#x27;[a-zA-Z_][\\w\\-\\.]*&#x27;</span><br><span class="hljs-keyword">const</span> qnameCapture = <span class="hljs-string">`((?:<span class="hljs-subst">$&#123;ncname&#125;</span>\\:)?<span class="hljs-subst">$&#123;ncname&#125;</span>)`</span><br><span class="hljs-keyword">const</span> startTagOpen = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`^&lt;<span class="hljs-subst">$&#123;qnameCapture&#125;</span>`</span>)<br><br><span class="hljs-keyword">const</span> start = html.match(startTagOpen)<br><span class="hljs-keyword">if</span> (start) &#123;<br>  <span class="hljs-keyword">const</span> match = &#123;<br>    tagName: start[<span class="hljs-number">1</span>],<br>    attrs: [],<br>    start: index<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 以开始标签开始的模板：</span><br><span class="hljs-string">&#x27;&lt;div&gt;&lt;/div&gt;&#x27;</span>.match(startTagOpen)  =&gt; [<span class="hljs-string">&#x27;&lt;div&#x27;</span>,<span class="hljs-string">&#x27;div&#x27;</span>,<span class="hljs-attr">index</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">input</span>:<span class="hljs-string">&#x27;&lt;div&gt;&lt;/div&gt;&#x27;</span>]<br><span class="hljs-comment">// 以结束标签开始的模板：</span><br><span class="hljs-string">&#x27;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&#x27;</span>.match(startTagOpen) =&gt; <span class="hljs-literal">null</span><br><span class="hljs-comment">// 以文本开始的模板：</span><br><span class="hljs-string">&#x27;我是文本&lt;/p&gt;&#x27;</span>.match(startTagOpen) =&gt; <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure>

<p>在上面代码中，我们用不同类型的内容去匹配开始标签的正则，发现只有<code>&lt;div&gt;&lt;/div&gt;</code>的字符串可以正确匹配，并且返回一个数组。</p>
<p>在前文中我们说到，当解析到开始标签时，会调用4个钩子函数中的<code>start</code>函数，而<code>start</code>函数需要传递3个参数，分别是标签名<code>tag</code>、标签属性<code>attrs</code>、标签是否自闭合<code>unary</code>。标签名通过正则匹配的结果就可以拿到，即上面代码中的<code>start[1]</code>，而标签属性<code>attrs</code>以及标签是否自闭合<code>unary</code>需要进一步解析。</p>
<p>解析标签属性</p>
<p>我们知道，标签属性一般是写在开始标签的标签名之后的，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>另外，我们在上面匹配是否是开始标签的正则中已经可以拿到开始标签的标签名，即上面代码中的<code>start[0]</code>，那么我们可以将这一部分先从模板字符串中截掉，则剩下的部分如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">class=&quot;a&quot; id=&quot;b&quot;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>那么我们只需用剩下的这部分去匹配标签属性的正则，就可以将标签属性提取出来了，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ncname = <span class="hljs-string">&#x27;[a-zA-Z_][\\w\\-\\.]*&#x27;</span><br><span class="hljs-keyword">const</span> qnameCapture = <span class="hljs-string">`((?:<span class="hljs-subst">$&#123;ncname&#125;</span>\\:)?<span class="hljs-subst">$&#123;ncname&#125;</span>)`</span><br><span class="hljs-keyword">const</span> endTag = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`^&lt;\\/<span class="hljs-subst">$&#123;qnameCapture&#125;</span>[^&gt;]*&gt;`</span>)<br><span class="hljs-keyword">const</span> endTagMatch = html.match(endTag)<br><br><span class="hljs-string">&#x27;&lt;/div&gt;&#x27;</span>.match(endTag)  <span class="hljs-comment">// [&quot;&lt;/div&gt;&quot;, &quot;div&quot;, index: 0, input: &quot;&lt;/div&gt;&quot;, groups: undefined]</span><br><span class="hljs-string">&#x27;&lt;div&gt;&#x27;</span>.match(endTag)  <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，如果模板字符串符合结束标签的特征，则会获得匹配结果数组；如果不合符，则得到null。</p>
<p>接着再调用<code>end</code>钩子函数，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (endTagMatch) &#123;<br>    <span class="hljs-keyword">const</span> curIndex = index<br>    advance(endTagMatch[<span class="hljs-number">0</span>].length)<br>    parseEndTag(endTagMatch[<span class="hljs-number">1</span>], curIndex, index)<br>    <span class="hljs-keyword">continue</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面代码中，没有直接去调用<code>end</code>函数，而是调用了<code>parseEndTag</code>函数，关于<code>parseEndTag</code>函数内部的作用我们后面会介绍到，在这里你暂时可以理解为该函数内部就是去调用了<code>end</code>钩子函数。</p>
<h5 id="3-6-解析文本"><a href="#3-6-解析文本" class="headerlink" title="3.6 解析文本"></a>3.6 解析文本</h5><figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">终于到了解析最后一种文本类型的内容了，为什么要把解析文本类型放在最后一个介绍呢？我们仔细想一下，前面五种类型都是以`&lt;`开头的，只有文本类型的内容不是以`&lt;`开头的，所以我们在解析模板字符串的时候可以先判断一下字符串是不是以`&lt;`开头的，如果是则继续判断是以上五种类型的具体哪一种，而如果不是的话，那它肯定就是文本了。<br></code></pre></td></tr></table></figure>

<p>解析文本也比较容易，在解析模板字符串之前，我们先查找一下第一个<code>&lt;</code>出现在什么位置，如果第一个<code>&lt;</code>在第一个位置，那么说明模板字符串是以其它5种类型开始的；如果第一个<code>&lt;</code>不在第一个位置而在模板字符串中间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个<code>&lt;</code>出现的位置就都是文本内容了；如果在整个模板字符串里没有找到<code>&lt;</code>，那说明整个模板字符串都是文本。这就是解析思路，接下来我们对照源码来了解一下实际的解析过程，源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> textEnd = html.indexOf(<span class="hljs-string">&#x27;&lt;&#x27;</span>)<br><span class="hljs-comment">// &#x27;&lt;&#x27; 在第一个位置，为其余5种类型</span><br><span class="hljs-keyword">if</span> (textEnd === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-comment">// &#x27;&lt;&#x27; 不在第一个位置，文本开头</span><br><span class="hljs-keyword">if</span> (textEnd &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 如果html字符串不是以&#x27;&lt;&#x27;开头,说明&#x27;&lt;&#x27;前面的都是纯文本，无需处理</span><br>    <span class="hljs-comment">// 那就把&#x27;&lt;&#x27;以后的内容拿出来赋给rest</span><br>    rest = html.slice(textEnd)<br>    <span class="hljs-keyword">while</span> (<br>        !endTag.test(rest) &amp;&amp;<br>        !startTagOpen.test(rest) &amp;&amp;<br>        !comment.test(rest) &amp;&amp;<br>        !conditionalComment.test(rest)<br>    ) &#123;<br>        <span class="hljs-comment">// &lt; in plain text, be forgiving and treat it as text</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">           * 用&#x27;&lt;&#x27;以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment</span><br><span class="hljs-comment">           * 如果都匹配不上，表示&#x27;&lt;&#x27;是属于文本本身的内容</span><br><span class="hljs-comment">           */</span><br>        <span class="hljs-comment">// 在&#x27;&lt;&#x27;之后查找是否还有&#x27;&lt;&#x27;</span><br>        next = rest.indexOf(<span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// 如果没有了，表示&#x27;&lt;&#x27;后面也是文本</span><br>        <span class="hljs-keyword">if</span> (next &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span><br>        <span class="hljs-comment">// 如果还有，表示&#x27;&lt;&#x27;是文本中的一个字符</span><br>        textEnd += next<br>        <span class="hljs-comment">// 那就把next之后的内容截出来继续下一轮循环匹配</span><br>        rest = html.slice(textEnd)<br>    &#125;<br>    <span class="hljs-comment">// &#x27;&lt;&#x27;是结束标签的开始 ,说明从开始到&#x27;&lt;&#x27;都是文本，截取出来</span><br>    text = html.substring(<span class="hljs-number">0</span>, textEnd)<br>    advance(textEnd)<br>&#125;<br><span class="hljs-comment">// 整个模板字符串里没有找到`&lt;`,说明整个模板字符串都是文本</span><br><span class="hljs-keyword">if</span> (textEnd &lt; <span class="hljs-number">0</span>) &#123;<br>    text = html<br>    html = <span class="hljs-string">&#x27;&#x27;</span><br>&#125;<br><span class="hljs-comment">// 把截取出来的text转化成textAST</span><br><span class="hljs-keyword">if</span> (options.chars &amp;&amp; text) &#123;<br>    options.chars(text)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>源码的逻辑很清晰，根据<code>&lt;</code>在不在第一个位置以及整个模板字符串里没有<code>&lt;</code>都分别进行了处理。</p>
<p>值得深究的是如果<code>&lt;</code>不在第一个位置而在模板字符串中间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个<code>&lt;</code>出现的位置就都是文本内容了，接着我们还要从第一个<code>&lt;</code>的位置继续向后判断，因为还存在这样一种情况，那就是如果文本里面本来就包含一个<code>&lt;</code>，例如<code>1&lt;2&lt;/div&gt;</code>。为了处理这种情况，我们把从第一个<code>&lt;</code>的位置直到模板字符串结束都截取出来记作<code>rest</code>，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> rest = html.slice(textEnd)<br></code></pre></td></tr></table></figure>

<p>接着用<code>rest</code>去匹配以上5种类型的正则，如果都匹配不上，则表明这个<code>&lt;</code>是属于文本本身的内容，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (<br>    !endTag.test(rest) &amp;&amp;<br>    !startTagOpen.test(rest) &amp;&amp;<br>    !comment.test(rest) &amp;&amp;<br>    !conditionalComment.test(rest)<br>) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果都匹配不上，则表明这个<code>&lt;</code>是属于文本本身的内容，接着以这个<code>&lt;</code>的位置继续向后查找，看是否还有<code>&lt;</code>，如果没有了，则表示后面的都是文本；如果后面还有下一个<code>&lt;</code>，那表明至少在这个<code>&lt;</code>到下一个<code>&lt;</code>中间的内容都是文本，至于下一个<code>&lt;</code>以后的内容是什么，则还需要重复以上的逻辑继续判断。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (<br>    !endTag.test(rest) &amp;&amp;<br>    !startTagOpen.test(rest) &amp;&amp;<br>    !comment.test(rest) &amp;&amp;<br>    !conditionalComment.test(rest)<br>) &#123;<br>    <span class="hljs-comment">// &lt; in plain text, be forgiving and treat it as text</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用&#x27;&lt;&#x27;以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment</span><br><span class="hljs-comment">    * 如果都匹配不上，表示&#x27;&lt;&#x27;是属于文本本身的内容</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 在&#x27;&lt;&#x27;之后查找是否还有&#x27;&lt;&#x27;</span><br>    next = rest.indexOf(<span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// 如果没有了，表示&#x27;&lt;&#x27;后面也是文本</span><br>    <span class="hljs-keyword">if</span> (next &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span><br>    <span class="hljs-comment">// 如果还有，表示&#x27;&lt;&#x27;是文本中的一个字符</span><br>    textEnd += next<br>    <span class="hljs-comment">// 那就把next之后的内容截出来继续下一轮循环匹配</span><br>    rest = html.slice(textEnd)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后截取文本内容<code>text</code>并调用4个钩子函数中的<code>chars</code>函数创建文本型的<code>AST</code>节点。</p>
<h5 id="4-如何保证AST节点层级关系"><a href="#4-如何保证AST节点层级关系" class="headerlink" title="4. 如何保证AST节点层级关系"></a>4. 如何保证AST节点层级关系</h5><p>上一章节我们介绍了<code>HTML</code>解析器是如何解析各种不同类型的内容并且调用钩子函数创建不同类型的<code>AST</code>节点。此时你可能会有个疑问，我们上面创建的<code>AST</code>节点都是单独创建且分散的，而真正的<code>DOM</code>节点都是有层级关系的，那如何来保证<code>AST</code>节点的层级关系与真正的<code>DOM</code>节点相同呢？</p>
<p>关于这个问题，<code>Vue</code>也注意到了。<code>Vue</code>在<code>HTML</code>解析器的开头定义了一个栈<code>stack</code>，这个栈的作用就是用来维护<code>AST</code>节点层级的，那么它是怎么维护的呢？通过前文我们知道，<code>HTML</code>解析器在从前向后解析模板字符串时，每当遇到开始标签时就会调用<code>start</code>钩子函数，那么在<code>start</code>钩子函数内部我们可以将解析得到的开始标签推入栈中，而每当遇到结束标签时就会调用<code>end</code>钩子函数，那么我们也可以在<code>end</code>钩子函数内部将解析得到的结束标签所对应的开始标签从栈中弹出。请看如下例子：</p>
<p>假如有如下模板字符串：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>当解析到开始标签<code>&lt;div&gt;</code>时，就把<code>div</code>推入栈中，然后继续解析，当解析到<code>&lt;p&gt;</code>时，再把<code>p</code>推入栈中，同理，再把<code>span</code>推入栈中，当解析到结束标签<code>&lt;/span&gt;</code>时，此时栈顶的标签刚好是<code>span</code>的开始标签，那么就用<code>span</code>的开始标签和结束标签构建<code>AST</code>节点，并且从栈中把<code>span</code>的开始标签弹出，那么此时栈中的栈顶标签<code>p</code>就是构建好的<code>span</code>的<code>AST</code>节点的父节点，如下图：</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210428173344529.png" alt="image-20210428173344529"></p>
<p>这样我们就找到了当前被构建节点的父节点。这只是栈的一个用途，它还有另外一个用途，我们再看如下模板字符串：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>按照上面的流程解析这个模板字符串时，当解析到结束标签<code>&lt;/p&gt;</code>时，此时栈顶的标签应该是<code>p</code>才对，而现在是<code>span</code>，那么就说明<code>span</code>标签没有被正确闭合，此时控制台就会抛出警告：‘tag has no matching end tag.’相信这个警告你一定不会陌生。这就是栈的第二个用途： 检测模板字符串中是否有未正确闭合的标签。</p>
<p>OK，有了这个栈的概念之后，我们再回看上一章<code>HTML</code>解析器解析不同内容的代码。</p>
<h5 id="5-回归源码"><a href="#5-回归源码" class="headerlink" title="5. 回归源码"></a>5. 回归源码</h5><h6 id="5-1-HTML解析器源码"><a href="#5-1-HTML解析器源码" class="headerlink" title="5.1 HTML解析器源码"></a>5.1 HTML解析器源码</h6><p>以上内容都了解了之后，我们回归源码，逐句分析<code>HTML</code>解析器<code>parseHTML</code>函数，函数定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseHTML</span>(<span class="hljs-params">html, options</span>) </span>&#123;<br>	<span class="hljs-keyword">var</span> stack = [];<br>	<span class="hljs-keyword">var</span> expectHTML = options.expectHTML;<br>	<span class="hljs-keyword">var</span> isUnaryTag$$<span class="hljs-number">1</span> = options.isUnaryTag || no;<br>	<span class="hljs-keyword">var</span> canBeLeftOpenTag$$<span class="hljs-number">1</span> = options.canBeLeftOpenTag || no;<br>	<span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">var</span> last, lastTag;<br><br>	<span class="hljs-comment">// 开启一个 while 循环，循环结束的条件是 html 为空，即 html 被 parse 完毕</span><br>	<span class="hljs-keyword">while</span> (html) &#123;<br>		last = html;<br>		<span class="hljs-comment">// 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)</span><br>		<span class="hljs-keyword">if</span> (!lastTag || !isPlainTextElement(lastTag)) &#123;<br>		   <span class="hljs-keyword">let</span> textEnd = html.indexOf(<span class="hljs-string">&#x27;&lt;&#x27;</span>)<br>              <span class="hljs-comment">/**</span><br><span class="hljs-comment">               * 如果html字符串是以&#x27;&lt;&#x27;开头,则有以下几种可能</span><br><span class="hljs-comment">               * 开始标签:&lt;div&gt;</span><br><span class="hljs-comment">               * 结束标签:&lt;/div&gt;</span><br><span class="hljs-comment">               * 注释:&lt;!-- 我是注释 --&gt;</span><br><span class="hljs-comment">               * 条件注释:&lt;!-- [if !IE] --&gt; &lt;!-- [endif] --&gt;</span><br><span class="hljs-comment">               * DOCTYPE:&lt;!DOCTYPE html&gt;</span><br><span class="hljs-comment">               * 需要一一去匹配尝试</span><br><span class="hljs-comment">               */</span><br>            <span class="hljs-keyword">if</span> (textEnd === <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 解析是否是注释</span><br>        		<span class="hljs-keyword">if</span> (comment.test(html)) &#123;<br><br>                &#125;<br>                <span class="hljs-comment">// 解析是否是条件注释</span><br>                <span class="hljs-keyword">if</span> (conditionalComment.test(html)) &#123;<br><br>                &#125;<br>                <span class="hljs-comment">// 解析是否是DOCTYPE</span><br>                <span class="hljs-keyword">const</span> doctypeMatch = html.match(doctype)<br>                <span class="hljs-keyword">if</span> (doctypeMatch) &#123;<br><br>                &#125;<br>                <span class="hljs-comment">// 解析是否是结束标签</span><br>                <span class="hljs-keyword">const</span> endTagMatch = html.match(endTag)<br>                <span class="hljs-keyword">if</span> (endTagMatch) &#123;<br><br>                &#125;<br>                <span class="hljs-comment">// 匹配是否是开始标签</span><br>                <span class="hljs-keyword">const</span> startTagMatch = parseStartTag()<br>                <span class="hljs-keyword">if</span> (startTagMatch) &#123;<br><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果html字符串不是以&#x27;&lt;&#x27;开头,则解析文本类型</span><br>            <span class="hljs-keyword">let</span> text, rest, next<br>            <span class="hljs-keyword">if</span> (textEnd &gt;= <span class="hljs-number">0</span>) &#123;<br><br>            &#125;<br>            <span class="hljs-comment">// 如果在html字符串中没有找到&#x27;&lt;&#x27;，表示这一段html字符串都是纯文本</span><br>            <span class="hljs-keyword">if</span> (textEnd &lt; <span class="hljs-number">0</span>) &#123;<br>                text = html<br>                html = <span class="hljs-string">&#x27;&#x27;</span><br>            &#125;<br>            <span class="hljs-comment">// 把截取出来的text转化成textAST</span><br>            <span class="hljs-keyword">if</span> (options.chars &amp;&amp; text) &#123;<br>                options.chars(text)<br>            &#125;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// 父元素为script、style、textarea时，其内部的内容全部当做纯文本处理</span><br>		&#125;<br><br>		<span class="hljs-comment">//将整个字符串作为文本对待</span><br>		<span class="hljs-keyword">if</span> (html === last) &#123;<br>			options.chars &amp;&amp; options.chars(html);<br>			<span class="hljs-keyword">if</span> (!stack.length &amp;&amp; options.warn) &#123;<br>				options.warn((<span class="hljs-string">&quot;Mal-formatted tag at end of template: \&quot;&quot;</span> + html + <span class="hljs-string">&quot;\&quot;&quot;</span>));<br>			&#125;<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// Clean up any remaining tags</span><br>	parseEndTag();<br>	<span class="hljs-comment">//parse 开始标签</span><br>	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseStartTag</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>	&#125;<br>	<span class="hljs-comment">//处理 parseStartTag 的结果</span><br>	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleStartTag</span>(<span class="hljs-params">match</span>) </span>&#123;<br><br>	&#125;<br>	<span class="hljs-comment">//parse 结束标签</span><br>	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseEndTag</span>(<span class="hljs-params">tagName, start, end</span>) </span>&#123;<br><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    上述代码中大致可分为三部分：</p>
<ul>
<li>定义的一些常量和变量</li>
<li>while 循环</li>
<li>解析过程中用到的辅助函数</li>
</ul>
<p>我们一一来分析：</p>
<p>首先定义了几个常量，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> stack = []       <span class="hljs-comment">// 维护AST节点层级的栈</span><br><span class="hljs-keyword">const</span> expectHTML = options.expectHTML<br><span class="hljs-keyword">const</span> isUnaryTag = options.isUnaryTag || no<br><span class="hljs-keyword">const</span> canBeLeftOpenTag = options.canBeLeftOpenTag || no   <span class="hljs-comment">//用来检测一个标签是否是可以省略闭合标签的非自闭合标签</span><br><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>   <span class="hljs-comment">//解析游标，标识当前从何处开始解析模板字符串</span><br><span class="hljs-keyword">let</span> last,   <span class="hljs-comment">// 存储剩余还未解析的模板字符串</span><br>    lastTag  <span class="hljs-comment">// 存储着位于 stack 栈顶的元素</span><br></code></pre></td></tr></table></figure>

<p>接着开启<code>while</code> 循环，循环的终止条件是 模板字符串<code>html</code>为空，即模板字符串被全部编译完毕。在每次<code>while</code>循环中， 先把 <code>html</code>的值赋给变量 <code>last</code>，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">last = html<br></code></pre></td></tr></table></figure>

<p>这样做的目的是，如果经过上述所有处理逻辑处理过后，<code>html</code>字符串没有任何变化，即表示<code>html</code>字符串没有匹配上任何一条规则，那么就把<code>html</code>字符串当作纯文本对待，创建文本类型的<code>AST</code>节点并且如果抛出异常：模板字符串中标签格式有误。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//将整个字符串作为文本对待</span><br><span class="hljs-keyword">if</span> (html === last) &#123;<br>    options.chars &amp;&amp; options.chars(html);<br>    <span class="hljs-keyword">if</span> (!stack.length &amp;&amp; options.warn) &#123;<br>        options.warn((<span class="hljs-string">&quot;Mal-formatted tag at end of template: \&quot;&quot;</span> + html + <span class="hljs-string">&quot;\&quot;&quot;</span>));<br>    &#125;<br>    <span class="hljs-keyword">break</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>接着，我们继续看<code>while</code>循环体内的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (html) &#123;<br>  <span class="hljs-comment">// 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)</span><br>  <span class="hljs-keyword">if</span> (!lastTag || !isPlainTextElement(lastTag)) &#123;<br><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// parse 的内容是在纯文本标签里 (script,style,textarea)</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在循环体内，首先判断了待解析的<code>html</code>字符串是否在纯文本标签里，如<code>script</code>,<code>style</code>,<code>textarea</code>，因为在这三个标签里的内容肯定不会有<code>HTML</code>标签，所以我们可直接当作文本处理，判断条件如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">!lastTag || !isPlainTextElement(lastTag)<br></code></pre></td></tr></table></figure>

<p>前面我们说了，<code>lastTag</code>为栈顶元素，<code>!lastTag</code>即表示当前<code>html</code>字符串没有父节点，而<code>isPlainTextElement(lastTag)</code> 是检测 <code>lastTag</code> 是否为是那三个纯文本标签之一，是的话返回<code>true</code>，不是返回<code>fasle</code>。</p>
<p>也就是说当前<code>html</code>字符串要么没有父节点要么父节点不是纯文本标签，则接下来就可以依次解析那6种类型的内容了，关于6种类型内容的处理方式前文已经逐个介绍过，此处不再重复。</p>
<h5 id="5-2-parseEndTag函数源码"><a href="#5-2-parseEndTag函数源码" class="headerlink" title="5.2 parseEndTag函数源码"></a>5.2 parseEndTag函数源码</h5><p>接下来我们看一下之前在解析结束标签时遗留的<code>parseEndTag</code>函数，该函数定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseEndTag</span> (<span class="hljs-params">tagName, start, end</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> pos, lowerCasedTagName<br>    <span class="hljs-keyword">if</span> (start == <span class="hljs-literal">null</span>) start = index<br>    <span class="hljs-keyword">if</span> (end == <span class="hljs-literal">null</span>) end = index<br><br>    <span class="hljs-keyword">if</span> (tagName) &#123;<br>      lowerCasedTagName = tagName.toLowerCase()<br>    &#125;<br><br>    <span class="hljs-comment">// Find the closest opened tag of the same type</span><br>    <span class="hljs-keyword">if</span> (tagName) &#123;<br>      <span class="hljs-keyword">for</span> (pos = stack.length - <span class="hljs-number">1</span>; pos &gt;= <span class="hljs-number">0</span>; pos--) &#123;<br>        <span class="hljs-keyword">if</span> (stack[pos].lowerCasedTag === lowerCasedTagName) &#123;<br>          <span class="hljs-keyword">break</span><br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// If no tag name is provided, clean shop</span><br>      pos = <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pos &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// Close all the open elements, up the stack</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = stack.length - <span class="hljs-number">1</span>; i &gt;= pos; i--) &#123;<br>        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp;<br>          (i &gt; pos || !tagName) &amp;&amp;<br>          options.warn<br>        ) &#123;<br>          options.warn(<br>            <span class="hljs-string">`tag &lt;<span class="hljs-subst">$&#123;stack[i].tag&#125;</span>&gt; has no matching end tag.`</span><br>          )<br>        &#125;<br>        <span class="hljs-keyword">if</span> (options.end) &#123;<br>          options.end(stack[i].tag, start, end)<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// Remove the open elements from the stack</span><br>      stack.length = pos<br>      lastTag = pos &amp;&amp; stack[pos - <span class="hljs-number">1</span>].tag<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lowerCasedTagName === <span class="hljs-string">&#x27;br&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (options.start) &#123;<br>        options.start(tagName, [], <span class="hljs-literal">true</span>, start, end)<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lowerCasedTagName === <span class="hljs-string">&#x27;p&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (options.start) &#123;<br>        options.start(tagName, [], <span class="hljs-literal">false</span>, start, end)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (options.end) &#123;<br>        options.end(tagName, start, end)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该函数接收三个参数，分别是结束标签名<code>tagName</code>、结束标签在<code>html</code>字符串中的起始和结束位置<code>start</code>和<code>end</code>。</p>
<p>这三个参数其实都是可选的，根据传参的不同其功能也不同。</p>
<ul>
<li>第一种是三个参数都传递，用于处理普通的结束标签</li>
<li>第二种是只传递<code>tagName</code></li>
<li>第三种是三个参数都不传递，用于处理栈中剩余未处理的标签</li>
</ul>
<p>如果<code>tagName</code>存在，那么就从后往前遍历栈，在栈中寻找与<code>tagName</code>相同的标签并记录其所在的位置<code>pos</code>，如果<code>tagName</code>不存在，则将<code>pos</code>置为0。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (tagName) &#123;<br>    <span class="hljs-keyword">for</span> (pos = stack.length - <span class="hljs-number">1</span>; pos &gt;= <span class="hljs-number">0</span>; pos--) &#123;<br>        <span class="hljs-keyword">if</span> (stack[pos].lowerCasedTag === lowerCasedTagName) &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// If no tag name is provided, clean shop</span><br>    pos = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>接着当<code>pos&gt;=0</code>时，开启一个<code>for</code>循环，从栈顶位置从后向前遍历直到<code>pos</code>处，如果发现<code>stack</code>栈中存在索引大于<code>pos</code>的元素，那么该元素一定是缺少闭合标签的。这是因为在正常情况下，<code>stack</code>栈的栈顶元素应该和当前的结束标签<code>tagName</code> 匹配，也就是说正常的<code>pos</code>应该是栈顶位置，后面不应该再有元素，如果后面还有元素，那么后面的元素就都缺少闭合标签 那么这个时候如果是在非生产环境会抛出警告，告诉你缺少闭合标签。除此之外，还会调用 <code>options.end(stack[i].tag, start, end)</code>立即将其闭合，这是为了保证解析结果的正确性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (pos &gt;= <span class="hljs-number">0</span>) &#123;<br>	<span class="hljs-comment">// Close all the open elements, up the stack</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = stack.length - <span class="hljs-number">1</span>; i &gt;= pos; i--) &#123;<br>		<span class="hljs-keyword">if</span> (i &gt; pos || !tagName ) &#123;<br>			options.warn(<br>				(<span class="hljs-string">&quot;tag &lt;&quot;</span> + (stack[i].tag) + <span class="hljs-string">&quot;&gt; has no matching end tag.&quot;</span>)<br>			);<br>		&#125;<br>		<span class="hljs-keyword">if</span> (options.end) &#123;<br>			options.end(stack[i].tag, start, end);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// Remove the open elements from the stack</span><br>	stack.length = pos;<br>	lastTag = pos &amp;&amp; stack[pos - <span class="hljs-number">1</span>].tag;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后把<code>pos</code>位置以后的元素都从<code>stack</code>栈中弹出，以及把<code>lastTag</code>更新为栈顶元素:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">stack.length = pos;<br>lastTag = pos &amp;&amp; stack[pos - <span class="hljs-number">1</span>].tag;<br></code></pre></td></tr></table></figure>

<p>接着，如果<code>pos</code>没有大于等于0，即当 <code>tagName</code> 没有在 <code>stack</code> 栈中找到对应的开始标签时，<code>pos</code> 为 -1 。那么此时再判断 <code>tagName</code> 是否为<code>br</code> 或<code>p</code>标签，为什么要单独判断这两个标签呢？这是因为在浏览器中如果我们写了如下<code>HTML</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>​    浏览器会自动把<code>&lt;/br&gt;</code>标签解析为正常的 <br>标签，而对于<code>&lt;/p&gt;</code>浏览器则自动将其补全为<code>&lt;p&gt;&lt;/p&gt;</code>，所以<code>Vue</code>为了与浏览器对这两个标签的行为保持一致，故对这两个便签单独判断处理，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">f (lowerCasedTagName === <span class="hljs-string">&#x27;br&#x27;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (options.start) &#123;<br>        options.start(tagName, [], <span class="hljs-literal">true</span>, start, end)  <span class="hljs-comment">// 创建&lt;br&gt;AST节点</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 补全p标签并创建AST节点</span><br><span class="hljs-keyword">if</span> (lowerCasedTagName === <span class="hljs-string">&#x27;p&#x27;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (options.start) &#123;<br>        options.start(tagName, [], <span class="hljs-literal">false</span>, start, end)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (options.end) &#123;<br>        options.end(tagName, start, end)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上就是对结束标签的解析与处理。</p>
<p>另外，在<code>while</code>循环后面还有一行代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">parseEndTag()<br></code></pre></td></tr></table></figure>

<p>这行代码执行的时机是<code>html === last</code>，即<code>html</code>字符串中的标签格式有误时会跳出<code>while</code>循环，此时就会执行这行代码，这行代码是调用<code>parseEndTag</code>函数并不传递任何参数，前面我们说过如果<code>parseEndTag</code>函数不传递任何参数是用于处理栈中剩余未处理的标签。这是因为如果不传递任何函数，此时<code>parseEndTag</code>函数里的<code>pos</code>就为0，那么<code>pos&gt;=0</code>就会恒成立，那么就会逐个警告缺少闭合标签，并调用 <code>options.end</code>将其闭合。</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>本篇文章主要介绍了<code>HTML</code>解析器的工作流程以及工作原理，文章比较长，但是逻辑并不复杂。</p>
<p>首先介绍了<code>HTML</code>解析器的工作流程，一句话概括就是：一边解析不同的内容一边调用对应的钩子函数生成对应的<code>AST</code>节点，最终完成将整个模板字符串转化成<code>AST</code>。</p>
<p>接着介绍了<code>HTML</code>解析器是如何解析用户所写的模板字符串中各种类型的内容的，把各种类型的解析方式都分别进行了介绍。</p>
<p>其次，介绍了在解析器内维护了一个栈，用来保证构建的<code>AST</code>节点层级与真正<code>DOM</code>层级一致。</p>
<p>了解了思想之后，最后回归源码，学习了源码中一些处理细节的地方。</p>
<h5 id="文本解析器"><a href="#文本解析器" class="headerlink" title="文本解析器"></a>文本解析器</h5><p>在上篇文章中我们说了，当<code>HTML</code>解析器解析到文本内容时会调用4个钩子函数中的<code>chars</code>函数来创建文本型的<code>AST</code>节点，并且也说了在<code>chars</code>函数中会根据文本内容是否包含变量再细分为创建含有变量的<code>AST</code>节点和不包含变量的<code>AST</code>节点，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 当解析到标签的文本时，触发chars</span><br>chars (text) &#123;<br>  <span class="hljs-keyword">if</span>(res = parseText(text))&#123;<br>       <span class="hljs-keyword">let</span> element = &#123;<br>           type: <span class="hljs-number">2</span>,<br>           expression: res.expression,<br>           tokens: res.tokens,<br>           text<br>       &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-keyword">let</span> element = &#123;<br>           type: <span class="hljs-number">3</span>,<br>           text<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面代码中可以看到，创建含有变量的<code>AST</code>节点时节点的<code>type</code>属性为2，并且相较于不包含变量的<code>AST</code>节点多了两个属性：<code>expression</code>和<code>tokens</code>。那么如何来判断文本里面是否包含变量以及多的那两个属性是什么呢？这就涉及到文本解析器了，当<code>Vue</code>用<code>HTML</code>解析器解析出文本时，再将解析出来的文本内容传给文本解析器，最后由文本解析器解析该段文本里面是否包含变量以及如果包含变量时再解析<code>expression</code>和<code>tokens</code>。那么接下来，本篇文章就来分析一下文本解析器都干了些什么。</p>
<p>撸码一时爽，一直撸码一直爽！！！</p>
]]></content>
      <tags>
        <tag>vue源码理解——模板编译篇</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码理解——虚拟DOM篇</title>
    <url>/2021/03/18/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A32/</url>
    <content><![CDATA[<p>虚拟DOM，这个名词作为当下的前端开发人员你一定不会陌生，至少会略有耳闻，但不会闻所未闻吧。这也是现在求职面试考察中非常高频的一个考点了。因为在当下的前端三大框架中关于虚拟DOM或多或少都有所涉及，那么接下来，我们就从源码角度出发，看看<code>Vue</code>中的虚拟DOM时怎样的。</p>
<h4 id="虚拟DOM简介"><a href="#虚拟DOM简介" class="headerlink" title="虚拟DOM简介"></a>虚拟DOM简介</h4><p>由于本系列文章是针对<code>Vue</code>源码深入学习的，所以着重分析在<code>Vue</code>中对虚拟DOM是如何实现的，而对于虚拟DOM本身这个概念不做大篇幅的展开讨论，仅从以下几个问题简单介绍：</p>
<p>1.什么是虚拟DOM？</p>
<p>所谓虚拟DOM，就是用一个<code>JS</code>对象来描述一个<code>DOM</code>节点，像如下示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;a&quot;</span> id=<span class="hljs-string">&quot;b&quot;</span>&gt;我是内容&lt;/div&gt;<br><br>&#123;<br>  tag:<span class="hljs-string">&#x27;div&#x27;</span>,        <span class="hljs-comment">// 元素标签</span><br>  attrs:&#123;           <span class="hljs-comment">// 属性</span><br>    class:&#x27;a&#x27;,<br>    id:<span class="hljs-string">&#x27;b&#x27;</span><br>  &#125;,<br>  text:<span class="hljs-string">&#x27;我是内容&#x27;</span>,  <span class="hljs-comment">// 文本内容</span><br>  children:[]       <span class="hljs-comment">// 子元素</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们把组成一个<code>DOM</code>节点的必要东西通过一个<code>JS</code>对象表示出来，那么这个<code>JS</code>对象就可以用来描述这个<code>DOM</code>节点，我们把这个<code>JS</code>对象就称为是这个真实<code>DOM</code>节点的虚拟<code>DOM</code>节点</p>
<p>2.为什么要有虚拟DOM？</p>
<p>我们知道，<code>Vue</code>是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作<code>DOM</code>,而操作真实<code>DOM</code>又是非常耗费性能的，这是因为浏览器的标准就把 <code>DOM</code> 设计的非常复杂，所以一个真正的 <code>DOM</code> 元素是非常庞大的，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>)<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> div) &#123;<br>  str += key + <span class="hljs-string">&#x27;&#x27;</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(str)<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210422112653087.png" alt="image-20210422112653087"></p>
<p>上图中我们打印一个简单的空<code>div</code>标签，就打印出这么多东西，更不用说复杂的、深嵌套的<code>DOM</code>节点了。由此可见，直接操作真实<code>DOM</code>是非常消耗性能的。</p>
<p>那么有没有什么解决方案呢？当然是有的。我们可以用<code>JS</code>的计算性能来换取操作<code>DOM</code>所消耗的性能。</p>
<p>既然我们逃不掉操作<code>DOM</code>这道坎,但是我们可以尽可能少的操作<code>DOM</code>。那如何在更新视图的时候尽可能少的操作<code>DOM</code>呢？最直观的思路就是我们不要盲目的去更新视图，而是通过对比数据变化前后的状态，计算出视图中哪些地方需要更新，只更新需要更新的地方，而不需要更新的地方则不需关心，这样我们就可以尽可能少的操作<code>DOM</code>了。这也就是上面所说的用<code>JS</code>的计算性能来换取操作<code>DOM</code>的性能。</p>
<p>我们可以用<code>JS</code>模拟出一个<code>DOM</code>节点，称之为虚拟<code>DOM</code>节点。当数据发生变化时，我们对比变化前后的虚拟<code>DOM</code>节点，通过<code>DOM-Diff</code>算法计算出需要更新的地方，然后去更新需要更新的视图。</p>
<p>这就是虚拟<code>DOM</code>产生的原因以及最大的用途。</p>
<h5 id="Vue中的虚拟DOM"><a href="#Vue中的虚拟DOM" class="headerlink" title="Vue中的虚拟DOM"></a>Vue中的虚拟DOM</h5><p>前文我们介绍了虚拟<code>DOM</code>的概念以及为什么要有虚拟<code>DOM</code>，那么在<code>Vue</code>中虚拟<code>DOM</code>是怎么实现的呢？接下来，我们从源码出发，深入学习一下。</p>
<h6 id="VNode类"><a href="#VNode类" class="headerlink" title="VNode类"></a>VNode类</h6><p>我们说了，虚拟<code>DOM</code>就是用<code>JS</code>来描述一个真实的<code>DOM</code>节点。而在<code>Vue</code>中就存在了一个<code>VNode</code>类，通过这个类，我们就可以实例化出不同类型的虚拟<code>DOM</code>节点，源码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VNode</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span> (<br>    tag?: string,<br>    data?: VNodeData,<br>    children?: ?Array&lt;VNode&gt;,<br>    text?: string,<br>    elm?: Node,<br>    context?: Component,<br>    componentOptions?: VNodeComponentOptions,<br>    asyncFactory?: Function<br>  ) &#123;<br>    <span class="hljs-built_in">this</span>.tag = tag                                <span class="hljs-comment">/*当前节点的标签名*/</span><br>    <span class="hljs-built_in">this</span>.data = data        <span class="hljs-comment">/*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/</span><br>    <span class="hljs-built_in">this</span>.children = children  <span class="hljs-comment">/*当前节点的子节点，是一个数组*/</span><br>    <span class="hljs-built_in">this</span>.text = text     <span class="hljs-comment">/*当前节点的文本*/</span><br>    <span class="hljs-built_in">this</span>.elm = elm       <span class="hljs-comment">/*当前虚拟节点对应的真实dom节点*/</span><br>    <span class="hljs-built_in">this</span>.ns = <span class="hljs-literal">undefined</span>            <span class="hljs-comment">/*当前节点的名字空间*/</span><br>    <span class="hljs-built_in">this</span>.context = context          <span class="hljs-comment">/*当前组件节点对应的Vue实例*/</span><br>    <span class="hljs-built_in">this</span>.fnContext = <span class="hljs-literal">undefined</span>       <span class="hljs-comment">/*函数式组件对应的Vue实例*/</span><br>    <span class="hljs-built_in">this</span>.fnOptions = <span class="hljs-literal">undefined</span><br>    <span class="hljs-built_in">this</span>.fnScopeId = <span class="hljs-literal">undefined</span><br>    <span class="hljs-built_in">this</span>.key = data &amp;&amp; data.key           <span class="hljs-comment">/*节点的key属性，被当作节点的标志，用以优化*/</span><br>    <span class="hljs-built_in">this</span>.componentOptions = componentOptions   <span class="hljs-comment">/*组件的option选项*/</span><br>    <span class="hljs-built_in">this</span>.componentInstance = <span class="hljs-literal">undefined</span>       <span class="hljs-comment">/*当前节点对应的组件的实例*/</span><br>    <span class="hljs-built_in">this</span>.parent = <span class="hljs-literal">undefined</span>           <span class="hljs-comment">/*当前节点的父节点*/</span><br>    <span class="hljs-built_in">this</span>.raw = <span class="hljs-literal">false</span>         <span class="hljs-comment">/*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/</span><br>    <span class="hljs-built_in">this</span>.isStatic = <span class="hljs-literal">false</span>         <span class="hljs-comment">/*静态节点标志*/</span><br>    <span class="hljs-built_in">this</span>.isRootInsert = <span class="hljs-literal">true</span>      <span class="hljs-comment">/*是否作为跟节点插入*/</span><br>    <span class="hljs-built_in">this</span>.isComment = <span class="hljs-literal">false</span>             <span class="hljs-comment">/*是否为注释节点*/</span><br>    <span class="hljs-built_in">this</span>.isCloned = <span class="hljs-literal">false</span>           <span class="hljs-comment">/*是否为克隆节点*/</span><br>    <span class="hljs-built_in">this</span>.isOnce = <span class="hljs-literal">false</span>                <span class="hljs-comment">/*是否有v-once指令*/</span><br>    <span class="hljs-built_in">this</span>.asyncFactory = asyncFactory<br>    <span class="hljs-built_in">this</span>.asyncMeta = <span class="hljs-literal">undefined</span><br>    <span class="hljs-built_in">this</span>.isAsyncPlaceholder = <span class="hljs-literal">false</span><br>  &#125;<br><br>  get child (): Component | <span class="hljs-keyword">void</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.componentInstance<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码中可以看出：<code>VNode</code>类中包含了描述一个真实<code>DOM</code>节点所需要的一系列属性，如<code>tag</code>表示节点的标签名，<code>text</code>表示节点中包含的文本，<code>children</code>表示该节点包含的子节点等。通过属性之间不同的搭配，就可以描述出各种类型的真实<code>DOM</code>节点。</p>
<h5 id="VNode的类型"><a href="#VNode的类型" class="headerlink" title="VNode的类型"></a>VNode的类型</h5><p>上一小节最后我们说了，通过属性之间不同的搭配，<code>VNode</code>类可以描述出各种类型的真实<code>DOM</code>节点。那么它都可以描述出哪些类型的节点呢？通过阅读源码，可以发现通过不同属性的搭配，可以描述出以下几种类型的节点。</p>
<ul>
<li>注释节点</li>
<li>文本节点</li>
<li>元素节点</li>
<li>组件节点</li>
<li>函数式组件节点</li>
<li>克隆节点</li>
</ul>
<p>1.注释节点</p>
<p>描述起来相对就非常简单了，它只需两个属性就够了，源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建注释节点</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createEmptyVNode = <span class="hljs-function">(<span class="hljs-params">text: string = <span class="hljs-string">&#x27;&#x27;</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> VNode()<br>  node.text = text<br>  node.isComment = <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">return</span> node<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面代码中可以看到，描述一个注释节点只需两个属性，分别是：<code>text</code>和<code>isComment</code>。其中<code>text</code>属性表示具体的注释信息，<code>isComment</code>是一个标志，用来标识一个节点是否是注释节点。</p>
<p>2.文本节点</p>
<p>文本节点描述起来比注释节点更简单，因为它只需要一个属性，那就是<code>text</code>属性，用来表示具体的文本信息。源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建文本节点</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createTextVNode</span> (<span class="hljs-params">val: string | number</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> VNode(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-built_in">String</span>(val))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3.克隆节点</p>
<p>克隆节点就是把一个已经存在的节点复制一份出来，它主要是为了做模板编译优化时使用，这个后面我们会说到。关于克隆节点的描述，源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建克隆节点</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneVNode</span> (<span class="hljs-params">vnode: VNode</span>): <span class="hljs-title">VNode</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> cloned = <span class="hljs-keyword">new</span> VNode(<br>    vnode.tag,<br>    vnode.data,<br>    vnode.children,<br>    vnode.text,<br>    vnode.elm,<br>    vnode.context,<br>    vnode.componentOptions,<br>    vnode.asyncFactory<br>  )<br>  cloned.ns = vnode.ns<br>  cloned.isStatic = vnode.isStatic<br>  cloned.key = vnode.key<br>  cloned.isComment = vnode.isComment<br>  cloned.fnContext = vnode.fnContext<br>  cloned.fnOptions = vnode.fnOptions<br>  cloned.fnScopeId = vnode.fnScopeId<br>  cloned.asyncMeta = vnode.asyncMeta<br>  cloned.isCloned = <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">return</span> cloned<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面代码中可以看到，克隆节点就是把已有节点的属性全部复制到新节点中，而现有节点和新克隆得到的节点之间唯一的不同就是克隆得到的节点<code>isCloned</code>为<code>true</code></p>
<p>4.元素节点</p>
<p>相比之下，元素节点更贴近于我们通常看到的真实<code>DOM</code>节点，它有描述节点标签名词的<code>tag</code>属性，描述节点属性如<code>class</code>、<code>attributes</code>等的<code>data</code>属性，有描述包含的子节点信息的<code>children</code>属性等。由于元素节点所包含的情况相比而言比较复杂，源码中没有像前三种节点一样直接写死（当然也不可能写死），那就举个简单例子说明一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 真实DOM节点</span><br>&lt;div id=<span class="hljs-string">&#x27;a&#x27;</span>&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>难凉热血<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>&lt;/div&gt;<br><br><span class="hljs-comment">// VNode节点</span><br>&#123;<br>  tag:<span class="hljs-string">&#x27;div&#x27;</span>,<br>  data:&#123;&#125;,<br>  children:[<br>    &#123;<br>      tag:<span class="hljs-string">&#x27;span&#x27;</span>,<br>      text:<span class="hljs-string">&#x27;难凉热血&#x27;</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以看到，真实<code>DOM</code>节点中:<code>div</code>标签里面包含了一个<code>span</code>标签，而<code>span</code>标签里面有一段文本。反应到<code>VNode</code>节点上就如上所示:<code>tag</code>表示标签名，<code>data</code>表示标签的属性<code>id</code>等，<code>children</code>表示子节点数组。</p>
<p>5.组件节点</p>
<p>组件节点除了有元素节点具有的属性之外，它还有两个特有的属性：</p>
<ul>
<li>componentOptions :组件的option选项，如组件的<code>props</code>等</li>
<li>componentInstance :当前组件节点对应的<code>Vue</code>实例</li>
</ul>
<p>6.函数式组件节点</p>
<p>函数式组件节点相较于组件节点，它又有两个特有的属性：</p>
<ul>
<li>fnContext:函数式组件对应的Vue实例</li>
<li>fnOptions: 组件的option选项</li>
</ul>
<p>以上就是<code>VNode</code>可以描述的多种节点类型，它们本质上都是<code>VNode</code>类的实例，只是在实例化的时候传入的属性参数不同而已。</p>
<h6 id="VNode的作用"><a href="#VNode的作用" class="headerlink" title="VNode的作用:"></a>VNode的作用:</h6><p>说了这么多，那么<code>VNode</code>在<code>Vue</code>的整个虚拟<code>DOM</code>过程起了什么作用呢？</p>
<p>其实<code>VNode</code>的作用是相当大的。我们在视图渲染之前，把写好的<code>template</code>模板先编译成<code>VNode</code>并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的<code>VNode</code>与前一次缓存下来的<code>VNode</code>进行对比，找出差异，然后有差异的<code>VNode</code>对应的真实<code>DOM</code>节点就是需要重新渲染的节点，最后根据有差异的<code>VNode</code>创建出真实的<code>DOM</code>节点再插入到视图中，最终完成一次视图更新。</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>本章首先介绍了虚拟<code>DOM</code>的一些基本概念和为什么要有虚拟<code>DOM</code>，其实说白了就是以<code>JS</code>的计算性能来换取操作真实<code>DOM</code>所消耗的性能。接着从源码角度我们知道了在<code>Vue</code>中是通过<code>VNode</code>类来实例化出不同类型的虚拟<code>DOM</code>节点，并且学习了不同类型节点生成的属性的不同，所谓不同类型的节点其本质还是一样的，都是<code>VNode</code>类的实例，只是在实例化时传入的属性参数不同罢了。最后探究了<code>VNode</code>的作用，有了数据变化前后的<code>VNode</code>，我们才能进行后续的<code>DOM-Diff</code>找出差异，最终做到只更新有差异的视图，从而达到尽可能少的操作真实<code>DOM</code>的目的，以节省性能。</p>
<h5 id="vue虚拟dom的diff"><a href="#vue虚拟dom的diff" class="headerlink" title="vue虚拟dom的diff"></a>vue虚拟dom的diff</h5><p>在上一篇文章介绍<code>VNode</code>的时候我们说了，<code>VNode</code>最大的用途就是在数据变化前后生成真实<code>DOM</code>对应的虚拟<code>DOM</code>节点，然后就可以对比新旧两份<code>VNode</code>，找出差异所在，然后更新有差异的<code>DOM</code>节点，最终达到以最少操作真实<code>DOM</code>更新视图的目的。而对比新旧两份<code>VNode</code>并找出差异的过程就是所谓的<code>DOM-Diff</code>过程。<code>DOM-Diff</code>算法是整个虚拟<code>DOM</code>的核心所在，那么接下来，我们就以源码出发，深入研究一下<code>Vue</code>中的<code>DOM-Diff</code>过程是怎样的。</p>
<p>在<code>Vue</code>中，把 <code>DOM-Diff</code>过程叫做<code>patch</code>过程。patch,意为“补丁”，即指对旧的<code>VNode</code>修补，打补丁从而得到新的<code>VNode</code>，非常形象哈。那不管叫什么，其本质都是把对比新旧两份<code>VNode</code>的过程。我们在下面研究<code>patch</code>过程的时候，一定把握住这样一个思想：所谓旧的<code>VNode</code>(即<code>oldVNode</code>)就是数据变化之前视图所对应的虚拟<code>DOM</code>节点，而新的<code>VNode</code>是数据变化之后将要渲染的新的视图所对应的虚拟<code>DOM</code>节点，所以我们要以生成的新的<code>VNode</code>为基准，对比旧的<code>oldVNode</code>，如果新的<code>VNode</code>上有的节点而旧的<code>oldVNode</code>上没有，那么就在旧的<code>oldVNode</code>上加上去；如果新的<code>VNode</code>上没有的节点而旧的<code>oldVNode</code>上有，那么就在旧的<code>oldVNode</code>上去掉；如果某些节点在新的<code>VNode</code>和旧的<code>oldVNode</code>上都有，那么就以新的<code>VNode</code>为准，更新旧的<code>oldVNode</code>，从而让新旧<code>VNode</code>相同。</p>
<p>总之一句话：<strong>以新的VNode为基准，改造旧的oldVNode使之成为跟新的VNode一样，这就是patch过程要干的事</strong>。</p>
<p>说了这么多，听起来感觉好像很复杂的样子，其实不然，我们仔细想想，整个<code>patch</code>无非就是干三件事：</p>
<ul>
<li>创建节点：新的<code>VNode</code>中有而旧的<code>oldVNode</code>中没有，就在旧的<code>oldVNode</code>中创建。</li>
<li>删除节点：新的<code>VNode</code>中没有而旧的<code>oldVNode</code>中有，就从旧的<code>oldVNode</code>中删除。</li>
<li>更新节点：新的<code>VNode</code>和旧的<code>oldVNode</code>中都有，就以新的<code>VNode</code>为准，更新旧的<code>oldVNode</code>。</li>
</ul>
<p>OK，到这里，你就对<code>Vue</code>中的<code>patch</code>过程理解了一半了，接下来，我们就逐个分析，看<code>Vue</code>对于以上三件事都是怎么做的。</p>
<h6 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h6><p>上篇文章中我们分析了，<code>VNode</code>类可以描述6种类型的节点，而实际上只有3种类型的节点能够被创建并插入到<code>DOM</code>中，它们分别是：元素节点、文本节点、注释节点。所以<code>Vue</code>在创建节点的时候会判断在新的<code>VNode</code>中有而旧的<code>oldVNode</code>中没有的这个节点是属于哪种类型的节点，从而调用不同的方法创建并插入到<code>DOM</code>中。</p>
<p>其实判断起来也不难，因为这三种类型的节点其特点非常明显，在源码中是怎么判断的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 源码位置: /src/core/vdom/patch.js</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElm</span> (<span class="hljs-params">vnode, parentElm, refElm</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> data = vnode.data<br>    <span class="hljs-keyword">const</span> children = vnode.children<br>    <span class="hljs-keyword">const</span> tag = vnode.tag<br>    <span class="hljs-keyword">if</span> (isDef(tag)) &#123;<br>      	vnode.elm = nodeOps.createElement(tag, vnode)   <span class="hljs-comment">// 创建元素节点</span><br>        createChildren(vnode, children, insertedVnodeQueue) <span class="hljs-comment">// 创建元素节点的子节点</span><br>        insert(parentElm, vnode.elm, refElm)       <span class="hljs-comment">// 插入到DOM中</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isTrue(vnode.isComment)) &#123;<br>      vnode.elm = nodeOps.createComment(vnode.text)  <span class="hljs-comment">// 创建注释节点</span><br>      insert(parentElm, vnode.elm, refElm)           <span class="hljs-comment">// 插入到DOM中</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      vnode.elm = nodeOps.createTextNode(vnode.text)  <span class="hljs-comment">// 创建文本节点</span><br>      insert(parentElm, vnode.elm, refElm)           <span class="hljs-comment">// 插入到DOM中</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>从上面代码中，我们可以看出：</p>
<ul>
<li>判断是否为元素节点只需判断该<code>VNode</code>节点是否有<code>tag</code>标签即可。如果有<code>tag</code>属性即认为是元素节点，则调用<code>createElement</code>方法创建元素节点，通常元素节点还会有子节点，那就递归遍历创建所有子节点，将所有子节点创建好之后<code>insert</code>插入到当前元素节点里面，最后把当前元素节点插入到<code>DOM</code>中。</li>
<li>判断是否为注释节点，只需判断<code>VNode</code>的<code>isComment</code>属性是否为<code>true</code>即可，若为<code>true</code>则为注释节点，则调用<code>createComment</code>方法创建注释节点，再插入到<code>DOM</code>中。</li>
<li>如果既不是元素节点，也不是注释节点，那就认为是文本节点，则调用<code>createTextNode</code>方法创建文本节点，再插入到<code>DOM</code>中。</li>
</ul>
<blockquote>
<p>代码中的<code>nodeOps</code>是<code>Vue</code>为了跨平台兼容性，对所有节点操作进行了封装，例如<code>nodeOps.createTextNode()</code>在浏览器端等同于<code>document.createTextNode()</code></p>
</blockquote>
<p>以上就完成了创建节点的操作，其完整流程图如下：</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425121000760.png" alt="image-20210425121000760"></p>
<h6 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h6><p>如果某些节点再新的<code>VNode</code>中没有而在旧的<code>oldVNode</code>中有，那么就需要把这些节点从旧的<code>oldVNode</code>中删除。删除节点非常简单，只需在要删除节点的父元素上调用<code>removeChild</code>方法即可。源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeNode</span> (<span class="hljs-params">el</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> parent = nodeOps.parentNode(el)  <span class="hljs-comment">// 获取父节点</span><br>    <span class="hljs-keyword">if</span> (isDef(parent)) &#123;<br>      nodeOps.removeChild(parent, el)  <span class="hljs-comment">// 调用父节点的removeChild方法</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<h6 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h6><p>创建节点和删除节点都比较简单，而更新节点就相对较为复杂一点了，其实也不算多复杂，只要理清逻辑就能理解了。</p>
<p>更新节点就是当某些节点在新的<code>VNode</code>和旧的<code>oldVNode</code>中都有时，我们就需要细致比较一下，找出不一样的地方进行更新。</p>
<p>介绍更新节点之前，我们先介绍一个小的概念，就是什么是静态节点？我们看个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是不会变化的文字<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>面这个节点里面只包含了纯文字，没有任何可变的变量，这也就是说，不管数据再怎么变化，只要这个节点第一次渲染了，那么它以后就永远不会发生变化，这是因为它不包含任何变量，所以数据发生任何变化都与它无关。我们把这种节点称之为静态节点。</p>
<p>OK，有了这个概念以后，我们开始更新节点。更新节点的时候我们需要对以下3种情况进行判断并分别处理：</p>
<ol>
<li><p>如果<code>VNode</code>和<code>oldVNode</code>均为静态节点</p>
<p>我们说了，静态节点无论数据发生任何变化都与它无关，所以都为静态节点的话则直接跳过，无需处理。</p>
</li>
<li><p>如果<code>VNode</code>是文本节点</p>
<p>如果<code>VNode</code>是文本节点即表示这个节点内只包含纯文本，那么只需看<code>oldVNode</code>是否也是文本节点，如果是，那就比较两个文本是否不同，如果不同则把<code>oldVNode</code>里的文本改成跟<code>VNode</code>的文本一样。如果<code>oldVNode</code>不是文本节点，那么不论它是什么，直接调用<code>setTextNode</code>方法把它改成文本节点，并且文本内容跟<code>VNode</code>相同。</p>
</li>
<li><p>如果<code>VNode</code>是元素节点</p>
<p>如果<code>VNode</code>是元素节点，则又细分以下两种情况：</p>
<ul>
<li><p>该节点包含子节点</p>
<p>如果新的节点内包含了子节点，那么此时要看旧的节点是否包含子节点，如果旧的节点里也包含了子节点，那就需要递归对比更新子节点；如果旧的节点里不包含子节点，那么这个旧节点有可能是空节点或者是文本节点，如果旧的节点是空节点就把新的节点里的子节点创建一份然后插入到旧的节点里面，如果旧的节点是文本节点，则把文本清空，然后把新的节点里的子节点创建一份然后插入到旧的节点里面。</p>
</li>
<li><p>该节点不包含子节点</p>
<p>如果该节点不包含子节点，同时它又不是文本节点，那就说明该节点是个空节点，那就好办了，不管旧节点之前里面都有啥，直接清空即可。</p>
</li>
</ul>
</li>
</ol>
<p>OK，处理完以上3种情况，更新节点就算基本完成了，接下来我们看下源码中具体是怎么实现的，源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 更新节点</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">patchVnode</span> (<span class="hljs-params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;<br>  <span class="hljs-comment">// vnode与oldVnode是否完全一样？若是，退出程序</span><br>  <span class="hljs-keyword">if</span> (oldVnode === vnode) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> elm = vnode.elm = oldVnode.elm<br><br>  <span class="hljs-comment">// vnode与oldVnode是否都是静态节点？若是，退出程序</span><br>  <span class="hljs-keyword">if</span> (isTrue(vnode.isStatic) &amp;&amp;<br>    isTrue(oldVnode.isStatic) &amp;&amp;<br>    vnode.key === oldVnode.key &amp;&amp;<br>    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))<br>  ) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-keyword">const</span> oldCh = oldVnode.children<br>  <span class="hljs-keyword">const</span> ch = vnode.children<br>  <span class="hljs-comment">// vnode有text属性？若没有：</span><br>  <span class="hljs-keyword">if</span> (isUndef(vnode.text)) &#123;<br>    <span class="hljs-comment">// vnode的子节点与oldVnode的子节点是否都存在？</span><br>    <span class="hljs-keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;<br>      <span class="hljs-comment">// 若都存在，判断子节点是否相同，不同则更新子节点</span><br>      <span class="hljs-keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)<br>    &#125;<br>    <span class="hljs-comment">// 若只有vnode的子节点存在</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isDef(ch)) &#123;<br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 判断oldVnode是否有文本？</span><br><span class="hljs-comment">       * 若没有，则把vnode的子节点添加到真实DOM中</span><br><span class="hljs-comment">       * 若有，则清空Dom中的文本，再把vnode的子节点添加到真实DOM中</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="hljs-string">&#x27;&#x27;</span>)<br>      addVnodes(elm, <span class="hljs-literal">null</span>, ch, <span class="hljs-number">0</span>, ch.length - <span class="hljs-number">1</span>, insertedVnodeQueue)<br>    &#125;<br>    <span class="hljs-comment">// 若只有oldnode的子节点存在</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isDef(oldCh)) &#123;<br>      <span class="hljs-comment">// 清空DOM中的子节点</span><br>      removeVnodes(elm, oldCh, <span class="hljs-number">0</span>, oldCh.length - <span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-comment">// 若vnode和oldnode都没有子节点，但是oldnode中有文本</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isDef(oldVnode.text)) &#123;<br>      <span class="hljs-comment">// 清空oldnode文本</span><br>      nodeOps.setTextContent(elm, <span class="hljs-string">&#x27;&#x27;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 上面两个判断一句话概括就是，如果vnode中既没有text，也没有子节点，那么对应的oldnode中有什么就清空什么</span><br>  &#125;<br>  <span class="hljs-comment">// 若有，vnode的text属性与oldVnode的text属性是否相同？</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldVnode.text !== vnode.text) &#123;<br>    <span class="hljs-comment">// 若不相同：则用vnode的text替换真实DOM的文本</span><br>    nodeOps.setTextContent(elm, vnode.text)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码里注释已经写得很清晰了，接下来我们画流程图来梳理一下整个过程，流程图如下：</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425121148769.png" alt="image-20210425121148769"></p>
<p>通过对照着流程图以及代码，相信更新节点这部分逻辑你很容易就能理解了。s</p>
<p>另外，你可能注意到了，如果新旧<code>VNode</code>里都包含了子节点，那么对于子节点的更新在代码里调用了<code>updateChildren</code>方法，而这个方法的逻辑到底是怎样的我们放在下一篇文章中展开学习。</p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>在本篇文章中我们介绍了<code>Vue</code>中的<code>DOM-Diff</code>算法：patch过程。我们先介绍了算法的整个思想流程，然后通过梳理算法思想，了解了整个<code>patch</code>过程干了三件事，分别是：创建节点，删除节点，更新节点。并且对每件事情都对照源码展开了细致的学习，画出了其逻辑流程图。另外对于更新节点中，如果新旧<code>VNode</code>里都包含了子节点，我们就需要细致的去更新子节点，关于更新子节点的过程我们在下一篇文章中展开学习。</p>
<p>在上一篇文章中，我们了解了<code>Vue</code>中的<code>patch</code>过程，即<code>DOM-Diff</code>算法。并且知道了在<code>patch</code>过程中基本会干三件事，分别是：创建节点，删除节点和更新节点。创建节点和删除节点都比较简单，而更新节点因为要处理各种可能出现的情况所以逻辑略微复杂一些，但是没关系，我们通过分析过程，对照源码，画逻辑流程图来帮助我们理解了其中的过程。最后我们还遗留了一个问题，那就是在更新节点过程中，新旧<code>VNode</code>可能都包含有子节点，对于子节点的对比更新会有额外的一些逻辑，那么在本篇文章中我们就来学习在<code>Vue</code>中是怎么对比更新子节点的。</p>
<h6 id="更新子节点："><a href="#更新子节点：" class="headerlink" title="更新子节点："></a>更新子节点：</h6><p>当新的<code>VNode</code>与旧的<code>oldVNode</code>都是元素节点并且都包含子节点时，那么这两个节点的<code>VNode</code>实例上的<code>children</code>属性就是所包含的子节点数组。我们把新的<code>VNode</code>上的子节点数组记为<code>newChildren</code>，把旧的<code>oldVNode</code>上的子节点数组记为<code>oldChildren</code>，我们把<code>newChildren</code>里面的元素与<code>oldChildren</code>里的元素一一进行对比，对比两个子节点数组肯定是要通过循环，外层循环<code>newChildren</code>数组，内层循环<code>oldChildren</code>数组，每循环外层<code>newChildren</code>数组里的一个子节点，就去内层<code>oldChildren</code>数组里找看有没有与之相同的子节点，伪代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newChildren.length; i++) &#123;<br>  <span class="hljs-keyword">const</span> newChild = newChildren[i];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; oldChildren.length; j++) &#123;<br>    <span class="hljs-keyword">const</span> oldChild = oldChildren[j];<br>    <span class="hljs-keyword">if</span> (newChild === oldChild) &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么以上这个过程将会存在以下四种情况：</p>
<ul>
<li><p>创建子节点</p>
<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找不到与之相同的子节点，那么说明<code>newChildren</code>里面的这个子节点是之前没有的，是需要此次新增的节点，那么就创建子节点。</p>
</li>
<li><p>删除子节点</p>
<p>如果把<code>newChildren</code>里面的每一个子节点都循环完毕后，发现在<code>oldChildren</code>还有未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除。</p>
</li>
<li><p>移动子节点</p>
<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以<code>newChildren</code>里子节点的位置为基准，调整<code>oldChildren</code>里该节点的位置，使之与在<code>newChildren</code>里的位置相同。</p>
</li>
<li><p>更新节点</p>
<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找到了与之相同的子节点，并且所处的位置也相同，那么就更新<code>oldChildren</code>里该节点，使之与<code>newChildren</code>里的该节点相同。</p>
</li>
</ul>
<p>OK，到这里，逻辑就相对清晰了，接下来我们只需分门别类的处理这四种情况就好了。</p>
<h6 id="创建子节点"><a href="#创建子节点" class="headerlink" title="创建子节点"></a>创建子节点</h6><p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找不到与之相同的子节点，那么说明<code>newChildren</code>里面的这个子节点是之前没有的，是需要此次新增的节点，那么我们就创建这个节点，创建好之后再把它插入到<code>DOM</code>中合适的位置。</p>
<p>创建节点这个很容易，我们在上一篇文章的第三章已经介绍过了，这里就不再赘述了。</p>
<p>那么创建好之后如何插入到<code>DOM</code>中的合适的位置呢？显然，把节点插入到<code>DOM</code>中是很容易的，找到合适的位置是关键。接下来我们分析一下如何找这个合适的位置。我们看下面这个图：</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425133824295.png" alt="image-20210425133824295"></p>
<p>上图中左边是新的<code>VNode</code>，右边是旧的<code>oldVNode</code>，同时也是真实的<code>DOM</code>。这个图意思是当我们循环<code>newChildren</code>数组里面的子节点，前两个子节点都在<code>oldChildren</code>里找到了与之对应的子节点，那么我们将其处理，处理过后把它们标志为已处理，当循环到<code>newChildren</code>数组里第三个子节点时，发现在<code>oldChildren</code>里找不到与之对应的子节点，那么我们就需要创建这个节点，创建好之后我们发现这个节点本是<code>newChildren</code>数组里左起第三个子节点，那么我们就把创建好的节点插入到真实<code>DOM</code>里的第三个节点位置，也就是所有已处理节点之后，OK，此时我们拍手称快，所有已处理节点之后就是我们要找的合适的位置，但是真的是这样吗？我们再来看下面这个图：</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425134249593.png" alt="image-20210425134249593"></p>
<p>假如我们按照上面的方法把第三个节点插入到所有已处理节点之后，此时如果第四个节点也在<code>oldChildren</code>里找不到与之对应的节点，也是需要创建的节点，那么当我们把第四个节点也按照上面的说的插入到已处理节点之后，发现怎么插入到第三个位置了，可明明这个节点在<code>newChildren</code>数组里是第四个啊！</p>
<p>这就是问题所在，其实，我们应该把新创建的节点插入到所有未处理节点之前，这样以来逻辑才正确。后面不管有多少个新增的节点，每一个都插入到所有未处理节点之前，位置才不会错。</p>
<p>所以，<strong>合适的位置是所有未处理节点之前，而并非所有已处理节点之后</strong>。</p>
<h6 id="删除子节点"><a href="#删除子节点" class="headerlink" title="删除子节点"></a>删除子节点</h6><p>如果把<code>newChildren</code>里面的每一个子节点都循环一遍，能在<code>oldChildren</code>数组里找到的就处理它，找不到的就新增，直到把<code>newChildren</code>里面所有子节点都过一遍后，发现在<code>oldChildren</code>还存在未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除。</p>
<p>删除节点这个也很容易，我们在上一篇文章的第四章已经介绍过了，这里就不再赘述了。</p>
<h6 id="更新子节点"><a href="#更新子节点" class="headerlink" title="更新子节点"></a>更新子节点</h6><p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找到了与之相同的子节点，并且所处的位置也相同，那么就更新<code>oldChildren</code>里该节点，使之与<code>newChildren</code>里的该节点相同。</p>
<p>关于更新节点，我们在上一篇文章的第五章已经介绍过了，这里就不再赘述了。</p>
<h6 id="移动子节点"><a href="#移动子节点" class="headerlink" title="移动子节点"></a>移动子节点</h6><p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以<code>newChildren</code>里子节点的位置为基准，调整<code>oldChildren</code>里该节点的位置，使之与在<code>newChildren</code>里的位置相同。</p>
<p>同样，移动一个节点不难，关键在于该移动到哪，或者说关键在于移动到哪个位置，这个位置才是关键。我们看下图：</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425134557748.png" alt="image-20210425134557748"></p>
<p>在上图中，绿色的两个节点是相同节点但是所处位置不同，即<code>newChildren</code>里面的第三个子节点与真实<code>DOM</code>即<code>oldChildren</code>里面的第四个子节点相同但是所处位置不同，按照上面所说的，我们应该以<code>newChildren</code>里子节点的位置为基准，调整<code>oldChildren</code>里该节点的位置，所以我们应该把真实<code>DOM</code>即<code>oldChildren</code>里面的第四个节点移动到第三个节点的位置，通过上图中的标注我们不难发现，<strong>所有未处理节点之前就是我们要移动的目的位置</strong>。如果此时你说那可不可以移动到所有已处理节点之后呢？那就又回到了更新节点时所遇到的那个问题了：如果前面有新增的节点呢？</p>
<h6 id="回到源码"><a href="#回到源码" class="headerlink" title="回到源码"></a>回到源码</h6><p>OK，以上就是更新子节点时所要考虑的所有情况了，分析完以后，我们回到源码里看看实际情况是不是我们分析的这样子的，源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 源码位置： /src/core/vdom/patch.js</span><br><br><span class="hljs-keyword">if</span> (isUndef(idxInOld)) &#123;    <span class="hljs-comment">// 如果在oldChildren里找不到当前循环的newChildren里的子节点</span><br>    <span class="hljs-comment">// 新增节点并插入到合适位置</span><br>    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="hljs-literal">false</span>, newCh, newStartIdx)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果在oldChildren里找到了当前循环的newChildren里的子节点</span><br>    vnodeToMove = oldCh[idxInOld]<br>    <span class="hljs-comment">// 如果两个节点相同</span><br>    <span class="hljs-keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;<br>        <span class="hljs-comment">// 调用patchVnode更新节点</span><br>        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)<br>        oldCh[idxInOld] = <span class="hljs-literal">undefined</span><br>        <span class="hljs-comment">// canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动</span><br>        canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上代码中，首先判断在<code>oldChildren</code>里能否找到当前循环的<code>newChildren</code>里的子节点，如果找不到，那就是新增节点并插入到合适位置；如果找到了，先对比两个节点是否相同，若相同则先调用<code>patchVnode</code>更新节点，更新完之后再看是否需要移动节点，注意，源码里在判断是否需要移动子节点时用了简写的方式，下面这两种写法是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">if</span>(canMove)&#123;<br>    nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看到，源码里的实现跟我们分析的是一样一样的。</p>
<h6 id="总结：："><a href="#总结：：" class="headerlink" title="总结：："></a>总结：：</h6><p>本篇文章我们分析了<code>Vue</code>在更新子节点时是外层循环<code>newChildren</code>数组，内层循环<code>oldChildren</code>数组，把<code>newChildren</code>数组里的每一个元素分别与<code>oldChildren</code>数组里的每一个元素匹配，根据不同情况作出创建子节点、删除子节点、更新子节点以及移动子节点的操作。并且我们对不同情况的不同操作都进行了深入分析，分析之后我们回到源码验证我们分析的正确性，发现我们的分析跟源码的实现是一致的。</p>
<p>最后，我们再思考一个问题：这样双层循环虽然能解决问题，但是如果节点数量很多，这样循环算法的时间复杂度会不会很高？有没有什么可以优化的办法？答案当然是有的，并且<code>Vue</code>也意识到了这点，也进行了优化，那么下篇文章我们就来分析当节点数量很多时<code>Vue</code>是怎么优化算法的。</p>
<h6 id="优化更新子节点"><a href="#优化更新子节点" class="headerlink" title="优化更新子节点"></a>优化更新子节点</h6><p>在上一篇文章中，我们介绍了当新的<code>VNode</code>与旧的<code>oldVNode</code>都是元素节点并且都包含子节点时，<code>Vue</code>对子节点是</p>
<p>先外层循环<code>newChildren</code>数组，再内层循环<code>oldChildren</code>数组，每循环外层<code>newChildren</code>数组里的一个子节点，就去内层<code>oldChildren</code>数组里找看有没有与之相同的子节点，最后根据不同的情况作出不同的操作。</p>
<p>在上一篇文章的结尾我们也说了，这种方法虽然能够解决问题，但是还存在可优化的地方。比如当包含的子节点数量很多时，这样循环算法的时间复杂度就会变的很大，不利于性能提升。当然，<code>Vue</code>也意识到了这点，并对此也进行了优化，那么本篇文章，就来学习一下关于子节点更新的优化问题<code>Vue</code>是如何做的。</p>
<h6 id="优化策略介绍："><a href="#优化策略介绍：" class="headerlink" title="优化策略介绍："></a>优化策略介绍：</h6><p>假如我们现有一份新的<code>newChildren</code>数组和旧的<code>oldChildren</code>数组，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">newChildren = [<span class="hljs-string">&#x27;新子节点1&#x27;</span>,<span class="hljs-string">&#x27;新子节点2&#x27;</span>,<span class="hljs-string">&#x27;新子节点3&#x27;</span>,<span class="hljs-string">&#x27;新子节点4&#x27;</span>]<br>oldChildren = [<span class="hljs-string">&#x27;旧子节点1&#x27;</span>,<span class="hljs-string">&#x27;旧子节点2&#x27;</span>,<span class="hljs-string">&#x27;旧子节点3&#x27;</span>,<span class="hljs-string">&#x27;旧子节点4&#x27;</span>]<br></code></pre></td></tr></table></figure>

<p>如果按照优化之前的解决方案，那么我们接下来的操作应该是这样的：先循环<code>newChildren</code>数组，拿到第一个新子节点1，然后用第一个新子节点1去跟<code>oldChildren</code>数组里的旧子节点逐一对比，如果运气好一点，刚好<code>oldChildren</code>数组里的第一个旧子节点1与第一个新子节点1相同，那就皆大欢喜，直接处理，不用再往下循环了。那如果运气坏一点，直到循环到<code>oldChildren</code>数组里的第四个旧子节点4才与第一个新子节点1相同，那此时就会多循环了4次。我们不妨把情况再设想的极端一点，如果<code>newChildren</code>数组和<code>oldChildren</code>数组里前三个节点都没有变化，只是第四个节点发生了变化，那么我们就会循环16次，只有在第16次循环的时候才发现新节点4与旧节点4相同，进行更新，如下图所示：</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425135252298.png" alt="image-20210425135252298">    </p>
<p>上面例子中只有四个子节点，好像还看不出来有什么缺陷，但是当子节点数量很多的时候，算法的时间复杂度就会非常高，很不利于性能提升。</p>
<p>那么我们该怎么优化呢？其实我们可以这样想，我们不要按顺序去循环<code>newChildren</code>和<code>oldChildren</code>这两个数组，可以先比较这两个数组里特殊位置的子节点，比如：</p>
<ul>
<li><p>先把<code>newChildren</code>数组里的所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作；</p>
</li>
<li><p>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作；</p>
</li>
<li><p>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</p>
</li>
<li><p>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</p>
</li>
<li><p>最后四种情况都试完如果还不同，那就按照之前循环的方式来查找节点。上面例子中只有四个子节点，好像还看不出来有什么缺陷，但是当子节点数量很多的时候，算法的时间复杂度就会非常高，很不利于性能提升。</p>
<p>那么我们该怎么优化呢？其实我们可以这样想，我们不要按顺序去循环<code>newChildren</code>和<code>oldChildren</code>这两个数组，可以先比较这两个数组里特殊位置的子节点，比如：</p>
<ul>
<li>先把<code>newChildren</code>数组里的所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作；</li>
<li>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作；</li>
<li>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</li>
<li>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</li>
<li>最后四种情况都试完如果还不同，那就按照之前循环的方式来查找节点。</li>
</ul>
</li>
</ul>
<p>其过程如下图所示：</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425135454618.png" alt="image-20210425135454618"></p>
<p>在上图中，我们把：</p>
<ul>
<li><code>newChildren</code>数组里的所有未处理子节点的第一个子节点称为：新前；</li>
<li><code>newChildren</code>数组里的所有未处理子节点的最后一个子节点称为：新后；</li>
<li><code>oldChildren</code>数组里的所有未处理子节点的第一个子节点称为：旧前；</li>
<li><code>oldChildren</code>数组里的所有未处理子节点的最后一个子节点称为：旧后；</li>
</ul>
<p>OK，有了以上概念以后，下面我们就来看看其具体是如何实施的。</p>
<h6 id="新前与旧前"><a href="#新前与旧前" class="headerlink" title="新前与旧前"></a>新前与旧前</h6><p>把<code>newChildren</code>数组里的所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那好极了，直接进入之前文章中说的更新节点的操作并且由于新前与旧前两个节点的位置也相同，无需进行节点移动操作；如果不同，没关系，再尝试后面三种情况。</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425135923348.png" alt="image-20210425135923348"></p>
<h6 id="新后与旧后"><a href="#新后与旧后" class="headerlink" title="新后与旧后"></a>新后与旧后</h6><p>把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作并且由于新后与旧后两个节点的位置也相同，无需进行节点移动操作；如果不同，继续往后尝试。</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425140013890.png" alt="image-20210425140013890"></p>
<h5 id="新后与旧前"><a href="#新后与旧前" class="headerlink" title="新后与旧前"></a>新后与旧前</h5><p>把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425140051237.png" alt="image-20210425140051237"></p>
<p>此时，出现了移动节点的操作，移动节点最关键的地方在于找准要移动的位置。我们一再强调，<strong>更新节点要以新<code>VNode</code>为基准，然后操作旧的<code>oldVNode</code>，使之最后旧的<code>oldVNode</code>与新的<code>VNode</code>相同</strong>。那么现在的情况是：<code>newChildren</code>数组里的最后一个子节点与<code>oldChildren</code>数组里的第一个子节点相同，那么我们就应该在<code>oldChildren</code>数组里把第一个子节点移动到最后一个子节点的位置，如下图：</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425140208880.png" alt="image-20210425140208880"></p>
<p>从图中不难看出，我们要把<code>oldChildren</code>数组里把第一个子节点移动到数组中<strong>所有未处理节点之后</strong>。</p>
<p>如果对比之后发现这两个节点仍不是同一个节点，那就继续尝试最后一种情况。</p>
<h6 id="新前与旧后"><a href="#新前与旧后" class="headerlink" title="新前与旧后"></a>新前与旧后</h6><p>把<code>newChildren</code>数组里所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425140311007.png" alt="image-20210425140311007"></p>
<p>同样，这种情况的节点移动位置逻辑与“新后与旧前”的逻辑类似，那就是<code>newChildren</code>数组里的第一个子节点与<code>oldChildren</code>数组里的最后一个子节点相同，那么我们就应该在<code>oldChildren</code>数组里把最后一个子节点移动到第一个子节点的位置，如下图：</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425140415224.png" alt="image-20210425140415224"></p>
<p>从图中不难看出，我们要把<code>oldChildren</code>数组里把最后一个子节点移动到数组中<strong>所有未处理节点之前</strong>。</p>
<p>OK，以上就是子节点对比更新优化策略种的4种情况，如果以上4种情况逐个试遍之后要是还没找到相同的节点，那就再通过之前的循环方式查找。</p>
<h6 id="回到源码：："><a href="#回到源码：：" class="headerlink" title="回到源码：："></a>回到源码：：</h6><p>思路分析完，逻辑理清之后，我们再回到源码里看看，验证一下源码实现的逻辑是否跟我们分析的一样。源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 循环更新子节点</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateChildren</span> (<span class="hljs-params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span>               <span class="hljs-comment">// oldChildren开始索引</span><br>    <span class="hljs-keyword">let</span> oldEndIdx = oldCh.length - <span class="hljs-number">1</span>   <span class="hljs-comment">// oldChildren结束索引</span><br>    <span class="hljs-keyword">let</span> oldStartVnode = oldCh[<span class="hljs-number">0</span>]        <span class="hljs-comment">// oldChildren中所有未处理节点中的第一个</span><br>    <span class="hljs-keyword">let</span> oldEndVnode = oldCh[oldEndIdx]   <span class="hljs-comment">// oldChildren中所有未处理节点中的最后一个</span><br><br>    <span class="hljs-keyword">let</span> newStartIdx = <span class="hljs-number">0</span>               <span class="hljs-comment">// newChildren开始索引</span><br>    <span class="hljs-keyword">let</span> newEndIdx = newCh.length - <span class="hljs-number">1</span>   <span class="hljs-comment">// newChildren结束索引</span><br>    <span class="hljs-keyword">let</span> newStartVnode = newCh[<span class="hljs-number">0</span>]        <span class="hljs-comment">// newChildren中所有未处理节点中的第一个</span><br>    <span class="hljs-keyword">let</span> newEndVnode = newCh[newEndIdx]  <span class="hljs-comment">// newChildren中所有未处理节点中的最后一个</span><br><br>    <span class="hljs-keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm<br><br>    <span class="hljs-comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span><br>    <span class="hljs-comment">// to ensure removed elements stay in correct relative positions</span><br>    <span class="hljs-comment">// during leaving transitions</span><br>    <span class="hljs-keyword">const</span> canMove = !removeOnly<br><br>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>      checkDuplicateKeys(newCh)<br>    &#125;<br><br>    <span class="hljs-comment">// 以&quot;新前&quot;、&quot;新后&quot;、&quot;旧前&quot;、&quot;旧后&quot;的方式开始比对节点</span><br>    <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;<br>      <span class="hljs-keyword">if</span> (isUndef(oldStartVnode)) &#123;<br>        oldStartVnode = oldCh[++oldStartIdx] <span class="hljs-comment">// 如果oldStartVnode不存在，则直接跳过，比对下一个</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isUndef(oldEndVnode)) &#123;<br>        oldEndVnode = oldCh[--oldEndIdx]<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;<br>        <span class="hljs-comment">// 如果新前与旧前节点相同，就把两个节点进行patch更新</span><br>        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)<br>        oldStartVnode = oldCh[++oldStartIdx]<br>        newStartVnode = newCh[++newStartIdx]<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;<br>        <span class="hljs-comment">// 如果新后与旧后节点相同，就把两个节点进行patch更新</span><br>        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)<br>        oldEndVnode = oldCh[--oldEndIdx]<br>        newEndVnode = newCh[--newEndIdx]<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="hljs-comment">// Vnode moved right</span><br>        <span class="hljs-comment">// 如果新后与旧前节点相同，先把两个节点进行patch更新，然后把旧前节点移动到oldChilren中所有未处理节点之后</span><br>        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)<br>        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))<br>        oldStartVnode = oldCh[++oldStartIdx]<br>        newEndVnode = newCh[--newEndIdx]<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="hljs-comment">// Vnode moved left</span><br>        <span class="hljs-comment">// 如果新前与旧后节点相同，先把两个节点进行patch更新，然后把旧后节点移动到oldChilren中所有未处理节点之前</span><br>        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)<br>        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)<br>        oldEndVnode = oldCh[--oldEndIdx]<br>        newStartVnode = newCh[++newStartIdx]<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果不属于以上四种情况，就进行常规的循环比对patch</span><br>        <span class="hljs-keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)<br>        idxInOld = isDef(newStartVnode.key)<br>          ? oldKeyToIdx[newStartVnode.key]<br>          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)<br>        <span class="hljs-comment">// 如果在oldChildren里找不到当前循环的newChildren里的子节点</span><br>        <span class="hljs-keyword">if</span> (isUndef(idxInOld)) &#123; <span class="hljs-comment">// New element</span><br>          <span class="hljs-comment">// 新增节点并插入到合适位置</span><br>          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="hljs-literal">false</span>, newCh, newStartIdx)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果在oldChildren里找到了当前循环的newChildren里的子节点</span><br>          vnodeToMove = oldCh[idxInOld]<br>          <span class="hljs-comment">// 如果两个节点相同</span><br>          <span class="hljs-keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;<br>            <span class="hljs-comment">// 调用patchVnode更新节点</span><br>            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)<br>            oldCh[idxInOld] = <span class="hljs-literal">undefined</span><br>            <span class="hljs-comment">// canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动</span><br>            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// same key but different element. treat as new element</span><br>            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="hljs-literal">false</span>, newCh, newStartIdx)<br>          &#125;<br>        &#125;<br>        newStartVnode = newCh[++newStartIdx]<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;<br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 如果oldChildren比newChildren先循环完毕，</span><br><span class="hljs-comment">       * 那么newChildren里面剩余的节点都是需要新增的节点，</span><br><span class="hljs-comment">       * 把[newStartIdx, newEndIdx]之间的所有节点都插入到DOM中</span><br><span class="hljs-comment">       */</span><br>      refElm = isUndef(newCh[newEndIdx + <span class="hljs-number">1</span>]) ? <span class="hljs-literal">null</span> : newCh[newEndIdx + <span class="hljs-number">1</span>].elm<br>      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;<br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 如果newChildren比oldChildren先循环完毕，</span><br><span class="hljs-comment">       * 那么oldChildren里面剩余的节点都是需要删除的节点，</span><br><span class="hljs-comment">       * 把[oldStartIdx, oldEndIdx]之间的所有节点都删除</span><br><span class="hljs-comment">       */</span><br>      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>读源码之前，我们先有这样一个概念：那就是在我们前面所说的优化策略中，节点有可能是从前面对比，也有可能是从后面对比，对比成功就会进行更新处理，也就是说我们有可能处理第一个，也有可能处理最后一个，那么我们在循环的时候就不能简单从前往后或从后往前循环，而是要从两边向中间循环。</p>
<p>那么该如何从两边向中间循环呢？请看下图：</p>
<p><img src="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425140631885.png" alt="image-20210425140631885"></p>
<p>首先，我们先准备4个变量：</p>
<ul>
<li><strong>newStartIdx:</strong><code>newChildren</code>数组里开始位置的下标；</li>
<li><strong>newEndIdx:</strong><code>newChildren</code>数组里结束位置的下标；</li>
<li><strong>oldStartIdx:</strong><code>oldChildren</code>数组里开始位置的下标；</li>
<li><strong>oldEndIdx:</strong><code>oldChildren</code>数组里结束位置的下标；</li>
</ul>
<p>在循环的时候，每处理一个节点，就将下标向图中箭头所指的方向移动一个位置，开始位置所表示的节点被处理后，就向后移动一个位置；结束位置所表示的节点被处理后，就向前移动一个位置；由于我们的优化策略都是新旧节点两两更新的，所以一次更新将会移动两个节点。说的再直白一点就是：<code>newStartIdx</code>和<code>oldStartIdx</code>只能往后移动（只会加），<code>newEndIdx</code>和<code>oldEndIdx</code>只能往前移动（只会减）。</p>
<p>当开始位置大于结束位置时，表示所有节点都已经遍历过了。</p>
<p>OK，有了这个概念后，我们开始读源码：</p>
<ol>
<li>如果<code>oldStartVnode</code>不存在，则直接跳过，将<code>oldStartIdx</code>加1，比对下一个</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 以&quot;新前&quot;、&quot;新后&quot;、&quot;旧前&quot;、&quot;旧后&quot;的方式开始比对节点</span><br><span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;<br>	<span class="hljs-keyword">if</span> (isUndef(oldStartVnode)) &#123;<br>        oldStartVnode = oldCh[++oldStartIdx]<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果<code>oldEndVnode</code>不存在，则直接跳过，将<code>oldEndIdx</code>减1，比对前一个</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isUndef(oldEndVnode)) &#123;<br>    oldEndVnode = oldCh[--oldEndIdx]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果新前与旧前节点相同，就把两个节点进行<code>patch</code>更新，同时<code>oldStartIdx</code>和<code>newStartIdx</code>都加1，后移一个位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;<br>    patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)<br>    oldStartVnode = oldCh[++oldStartIdx]<br>    newStartVnode = newCh[++newStartIdx]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果新后与旧后节点相同，就把两个节点进行<code>patch</code>更新，同时<code>oldEndIdx</code>和<code>newEndIdx</code>都减1，前移一个位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;<br>    patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)<br>    oldEndVnode = oldCh[--oldEndIdx]<br>    newEndVnode = newCh[--newEndIdx]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果新后与旧前节点相同，先把两个节点进行<code>patch</code>更新，然后把旧前节点移动到<code>oldChilren</code>中所有未处理节点之后，最后把<code>oldStartIdx</code>加1，后移一个位置，<code>newEndIdx</code>减1，前移一个位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123;<br>    patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)<br>    canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))<br>    oldStartVnode = oldCh[++oldStartIdx]<br>    newEndVnode = newCh[--newEndIdx]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果新前与旧后节点相同，先把两个节点进行<code>patch</code>更新，然后把旧后节点移动到<code>oldChilren</code>中所有未处理节点之前，最后把<code>newStartIdx</code>加1，后移一个位置，<code>oldEndIdx</code>减1，前移一个位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="hljs-comment">// Vnode moved left</span><br>    patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)<br>    canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)<br>    oldEndVnode = oldCh[--oldEndIdx]<br>    newStartVnode = newCh[++newStartIdx]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果不属于以上四种情况，就进行常规的循环比对<code>patch</code></p>
<p>如果在循环中，<code>oldStartIdx</code>大于<code>oldEndIdx</code>了，那就表示<code>oldChildren</code>比<code>newChildren</code>先循环完毕，那么<code>newChildren</code>里面剩余的节点都是需要新增的节点，把<code>[newStartIdx, newEndIdx]</code>之间的所有节点都插入到<code>DOM</code>中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;<br>    refElm = isUndef(newCh[newEndIdx + <span class="hljs-number">1</span>]) ? <span class="hljs-literal">null</span> : newCh[newEndIdx + <span class="hljs-number">1</span>].elm<br>    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果在循环中，<code>newStartIdx</code>大于<code>newEndIdx</code>了，那就表示<code>newChildren</code>比<code>oldChildren</code>先循环完毕，那么<code>oldChildren</code>里面剩余的节点都是需要删除的节点，把<code>[oldStartIdx, oldEndIdx]</code>之间的所有节点都删除</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;<br>    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>OK,处理完毕，可见源码中的处理逻辑跟我们之前分析的逻辑是一样的。</p>
<h6 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h6><p>本篇文章中，我们介绍了<code>Vue</code>中子节点更新的优化策略，发现<code>Vue</code>为了避免双重循环数据量大时间复杂度升高带来的性能问题，而选择了从子节点数组中的4个特殊位置互相比对，分别是：新前与旧前，新后与旧后，新后与旧前，新前与旧后。对于每一种情况我们都通过图文的形式对其逻辑进行了分析。最后我们回到源码，通过阅读源码来验证我们分析的是否正确。幸运的是我们之前每一步的分析都在源码中找到了相应的实现，得以验证我们的分析没有错。以上就是<code>Vue</code>中的<code>patch</code>过程，即<code>DOM-Diff</code>算法所有内容了，到这里相信你再读这部分源码的时候就有比较清晰的思路了。</p>
<p>撸码一时爽，一直撸码一直爽！！！</p>
]]></content>
      <tags>
        <tag>vue源码理解——虚拟DOM篇</tag>
      </tags>
  </entry>
  <entry>
    <title>es6</title>
    <url>/2020/09/18/es6/</url>
    <content><![CDATA[<p><img src="https://images.weserv.nl/?url=https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1625990591979-6a2fa7d45ef1.jpg" alt="img"></p>
<h4 id="let："><a href="#let：" class="headerlink" title="let："></a>let：</h4><p>块级作用域；</p>
<p>用{}来表示块级作用域；</p>
<p>暂时性死区：在同一个作用域内，let声明变量x，那么在这一行代码之前就是x的暂时性死区‘’暂时性死区‘’也意味着typeof不再是一个百分之白安全的操作；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> x;<span class="hljs-comment">//ReferenceError</span><br><span class="hljs-keyword">let</span> x<br><span class="hljs-keyword">typeof</span> undeclar_variable<span class="hljs-comment">//&#x27;undefined&#x27;没有声明反而不会报错</span><br><br><br><span class="hljs-comment">//不报错</span><br><span class="hljs-keyword">var</span> x=x<br><br><span class="hljs-comment">//报错</span><br><span class="hljs-keyword">let</span> x=x<br><span class="hljs-comment">//ReferenceError:x is not definde</span><br></code></pre></td></tr></table></figure>

<p>不能变量提升（变量提升，即变量可以在声明之前使用），let所声明的变量一定要在声明后使用</p>
<p>不能重复声明：let x；var x；（不可以）</p>
<p>不能在函数内部重新声明函数</p>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p>具有let的特点</p>
<p>const一旦声明变量，就必须立即初始化，不能到以后赋值。；</p>
<p>不能重复赋值：const x=100；x=200；（不可以）</p>
<p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</p>
<p>如果const的值是一个对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> o=&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zs&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">10</span>&#125;<br>o=&#123;&#125;<span class="hljs-comment">//报错</span><br>o.name=<span class="hljs-string">&#x27;lisi&#x27;</span><span class="hljs-comment">//可以</span><br><br></code></pre></td></tr></table></figure>

<p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">Object</span>.freeze(&#123;&#125;);<br><br><span class="hljs-comment">// 常规模式时，下面一行不起作用；</span><br><span class="hljs-comment">// 严格模式时，该行会报错</span><br>foo.prop = <span class="hljs-number">123</span>;<br><br><span class="hljs-comment">//将对象彻底冻结的函数</span><br><span class="hljs-keyword">var</span> constantize = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">Object</span>.freeze(obj);<br>  <span class="hljs-built_in">Object</span>.keys(obj).forEach( <span class="hljs-function">(<span class="hljs-params">key, i</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">&#x27;object&#x27;</span> ) &#123;<br>      constantize( obj[key] );<br>    &#125;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>Symbol表示独一无二的值，凡是属性名属于symbol类型，那都是独一无二的，可以保证不会与其他属性名产生冲突，他是javascript语言的第七种数据类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s=<span class="hljs-built_in">Symbol</span>()<br><span class="hljs-keyword">typeof</span> s<br><span class="hljs-comment">//&#x27;symbol&#x27;</span><br><br></code></pre></td></tr></table></figure>

<p>如果Symbol的参数是一个对象，就会调用该对象的tostring方法，将其转为字符串，然后生成一个Symbol值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  toString() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;abc&#x27;</span>;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> sym = <span class="hljs-built_in">Symbol</span>(obj);<br>sym <span class="hljs-comment">// Symbol(abc)</span><br><br><br><span class="hljs-comment">//Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。</span><br><span class="hljs-comment">// 没有参数的情况</span><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">Symbol</span>();<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">Symbol</span>();<br><br>s1 === s2 <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 有参数的情况</span><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><br>s1 === s2 <span class="hljs-comment">// false</span><br><br><br><span class="hljs-keyword">let</span> sym = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;My symbol&#x27;</span>);<span class="hljs-comment">//Symbol 值不能与其他类型的值进行运算，会报错。</span><br><span class="hljs-string">&quot;your symbol is &quot;</span> + sym<br><span class="hljs-comment">// TypeError: can&#x27;t convert symbol to string</span><br><span class="hljs-string">`your symbol is <span class="hljs-subst">$&#123;sym&#125;</span>`</span><br><span class="hljs-comment">// TypeError: can&#x27;t convert symbol to string</span><br><br><span class="hljs-keyword">let</span> sym = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;My symbol&#x27;</span>);<span class="hljs-comment">//Symbol 值可以显式转为字符串</span><br><span class="hljs-built_in">String</span>(sym) <span class="hljs-comment">// &#x27;Symbol(My symbol)&#x27;</span><br>sym.toString() <span class="hljs-comment">// &#x27;Symbol(My symbol)&#x27;</span><br><br><span class="hljs-keyword">let</span> sym = <span class="hljs-built_in">Symbol</span>();<span class="hljs-comment">//Symbol 值也可以转为布尔值，但是不能转为数值</span><br><span class="hljs-built_in">Boolean</span>(sym) <span class="hljs-comment">// true</span><br>!sym  <span class="hljs-comment">// false</span><br><span class="hljs-keyword">if</span> (sym) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-built_in">Number</span>(sym) <span class="hljs-comment">// TypeError</span><br>sym + <span class="hljs-number">2</span> <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure>

<p>由于每一个Symbol都是不相等的，这意味着symbol值可以作为标识，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> mySymbol=symbol();<br><br><span class="hljs-comment">//第一种写法</span><br><span class="hljs-keyword">let</span> a=&#123;&#125;<br>a[mySmbol]=<span class="hljs-string">&#x27;hellow&#x27;</span><br><br><span class="hljs-comment">//第二种写法</span><br><span class="hljs-keyword">let</span> a=&#123;<br>    [mySmbol]:<span class="hljs-string">&#x27;hellow&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">//第三种写法</span><br><span class="hljs-keyword">let</span> a=&#123;&#125;<br><span class="hljs-built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Hello!&#x27;</span> &#125;);<br><span class="hljs-comment">// 以上写法都得到同样结果</span><br>a[mySymbol] <span class="hljs-comment">// &quot;Hello!&quot;</span><br><br><span class="hljs-comment">//Symbol 值作为对象属性名时，不能用点运算符</span><br><span class="hljs-keyword">const</span> mySymbol = <span class="hljs-built_in">Symbol</span>();<br><span class="hljs-keyword">const</span> a = &#123;&#125;;<br>a.mySymbol = <span class="hljs-string">&#x27;Hello!&#x27;</span>;<span class="hljs-comment">//因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值</span><br>a[mySymbol] <span class="hljs-comment">// undefined</span><br>a[<span class="hljs-string">&#x27;mySymbol&#x27;</span>] <span class="hljs-comment">// &quot;Hello!&quot;</span><br><br></code></pre></td></tr></table></figure>

<h3 id="解构赋值："><a href="#解构赋值：" class="headerlink" title="解构赋值："></a>解构赋值：</h3><h3 id="扩展运算符…"><a href="#扩展运算符…" class="headerlink" title="扩展运算符…"></a>扩展运算符…</h3><p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环</p>
<p>rest参数 函数的形参</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a,b,...args</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a,b,args);<br>&#125;<br>fn(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure>

<p>数组的扩展运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr=[<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a,b,c</span>)</span>&#123;&#125;<br>fn(...arr);<br><span class="hljs-keyword">var</span> arr2=[...arr];<br></code></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br><br>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>].forEach(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> s.add(x));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> s) &#123;<br>  <span class="hljs-built_in">console</span>.log(i);<br>&#125;<br><span class="hljs-comment">// 2 3 5 4 //通过add()方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值</span><br><br><br><span class="hljs-comment">// 例一</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]);<br>[...set]<br><span class="hljs-comment">// [1, 2, 3, 4]</span><br><span class="hljs-comment">// 例二</span><br><span class="hljs-keyword">const</span> items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]);<br>items.size <span class="hljs-comment">// 5</span><br><span class="hljs-comment">// 例三</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;div&#x27;</span>));<br>set.size <span class="hljs-comment">// 56</span><br><span class="hljs-comment">// 类似于</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br><span class="hljs-built_in">document</span><br> .querySelectorAll(<span class="hljs-string">&#x27;div&#x27;</span>)<br> .forEach(<span class="hljs-function"><span class="hljs-params">div</span> =&gt;</span> set.add(div));<br>set.size <span class="hljs-comment">// 56</span><br></code></pre></td></tr></table></figure>

<p>set用于去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 去除数组的重复成员</span><br>[...new <span class="hljs-built_in">Set</span>(array)]<br><span class="hljs-comment">//去除字符串里面的重复字符</span><br>[...new <span class="hljs-built_in">Set</span>(<span class="hljs-string">&#x27;ababbc&#x27;</span>)].join(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-comment">// &quot;abc&quot;</span><br></code></pre></td></tr></table></figure>

<p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br><span class="hljs-keyword">let</span> a = <span class="hljs-literal">NaN</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-literal">NaN</span>;<br>set.add(a);<br>set.add(b);<br>set <span class="hljs-comment">// Set &#123;NaN&#125;  //只添加了一个NaN，表明在 Set 内部，两个NaN是相等的</span><br><span class="hljs-comment">//两个对象总是不相等的</span><br><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>set.add(&#123;&#125;);<br>set.size <span class="hljs-comment">// 1</span><br>set.add(&#123;&#125;);<br>set.size <span class="hljs-comment">// 2  由于两个空对象不相等，所以它们被视为两个值</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//Set 结构的实例有以下属性：</span><br><span class="hljs-built_in">Set</span>.prototype.constructor：构造函数，默认就是<span class="hljs-built_in">Set</span>函数。<br><span class="hljs-built_in">Set</span>.prototype.size：返回<span class="hljs-built_in">Set</span>实例的成员总数。<br><span class="hljs-comment">//Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。</span><br><span class="hljs-comment">//四个操作方法</span><br><span class="hljs-built_in">Set</span>.prototype.add(value)：添加某个值，返回 <span class="hljs-built_in">Set</span> 结构本身。<br><span class="hljs-built_in">Set</span>.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。<br><span class="hljs-built_in">Set</span>.prototype.has(value)：返回一个布尔值，表示该值是否为<span class="hljs-built_in">Set</span>的成员。<br><span class="hljs-built_in">Set</span>.prototype.clear()：清除所有成员，没有返回值。<br><br>s.add(<span class="hljs-number">1</span>).add(<span class="hljs-number">2</span>).add(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 注意2被加入了两次</span><br>s.size <span class="hljs-comment">// 2</span><br>s.has(<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><br>s.has(<span class="hljs-number">2</span>) <span class="hljs-comment">// true</span><br>s.has(<span class="hljs-number">3</span>) <span class="hljs-comment">// false</span><br>s.delete(<span class="hljs-number">2</span>);<br>s.has(<span class="hljs-number">2</span>) <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">//Set 结构的实例有四个遍历方法，可以用于遍历成员，Set的遍历顺序就是插入顺序。</span><br><span class="hljs-built_in">Set</span>.prototype.keys()：返回键名的遍历器<br><span class="hljs-built_in">Set</span>.prototype.values()：返回键值的遍历器<br><span class="hljs-built_in">Set</span>.prototype.entries()：返回键值对的遍历器<br><span class="hljs-built_in">Set</span>.prototype.forEach()：使用回调函数遍历每个成员<br><br><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]);<br><span class="hljs-comment">//keys方法、values方法、entries方法返回的都是遍历器对象，由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set.keys()) &#123;<br>  <span class="hljs-built_in">console</span>.log(item);<br>&#125;<br><span class="hljs-comment">// red</span><br><span class="hljs-comment">// green</span><br><span class="hljs-comment">// blue</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set.values()) &#123;<br>  <span class="hljs-built_in">console</span>.log(item);<br>&#125;<br><span class="hljs-comment">// red</span><br><span class="hljs-comment">// green</span><br><span class="hljs-comment">// blue</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set.entries()) &#123;<br>  <span class="hljs-built_in">console</span>.log(item);<br>&#125;<br><span class="hljs-comment">// [&quot;red&quot;, &quot;red&quot;]</span><br><span class="hljs-comment">// [&quot;green&quot;, &quot;green&quot;]</span><br><span class="hljs-comment">// [&quot;blue&quot;, &quot;blue&quot;]</span><br><br><span class="hljs-comment">//Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。</span><br><span class="hljs-built_in">Set</span>.prototype[<span class="hljs-built_in">Symbol</span>.iterator] === <span class="hljs-built_in">Set</span>.prototype.values<br><span class="hljs-comment">// true</span><br><span class="hljs-comment">//这意味着，可以省略values方法，直接用for...of循环遍历 Set。</span><br><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> set) &#123;<br>  <span class="hljs-built_in">console</span>.log(x);<br>&#125;<br><span class="hljs-comment">// red</span><br><span class="hljs-comment">// green</span><br><span class="hljs-comment">// blue</span><br><br><span class="hljs-comment">//Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</span><br><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>]);<br>set.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">&#x27; : &#x27;</span> + value))<br><span class="hljs-comment">// 1 : 1</span><br><span class="hljs-comment">// 4 : 4</span><br><span class="hljs-comment">// 9 : 9</span><br><br><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]);<br><span class="hljs-keyword">let</span> arr = [...set];<br><span class="hljs-comment">// [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> unique = [...new <span class="hljs-built_in">Set</span>(arr)];<br><span class="hljs-comment">// [3, 5, 2]</span><br><br><span class="hljs-comment">//数组的map和filter方法可以间接用于 Set </span><br><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...set].map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>));<br><span class="hljs-comment">// 返回Set结构：&#123;2, 4, 6&#125;</span><br><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br>set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...set].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> (x % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>));<br><span class="hljs-comment">// 返回Set结构：&#123;2, 4&#125;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//Array.from方法可以将 Set 结构转为数组</span><br><span class="hljs-keyword">const</span> items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-keyword">const</span> array = <span class="hljs-built_in">Array</span>.from(items);<br><span class="hljs-comment">//用于数组去重</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dedupe</span>(<span class="hljs-params">array</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(array));<br>&#125;<br>dedupe([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>

<p>使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-comment">// 并集</span><br><span class="hljs-keyword">let</span> union = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...a, ...b]);<br><span class="hljs-comment">// Set &#123;1, 2, 3, 4&#125;</span><br><span class="hljs-comment">// 交集</span><br><span class="hljs-keyword">let</span> intersect = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...a].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> b.has(x)));<br><span class="hljs-comment">// set &#123;2, 3&#125;</span><br><span class="hljs-comment">//（a 相对于 b 的）差集</span><br><span class="hljs-keyword">let</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...a].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !b.has(x)));<br><span class="hljs-comment">// Set &#123;1&#125;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。</span><br><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...set].map(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val * <span class="hljs-number">2</span>));<br><span class="hljs-comment">// set的值是2, 4, 6</span><br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(<span class="hljs-built_in">Array</span>.from(set, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val * <span class="hljs-number">2</span>));<br><span class="hljs-comment">// set的值是2, 4, 6</span><br></code></pre></td></tr></table></figure>

<p>Array.from()方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</p>
<p>​        伪数组对象（拥有一个 length 属性和若干索引属性的任意对象）</p>
<p>​        可迭代对象（可以获取对象中的元素,如 Map和 Set 等）</p>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>();<br><span class="hljs-comment">//作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</span><br><span class="hljs-keyword">const</span> a = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]];<br><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>(a);<br><span class="hljs-comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span><br><span class="hljs-keyword">const</span> b = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>(b);<span class="hljs-comment">//数组b的成员不是对象，加入 WeakSet 就会报错</span><br><span class="hljs-comment">// Uncaught TypeError: Invalid value used in weak set(…)</span><br></code></pre></td></tr></table></figure>

<p>WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。</p>
<p>WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。</p>
<p>WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</p>
<p>WeakSet 没有<code>size</code>属性。</p>
<p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br><span class="hljs-keyword">const</span> o = &#123;<span class="hljs-attr">p</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span>&#125;;<br>m.set(o, <span class="hljs-string">&#x27;content&#x27;</span>)<br>m.get(o) <span class="hljs-comment">// &quot;content&quot;</span><br>m.has(o) <span class="hljs-comment">// true</span><br>m.delete(o) <span class="hljs-comment">// true</span><br>m.has(o) <span class="hljs-comment">// false</span><br><span class="hljs-comment">//上面代码使用 Map 结构的set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键</span><br><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([<br>  [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;张三&#x27;</span>],<br>  [<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;Author&#x27;</span>]<br>]);<br>map.size <span class="hljs-comment">// 2</span><br>map.has(<span class="hljs-string">&#x27;name&#x27;</span>) <span class="hljs-comment">// true</span><br>map.get(<span class="hljs-string">&#x27;name&#x27;</span>) <span class="hljs-comment">// &quot;张三&quot;</span><br>map.has(<span class="hljs-string">&#x27;title&#x27;</span>) <span class="hljs-comment">// true</span><br>map.get(<span class="hljs-string">&#x27;title&#x27;</span>) <span class="hljs-comment">// &quot;Author&quot;</span><br><br></code></pre></td></tr></table></figure>

<p>任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<br>  [<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">1</span>],<br>  [<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-number">2</span>]<br>]);<br><span class="hljs-keyword">const</span> m1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(set);<br>m1.get(<span class="hljs-string">&#x27;foo&#x27;</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-keyword">const</span> m2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-number">3</span>]]);<br><span class="hljs-keyword">const</span> m3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(m2);<br>m3.get(<span class="hljs-string">&#x27;baz&#x27;</span>) <span class="hljs-comment">// 3</span><br><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<span class="hljs-comment">//对同一个键多次赋值，后面的值将覆盖前面的值</span><br>map.set(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>).set(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;bbb&#x27;</span>);<br>map.get(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;bbb&quot;</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().get(<span class="hljs-string">&#x27;asfddfsasadf&#x27;</span>)<span class="hljs-comment">//读取一个未知的键，则返回undefined</span><br><span class="hljs-comment">// undefined</span><br><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>map.set([<span class="hljs-string">&#x27;a&#x27;</span>], <span class="hljs-number">555</span>);<br>map.get([<span class="hljs-string">&#x27;a&#x27;</span>]) <span class="hljs-comment">// undefined  这是两个不同的数组实例，内存地址是不一样的，因此get方法无法读取该键，返回undefined</span><br><br></code></pre></td></tr></table></figure>

<p>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>map.set(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-literal">true</span>);<br>map.set(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-literal">false</span>);<br>map.size <span class="hljs-comment">// 2  size属性返回 Map 结构的成员总数</span><br><br></code></pre></td></tr></table></figure>



<h3 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串:"></a>模版字符串:</h3><p>``</p>
<p>模板字符串中嵌入变量，需要将变量名写在<code>$&#123;&#125;</code>之中，大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性，如果大括号内部是一个字符串，将会原样输出。。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a=<span class="hljs-string">``</span>;<br><span class="hljs-string">`Hello <span class="hljs-subst">$&#123;<span class="hljs-string">&#x27;World&#x27;</span>&#125;</span>`</span><br><span class="hljs-comment">// &quot;Hello World&quot;</span><br><span class="hljs-keyword">const</span> tmpl = <span class="hljs-function"><span class="hljs-params">addrs</span> =&gt;</span> <span class="hljs-string">`//嵌套</span><br><span class="hljs-string">  &lt;table&gt;</span><br><span class="hljs-string">  <span class="hljs-subst">$&#123;addrs.map(addr =&gt; <span class="hljs-string">`</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">    &lt;tr&gt;&lt;td&gt;<span class="hljs-subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">    &lt;tr&gt;&lt;td&gt;<span class="hljs-subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">  `</span>).join(<span class="hljs-string">&#x27;&#x27;</span>)&#125;</span></span><br><span class="hljs-string">  &lt;/table&gt;</span><br><span class="hljs-string">`</span>;<br><br></code></pre></td></tr></table></figure>

<h3 id="Class："><a href="#Class：" class="headerlink" title="Class："></a>Class：</h3><p>静态方法和属性由class调用，非静态方法和属性由实例调用；</p>
<h4 id="class继承："><a href="#class继承：" class="headerlink" title="class继承："></a>class继承：</h4><p>Class 可以通过extends关键字实现继承，super关键字表示父类的构造函数，用来新建父类的this对象。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>&#123;<br>  <br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;<span class="hljs-comment">//继承</span><br>  <span class="hljs-keyword">constructor</span>(x, y, color) &#123;<br>    <span class="hljs-built_in">super</span>(x, y); <span class="hljs-comment">// 调用父类的constructor(x, y)，super方法要在this之前调用</span><br>    <span class="hljs-built_in">this</span>.color = color;<br>  &#125;<br><br>  toString() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">super</span>.toString(); <span class="hljs-comment">// 调用父类的toString()</span><br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">//构造函数</span><br><span class="hljs-keyword">var</span> p=<span class="hljs-keyword">new</span> Person();<br><span class="hljs-comment">//new：</span><br><span class="hljs-comment">//1.创建一个空object</span><br><span class="hljs-comment">//2.把this指针指向这个空object</span><br><span class="hljs-comment">//3.把this指向的这个空对象当作函数的返回值;  return this;</span><br><br></code></pre></td></tr></table></figure>

<h2 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>
<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p><code>Promise</code>对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p>
<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>
<p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>如果某些事件不断地反复发生，一般来说，使用 <a href="https://nodejs.org/api/stream.html">Stream</a> 模式是比部署<code>Promise</code>更好的选择。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>
<p>下面代码创造了一个<code>Promise</code>实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-comment">// ... some code</span><br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>)&#123;<br>    resolve(value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    reject(error);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-comment">// success</span><br>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-comment">// failure</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。这两个函数都是可选的，不一定要提供。它们都接受<code>Promise</code>对象传出的值作为参数。</p>
<p>下面是一个<code>Promise</code>对象的简单例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params">ms</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, ms, <span class="hljs-string">&#x27;done&#x27;</span>);<br>  &#125;);<br>&#125;<br><br>timeout(<span class="hljs-number">100</span>).then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p>
<p>Promise 新建后就会立即执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Promise&#x27;</span>);<br>  resolve();<br>&#125;);<br><br>promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;resolved.&#x27;</span>);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi!&#x27;</span>);<br><br><span class="hljs-comment">// Promise</span><br><span class="hljs-comment">// Hi!</span><br><span class="hljs-comment">// resolved</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p>
<p>下面是异步加载图片的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadImageAsync</span>(<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> Image();<br><br>    image.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      resolve(image);<br>    &#125;;<br><br>    image.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Could not load image at &#x27;</span> + url));<br>    &#125;;<br><br>    image.src = url;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p>
<p>下面是一个用<code>Promise</code>对象实现的 Ajax 操作的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> getJSON = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> handler = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.readyState !== <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-number">200</span>) &#123;<br>        resolve(<span class="hljs-built_in">this</span>.response);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-built_in">this</span>.statusText));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    client.open(<span class="hljs-string">&quot;GET&quot;</span>, url);<br>    client.onreadystatechange = handler;<br>    client.responseType = <span class="hljs-string">&quot;json&quot;</span>;<br>    client.setRequestHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>    client.send();<br><br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> promise;<br>&#125;;<br><br>getJSON(<span class="hljs-string">&quot;/posts.json&quot;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">json</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Contents: &#x27;</span> + json);<br>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;出错了&#x27;</span>, error);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p>
<p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  resolve(p1);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p>
<p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;fail&#x27;</span>)), <span class="hljs-number">3000</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(p1), <span class="hljs-number">1000</span>)<br>&#125;)<br><br>p2<br>  .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(result))<br>  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(error))<br><span class="hljs-comment">// Error: fail</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p>
<p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(r);<br>&#125;);<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
<p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> resolve(<span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 后面的语句不会执行</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数，它们都是可选的。</p>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">getJSON(<span class="hljs-string">&quot;/posts.json&quot;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">json</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> json.post;<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">post</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">getJSON(<span class="hljs-string">&quot;/post/1.json&quot;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">post</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> getJSON(post.commentURL);<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">comments</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;resolved: &quot;</span>, comments);<br>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;rejected: &quot;</span>, err);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p>
<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">getJSON(<span class="hljs-string">&quot;/post/1.json&quot;</span>).then(<br>  post =&gt; getJSON(post.commentURL)<br>).then(<br>  comments =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;resolved: &quot;</span>, comments),<br>  err =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;rejected: &quot;</span>, err)<br>);<br></code></pre></td></tr></table></figure>

<h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">getJSON(<span class="hljs-string">&#x27;/posts.json&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">posts</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;发生错误！&#x27;</span>, error);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">p.then(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fulfilled:&#x27;</span>, val))<br>  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;rejected&#x27;</span>, err));<br><br><span class="hljs-comment">// 等同于</span><br>p.then(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fulfilled:&#x27;</span>, val))<br>  .then(<span class="hljs-literal">null</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;rejected:&quot;</span>, err));<br></code></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br>&#125;);<br>promise.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(error);<br>&#125;);<br><span class="hljs-comment">// Error: test</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法一</span><br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br>  &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>    reject(e);<br>  &#125;<br>&#125;);<br>promise.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(error);<br>&#125;);<br><br><span class="hljs-comment">// 写法二</span><br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;test&#x27;</span>));<br>&#125;);<br>promise.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(error);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误。</p>
<p>如果 Promise 状态已经变成<code>resolved</code>，再抛出错误是无效的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  resolve(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br>&#125;);<br>promise<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123; <span class="hljs-built_in">console</span>.log(value) &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123; <span class="hljs-built_in">console</span>.log(error) &#125;);<br><span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p>
<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">getJSON(<span class="hljs-string">&#x27;/post/1.json&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">post</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> getJSON(post.commentURL);<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">comments</span>) </span>&#123;<br>  <span class="hljs-comment">// some code</span><br>&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-comment">// 处理前面三个Promise产生的错误</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p>
<p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br>promise<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-comment">// success</span><br>  &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-comment">// error</span><br>  &#125;);<br><br><span class="hljs-comment">// good</span><br>promise<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123; <span class="hljs-comment">//cb</span><br>    <span class="hljs-comment">// success</span><br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-comment">// error</span><br>  &#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</p>
<p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> someAsyncThing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-comment">// 下面一行会报错，因为x没有声明</span><br>    resolve(x + <span class="hljs-number">2</span>);<br>  &#125;);<br>&#125;;<br><br>someAsyncThing().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;everything is great&#x27;</span>);<br>&#125;);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>) &#125;, <span class="hljs-number">2000</span>);<br><span class="hljs-comment">// Uncaught (in promise) ReferenceError: x is not defined</span><br><span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程、终止脚本执行，2 秒之后还是会输出<code>123</code>。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p>
<p>这个脚本放在服务器执行，退出码就是<code>0</code>（即表示执行成功）。不过，Node.js 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">process.on(<span class="hljs-string">&#x27;unhandledRejection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, p</span>) </span>&#123;<br>  <span class="hljs-keyword">throw</span> err;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>unhandledRejection</code>事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</p>
<p>注意，Node 有计划在未来废除<code>unhandledRejection</code>事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p>
<p>再看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  resolve(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;test&#x27;</span>) &#125;, <span class="hljs-number">0</span>)<br>&#125;);<br>promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123; <span class="hljs-built_in">console</span>.log(value) &#125;);<br><span class="hljs-comment">// ok</span><br><span class="hljs-comment">// Uncaught Error: test</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p>
<p>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> someAsyncThing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-comment">// 下面一行会报错，因为x没有声明</span><br>    resolve(x + <span class="hljs-number">2</span>);<br>  &#125;);<br>&#125;;<br><br>someAsyncThing()<br>.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;oh no&#x27;</span>, error);<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;carry on&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// oh no [ReferenceError: x is not defined]</span><br><span class="hljs-comment">// carry on</span><br></code></pre></td></tr></table></figure>

<p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。如果没有报错，则会跳过<code>catch()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve()<br>.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;oh no&#x27;</span>, error);<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;carry on&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// carry on</span><br></code></pre></td></tr></table></figure>

<p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p>
<p><code>catch()</code>方法之中，还能再抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> someAsyncThing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-comment">// 下面一行会报错，因为x没有声明</span><br>    resolve(x + <span class="hljs-number">2</span>);<br>  &#125;);<br>&#125;;<br><br>someAsyncThing().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> someOtherAsyncThing();<br>&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;oh no&#x27;</span>, error);<br>  <span class="hljs-comment">// 下面一行会报错，因为 y 没有声明</span><br>  y + <span class="hljs-number">2</span>;<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;carry on&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// oh no [ReferenceError: x is not defined]</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">someAsyncThing().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> someOtherAsyncThing();<br>&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;oh no&#x27;</span>, error);<br>  <span class="hljs-comment">// 下面一行会报错，因为y没有声明</span><br>  y + <span class="hljs-number">2</span>;<br>&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;carry on&#x27;</span>, error);<br>&#125;);<br><span class="hljs-comment">// oh no [ReferenceError: x is not defined]</span><br><span class="hljs-comment">// carry on [ReferenceError: y is not defined]</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p>
<h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">promise<br>.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;···&#125;)<br>.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;···&#125;)<br>.finally(<span class="hljs-function">() =&gt;</span> &#123;···&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>
<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">server.listen(port)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;)<br>  .finally(server.stop);<br></code></pre></td></tr></table></figure>

<p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<p><code>finally</code>本质上是<code>then</code>方法的特例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">promise<br>.finally(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 语句</span><br>&#125;);<br><br><span class="hljs-comment">// 等同于</span><br>promise<br>.then(<br>  result =&gt; &#123;<br>    <span class="hljs-comment">// 语句</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;,<br>  error =&gt; &#123;<br>    <span class="hljs-comment">// 语句</span><br>    <span class="hljs-keyword">throw</span> error;<br>  &#125;<br>);<br></code></pre></td></tr></table></figure>

<p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p>
<p>它的实现也很简单。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.prototype.finally = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> P = <span class="hljs-built_in">this</span>.constructor;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<br>    value  =&gt; P.resolve(callback()).then(<span class="hljs-function">() =&gt;</span> value),<br>    reason =&gt; P.resolve(callback()).then(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-keyword">throw</span> reason &#125;)<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p>
<p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// resolve 的值是 undefined</span><br><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>).then(<span class="hljs-function">() =&gt;</span> &#123;&#125;, <span class="hljs-function">() =&gt;</span> &#123;&#125;)<br><br><span class="hljs-comment">// resolve 的值是 2</span><br><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>).finally(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br><br><span class="hljs-comment">// reject 的值是 undefined</span><br><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">3</span>).then(<span class="hljs-function">() =&gt;</span> &#123;&#125;, <span class="hljs-function">() =&gt;</span> &#123;&#125;)<br><br><span class="hljs-comment">// reject 的值是 3</span><br><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">3</span>).finally(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.all([p1, p2, p3]);<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p>
<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>
<p>下面是一个具体的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 生成一个Promise对象的数组</span><br><span class="hljs-keyword">const</span> promises = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> getJSON(<span class="hljs-string">&#x27;/post/&#x27;</span> + id + <span class="hljs-string">&quot;.json&quot;</span>);<br>&#125;);<br><br><span class="hljs-built_in">Promise</span>.all(promises).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">posts</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)</span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> databasePromise = connectDatabase();<br><br><span class="hljs-keyword">const</span> booksPromise = databasePromise<br>  .then(findAllBooks);<br><br><span class="hljs-keyword">const</span> userPromise = databasePromise<br>  .then(getCurrentUser);<br><br><span class="hljs-built_in">Promise</span>.all([<br>  booksPromise,<br>  userPromise<br>])<br>.then(<span class="hljs-function">(<span class="hljs-params">[books, user]</span>) =&gt;</span> pickTopRecommendations(books, user));<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p>
<p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result)<br>.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e);<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;报错了&#x27;</span>);<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result)<br>.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e);<br><br><span class="hljs-built_in">Promise</span>.all([p1, p2])<br>.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(result))<br>.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e));<br><span class="hljs-comment">// [&quot;hello&quot;, Error: 报错了]</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p>
<p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result);<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;报错了&#x27;</span>);<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result);<br><br><span class="hljs-built_in">Promise</span>.all([p1, p2])<br>.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(result))<br>.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e));<br><span class="hljs-comment">// Error: 报错了</span><br></code></pre></td></tr></table></figure>

<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.race([p1, p2, p3]);<br></code></pre></td></tr></table></figure>

<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p>
<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.race([<br>  fetch(<span class="hljs-string">&#x27;/resource-that-may-take-a-while&#x27;</span>),<br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;request timeout&#x27;</span>)), <span class="hljs-number">5000</span>)<br>  &#125;)<br>]);<br><br>p<br>.then(<span class="hljs-built_in">console</span>.log)<br>.catch(<span class="hljs-built_in">console</span>.error);<br></code></pre></td></tr></table></figure>

<p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>
<h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h2><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promises = [<br>  fetch(<span class="hljs-string">&#x27;/api-1&#x27;</span>),<br>  fetch(<span class="hljs-string">&#x27;/api-2&#x27;</span>),<br>  fetch(<span class="hljs-string">&#x27;/api-3&#x27;</span>),<br>];<br><br><span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.allSettled(promises);<br>removeLoadingIndicator();<br></code></pre></td></tr></table></figure>

<p>上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p>
<p>该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入<code>Promise.allSettled()</code>的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> resolved = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">42</span>);<br><span class="hljs-keyword">const</span> rejected = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">-1</span>);<br><br><span class="hljs-keyword">const</span> allSettledPromise = <span class="hljs-built_in">Promise</span>.allSettled([resolved, rejected]);<br><br>allSettledPromise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">results</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(results);<br>&#125;);<br><span class="hljs-comment">// [</span><br><span class="hljs-comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 42 &#125;,</span><br><span class="hljs-comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span><br><span class="hljs-comment">// ]</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。它的监听函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应传入<code>Promise.allSettled()</code>的两个 Promise 实例。每个对象都有<code>status</code>属性，该属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>。<code>fulfilled</code>时，对象有<code>value</code>属性，<code>rejected</code>时有<code>reason</code>属性，对应两种状态的返回值。</p>
<p>下面是返回值用法的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promises = [ fetch(<span class="hljs-string">&#x27;index.html&#x27;</span>), fetch(<span class="hljs-string">&#x27;https://does-not-exist/&#x27;</span>) ];<br><span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.allSettled(promises);<br><br><span class="hljs-comment">// 过滤出成功的请求</span><br><span class="hljs-keyword">const</span> successfulPromises = results.filter(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> p.status === <span class="hljs-string">&#x27;fulfilled&#x27;</span>);<br><br><span class="hljs-comment">// 过滤出失败的请求，并输出原因</span><br><span class="hljs-keyword">const</span> errors = results<br>  .filter(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> p.status === <span class="hljs-string">&#x27;rejected&#x27;</span>)<br>  .map(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> p.reason);<br></code></pre></td></tr></table></figure>

<p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，<code>Promise.allSettled()</code>方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。<code>Promise.all()</code>方法无法做到这一点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> urls = [ <span class="hljs-comment">/* ... */</span> ];<br><span class="hljs-keyword">const</span> requests = urls.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> fetch(x));<br><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(requests);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;所有请求都成功。&#x27;</span>);<br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;至少一个请求失败，其他请求可能还没结束。&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.all()</code>无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了<code>Promise.allSettled()</code>，这就很容易了。</p>
<h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h2><p>ES2021 引入了<a href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p>
<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promises = [<br>  fetch(<span class="hljs-string">&#x27;/endpoint-a&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;a&#x27;</span>),<br>  fetch(<span class="hljs-string">&#x27;/endpoint-b&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;b&#x27;</span>),<br>  fetch(<span class="hljs-string">&#x27;/endpoint-c&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;c&#x27;</span>),<br>];<br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">const</span> first = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.any(promises);<br>  <span class="hljs-built_in">console</span>.log(first);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-built_in">console</span>.log(error);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p>
<p><code>Promise.any()</code>抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> AggregateError() <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Array</span> -&gt; AggregateError<br><br><span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> AggregateError();<br>err.push(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;first error&quot;</span>));<br>err.push(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;second error&quot;</span>));<br><span class="hljs-keyword">throw</span> err;<br></code></pre></td></tr></table></figure>

<p>捕捉错误时，如果不用<code>try...catch</code>结构和 await 命令，可以像下面这样写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.any(promises).then(<br>  (first) =&gt; &#123;<br>    <span class="hljs-comment">// Any of the promises was fulfilled.</span><br>  &#125;,<br>  (error) =&gt; &#123;<br>    <span class="hljs-comment">// All of the promises were rejected.</span><br>  &#125;<br>);<br></code></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> resolved = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">42</span>);<br><span class="hljs-keyword">var</span> rejected = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">var</span> alsoRejected = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-literal">Infinity</span>);<br><br><span class="hljs-built_in">Promise</span>.any([resolved, rejected, alsoRejected]).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(result); <span class="hljs-comment">// 42</span><br>&#125;);<br><br><span class="hljs-built_in">Promise</span>.any([rejected, alsoRejected]).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">results</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(results); <span class="hljs-comment">// [-1, Infinity]</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> jsPromise = <span class="hljs-built_in">Promise</span>.resolve($.ajax(<span class="hljs-string">&#x27;/whatever.json&#x27;</span>));<br></code></pre></td></tr></table></figure>

<p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p>
<p><code>Promise.resolve()</code>等价于下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(<span class="hljs-string">&#x27;foo&#x27;</span>))<br></code></pre></td></tr></table></figure>

<p><code>Promise.resolve()</code>方法的参数分成四种情况。</p>
<p><strong>（1）参数是一个 Promise 实例</strong></p>
<p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p>
<p><strong>（2）参数是一个<code>thenable</code>对象</strong></p>
<p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> thenable = &#123;<br>  then: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    resolve(<span class="hljs-number">42</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> thenable = &#123;<br>  then: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    resolve(<span class="hljs-number">42</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(thenable);<br>p1.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(value);  <span class="hljs-comment">// 42</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出42。</p>
<p><strong>（3）参数不是具有<code>then()</code>方法的对象，或根本就不是对象</strong></p>
<p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br><br>p.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(s)<br>&#125;);<br><span class="hljs-comment">// Hello</span><br></code></pre></td></tr></table></figure>

<p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve()</code>方法的参数，会同时传给回调函数。</p>
<p><strong>（4）不带有任何参数</strong></p>
<p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p>
<p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve();<br><br>p.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p>
<p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;three&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;two&#x27;</span>);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;one&#x27;</span>);<br><br><span class="hljs-comment">// one</span><br><span class="hljs-comment">// two</span><br><span class="hljs-comment">// three</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p>
<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(<span class="hljs-string">&#x27;出错了&#x27;</span>))<br><br>p.then(<span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(s)<br>&#125;);<br><span class="hljs-comment">// 出错了</span><br></code></pre></td></tr></table></figure>

<p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p>
<p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;出错了&#x27;</span>)<br>.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(e === <span class="hljs-string">&#x27;出错了&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> preloadImage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> Image();<br>    image.onload  = resolve;<br>    image.onerror = reject;<br>    image.src = path;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="Generator-函数与-Promise-的结合"><a href="#Generator-函数与-Promise-的结合" class="headerlink" title="Generator 函数与 Promise 的结合"></a>Generator 函数与 Promise 的结合</h3><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFoo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>)</span>&#123;<br>    resolve(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">const</span> g = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">yield</span> getFoo();<br>    <span class="hljs-built_in">console</span>.log(foo);<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-built_in">console</span>.log(e);<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span> (<span class="hljs-params">generator</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> it = generator();<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">go</span>(<span class="hljs-params">result</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (result.done) <span class="hljs-keyword">return</span> result.value;<br><br>    <span class="hljs-keyword">return</span> result.value.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> go(it.next(value));<br>    &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> go(it.throw(error));<br>    &#125;);<br>  &#125;<br><br>  go(it.next());<br>&#125;<br><br>run(g);<br></code></pre></td></tr></table></figure>

<p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p>
<h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve().then(f)<br></code></pre></td></tr></table></figure>

<p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> f = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;now&#x27;</span>);<br><span class="hljs-built_in">Promise</span>.resolve().then(f);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;next&#x27;</span>);<br><span class="hljs-comment">// next</span><br><span class="hljs-comment">// now</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p>
<p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用<code>async</code>函数来写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> f = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;now&#x27;</span>);<br>(<span class="hljs-keyword">async</span> () =&gt; f())();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;next&#x27;</span>);<br><span class="hljs-comment">// now</span><br><span class="hljs-comment">// next</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">async</span> () =&gt; f())()<br>.then(...)<br></code></pre></td></tr></table></figure>

<p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">async</span> () =&gt; f())()<br>.then(...)<br>.catch(...)<br></code></pre></td></tr></table></figure>

<p>第二种写法是使用<code>new Promise()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> f = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;now&#x27;</span>);<br>(<br>  () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<br>    resolve =&gt; resolve(f())<br>  )<br>)();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;next&#x27;</span>);<br><span class="hljs-comment">// now</span><br><span class="hljs-comment">// next</span><br></code></pre></td></tr></table></figure>

<p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p>
<p>鉴于这是一个很常见的需求，所以现在有一个<a href="https://github.com/ljharb/proposal-promise-try">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> f = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;now&#x27;</span>);<br><span class="hljs-built_in">Promise</span>.try(f);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;next&#x27;</span>);<br><span class="hljs-comment">// now</span><br><span class="hljs-comment">// next</span><br></code></pre></td></tr></table></figure>

<p>事实上，<code>Promise.try</code>存在已久，Promise 库<a href="http://bluebirdjs.com/docs/api/promise.try.html"><code>Bluebird</code></a>、<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs"><code>Q</code></a>和<a href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry"><code>when</code></a>，早就提供了这个方法。</p>
<p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">许多好处</a>，其中一点就是可以更好地管理异常。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUsername</span>(<span class="hljs-params">userId</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> database.users.get(&#123;<span class="hljs-attr">id</span>: userId&#125;)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> user.name;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">database.users.get(&#123;<span class="hljs-attr">id</span>: userId&#125;)<br>.then(...)<br>.catch(...)<br></code></pre></td></tr></table></figure>

<p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  database.users.get(&#123;<span class="hljs-attr">id</span>: userId&#125;)<br>  .then(...)<br>  .catch(...)<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.try(<span class="hljs-function">() =&gt;</span> database.users.get(&#123;<span class="hljs-attr">id</span>: userId&#125;))<br>  .then(...)<br>  .catch(...)<br></code></pre></td></tr></table></figure>

<p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p>
<h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>
<p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>
<p>前文有一个 Generator 函数，依次读取两个文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">const</span> readFile = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fileName</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    fs.readFile(fileName, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, data</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> reject(error);<br>      resolve(data);<br>    &#125;);<br>  &#125;);<br>&#125;;<br><br><span class="hljs-keyword">const</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> f1 = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">&#x27;/etc/fstab&#x27;</span>);<br>  <span class="hljs-keyword">const</span> f2 = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">&#x27;/etc/shells&#x27;</span>);<br>  <span class="hljs-built_in">console</span>.log(f1.toString());<br>  <span class="hljs-built_in">console</span>.log(f2.toString());<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> asyncReadFile = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> f1 = <span class="hljs-keyword">await</span> readFile(<span class="hljs-string">&#x27;/etc/fstab&#x27;</span>);<br>  <span class="hljs-keyword">const</span> f2 = <span class="hljs-keyword">await</span> readFile(<span class="hljs-string">&#x27;/etc/shells&#x27;</span>);<br>  <span class="hljs-built_in">console</span>.log(f1.toString());<br>  <span class="hljs-built_in">console</span>.log(f2.toString());<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p>
<p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p>
<p>（1）内置执行器。</p>
<p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">asyncReadFile();<br></code></pre></td></tr></table></figure>

<p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p>
<p>（2）更好的语义。</p>
<p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p>
<p>（3）更广的适用性。</p>
<p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p>
<p>（4）返回值是 Promise。</p>
<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>
<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>
<h2 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStockPriceByName</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> symbol = <span class="hljs-keyword">await</span> getStockSymbol(name);<br>  <span class="hljs-keyword">const</span> stockPrice = <span class="hljs-keyword">await</span> getStockPrice(symbol);<br>  <span class="hljs-keyword">return</span> stockPrice;<br>&#125;<br><br>getStockPriceByName(<span class="hljs-string">&#x27;goog&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(result);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p>
<p>下面是另一个例子，指定多少毫秒后输出一个值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params">ms</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, ms);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncPrint</span>(<span class="hljs-params">value, ms</span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> timeout(ms);<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;<br><br>asyncPrint(<span class="hljs-string">&#x27;hello world&#x27;</span>, <span class="hljs-number">50</span>);<br></code></pre></td></tr></table></figure>

<p>上面代码指定 50 毫秒以后，输出<code>hello world</code>。</p>
<p>由于<code>async</code>函数返回的是 Promise 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params">ms</span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, ms);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncPrint</span>(<span class="hljs-params">value, ms</span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> timeout(ms);<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;<br><br>asyncPrint(<span class="hljs-string">&#x27;hello world&#x27;</span>, <span class="hljs-number">50</span>);<br></code></pre></td></tr></table></figure>

<p>async 函数有多种使用形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数声明</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br><span class="hljs-comment">// 函数表达式</span><br><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><br><span class="hljs-comment">// 对象的方法</span><br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-keyword">async</span> foo() &#123;&#125; &#125;;<br>obj.foo().then(...)<br><br><span class="hljs-comment">// Class 的方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Storage</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>() &#123;<br>    <span class="hljs-built_in">this</span>.cachePromise = caches.open(<span class="hljs-string">&#x27;avatars&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">async</span> getAvatar(name) &#123;<br>    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.cachePromise;<br>    <span class="hljs-keyword">return</span> cache.match(<span class="hljs-string">`/avatars/<span class="hljs-subst">$&#123;name&#125;</span>.jpg`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> storage = <span class="hljs-keyword">new</span> Storage();<br>storage.getAvatar(<span class="hljs-string">&#x27;jake&#x27;</span>).then(…);<br><br><span class="hljs-comment">// 箭头函数</span><br><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">async</span> () =&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p>
<h3 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h3><p><code>async</code>函数返回一个 Promise 对象。</p>
<p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span>;<br>&#125;<br><br>f().then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))<br><span class="hljs-comment">// &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p>
<p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br>&#125;<br><br>f().then(<br>  v =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;resolve&#x27;</span>, v),<br>  e =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;reject&#x27;</span>, e)<br>)<br><span class="hljs-comment">//reject Error: 出错了</span><br></code></pre></td></tr></table></figure>

<h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTitle</span>(<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(url);<br>  <span class="hljs-keyword">let</span> html = <span class="hljs-keyword">await</span> response.text();<br>  <span class="hljs-keyword">return</span> html.match(<span class="hljs-regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="hljs-number">1</span>];<br>&#125;<br>getTitle(<span class="hljs-string">&#x27;https://tc39.github.io/ecma262/&#x27;</span>).then(<span class="hljs-built_in">console</span>.log)<br><span class="hljs-comment">// &quot;ECMAScript 2017 Language Specification&quot;</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p>
<h3 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h3><p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 等同于</span><br>  <span class="hljs-comment">// return 123;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-number">123</span>;<br>&#125;<br><br>f().then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))<br><span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，这时等同于<code>return 123</code>。</p>
<p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sleep</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(timeout) &#123;<br>    <span class="hljs-built_in">this</span>.timeout = timeout;<br>  &#125;<br>  then(resolve, reject) &#123;<br>    <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-built_in">setTimeout</span>(<br>      () =&gt; resolve(<span class="hljs-built_in">Date</span>.now() - startTime),<br>      <span class="hljs-built_in">this</span>.timeout<br>    );<br>  &#125;<br>&#125;<br><br>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> sleepTime = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> Sleep(<span class="hljs-number">1000</span>);<br>  <span class="hljs-built_in">console</span>.log(sleepTime);<br>&#125;)();<br><span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>await</code>命令后面是一个<code>Sleep</code>对象的实例。这个实例不是 Promise 对象，但是因为定义了<code>then</code>方法，<code>await</code>会将其视为<code>Promise</code>处理。</p>
<p>这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助<code>await</code>命令就可以让程序停顿指定的时间。下面给出了一个简化的<code>sleep</code>实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">interval</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, interval);<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 用法</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">one2FiveInAsync</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">console</span>.log(i);<br>    <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">1000</span>);<br>  &#125;<br>&#125;<br><br>one2FiveInAsync();<br></code></pre></td></tr></table></figure>

<p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br>&#125;<br><br>f()<br>.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))<br>.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e))<br><span class="hljs-comment">// 出错了</span><br></code></pre></td></tr></table></figure>

<p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p>
<p>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;hello world&#x27;</span>); <span class="hljs-comment">// 不会执行</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p>
<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br>  &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br>&#125;<br><br>f()<br>.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))<br><span class="hljs-comment">// hello world</span><br></code></pre></td></tr></table></figure>

<p>另一种方法是<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;出错了&#x27;</span>)<br>    .catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e));<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br>&#125;<br><br>f()<br>.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))<br><span class="hljs-comment">// 出错了</span><br><span class="hljs-comment">// hello world</span><br></code></pre></td></tr></table></figure>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br>  &#125;);<br>&#125;<br><br>f()<br>.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))<br>.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e))<br><span class="hljs-comment">// Error：出错了</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的 Promise 对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。</p>
<p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br>    &#125;);<br>  &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> val1 = <span class="hljs-keyword">await</span> firstStep();<br>    <span class="hljs-keyword">const</span> val2 = <span class="hljs-keyword">await</span> secondStep(val1);<br>    <span class="hljs-keyword">const</span> val3 = <span class="hljs-keyword">await</span> thirdStep(val1, val2);<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Final: &#x27;</span>, val3);<br>  &#125;<br>  <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-built_in">console</span>.error(err);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;superagent&#x27;</span>);<br><span class="hljs-keyword">const</span> NUM_RETRIES = <span class="hljs-number">3</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> i;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_RETRIES; ++i) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">await</span> superagent.get(<span class="hljs-string">&#x27;http://google.com/this-throws-an-error&#x27;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">catch</span>(err) &#123;&#125;<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 3</span><br>&#125;<br><br>test();<br></code></pre></td></tr></table></figure>

<p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p>
<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">await</span> somethingThatReturnsAPromise();<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-built_in">console</span>.log(err);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 另一种写法</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> somethingThatReturnsAPromise()<br>  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(err);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">await</span> getFoo();<br><span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">await</span> getBar();<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法一</span><br><span class="hljs-keyword">let</span> [foo, bar] = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([getFoo(), getBar()]);<br><br><span class="hljs-comment">// 写法二</span><br><span class="hljs-keyword">let</span> fooPromise = getFoo();<br><span class="hljs-keyword">let</span> barPromise = getBar();<br><span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">await</span> fooPromise;<br><span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">await</span> barPromise;<br></code></pre></td></tr></table></figure>

<p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p>
<p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dbFuc</span>(<span class="hljs-params">db</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br><br>  <span class="hljs-comment">// 报错</span><br>  docs.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>&#123;<br>    <span class="hljs-keyword">await</span> db.post(doc);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dbFuc</span>(<span class="hljs-params">db</span>) </span>&#123; <span class="hljs-comment">//这里不需要 async</span><br>  <span class="hljs-keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br><br>  <span class="hljs-comment">// 可能得到错误结果</span><br>  docs.forEach(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>&#123;<br>    <span class="hljs-keyword">await</span> db.post(doc);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码可能不会正常工作，原因是这时三个<code>db.post()</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dbFuc</span>(<span class="hljs-params">db</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> doc <span class="hljs-keyword">of</span> docs) &#123;<br>    <span class="hljs-keyword">await</span> db.post(doc);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另一种方法是使用数组的<code>reduce()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dbFuc</span>(<span class="hljs-params">db</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br><br>  <span class="hljs-keyword">await</span> docs.reduce(<span class="hljs-keyword">async</span> (_, doc) =&gt; &#123;<br>    <span class="hljs-keyword">await</span> _;<br>    <span class="hljs-keyword">await</span> db.post(doc);<br>  &#125;, <span class="hljs-literal">undefined</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面例子中，<code>reduce()</code>方法的第一个参数是<code>async</code>函数，导致该函数的第一个参数是前一步操作返回的 Promise 对象，所以必须使用<code>await</code>等待它操作结束。另外，<code>reduce()</code>方法返回的是<code>docs</code>数组最后一个成员的<code>async</code>函数的执行结果，也是一个 Promise 对象，导致在它前面也必须加上<code>await</code>。</p>
<p>上面的<code>reduce()</code>的参数函数里面没有<code>return</code>语句，原因是这个函数的主要目的是<code>db.post()</code>操作，不是返回值。而且<code>async</code>函数不管有没有<code>return</code>语句，总是返回一个 Promise 对象，所以这里的<code>return</code>是不必要的。</p>
<p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。当三个请求都会<code>resolved</code>时，下面两种写法效果相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dbFuc</span>(<span class="hljs-params">db</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br>  <span class="hljs-keyword">let</span> promises = docs.map(<span class="hljs-function">(<span class="hljs-params">doc</span>) =&gt;</span> db.post(doc));<br><br>  <span class="hljs-keyword">let</span> results = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(promises);<br>  <span class="hljs-built_in">console</span>.log(results);<br>&#125;<br><br><span class="hljs-comment">// 或者使用下面的写法</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dbFuc</span>(<span class="hljs-params">db</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br>  <span class="hljs-keyword">let</span> promises = docs.map(<span class="hljs-function">(<span class="hljs-params">doc</span>) =&gt;</span> db.post(doc));<br><br>  <span class="hljs-keyword">let</span> results = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> promise <span class="hljs-keyword">of</span> promises) &#123;<br>    results.push(<span class="hljs-keyword">await</span> promise);<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(results);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第四点，async 函数可以保留运行堆栈。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-function">() =&gt;</span> &#123;<br>  b().then(<span class="hljs-function">() =&gt;</span> c());<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>上面代码中，函数<code>a</code>内部运行了一个异步任务<code>b()</code>。当<code>b()</code>运行的时候，函数<code>a()</code>不会中断，而是继续执行。等到<code>b()</code>运行结束，可能<code>a()</code>早就运行结束了，<code>b()</code>所在的上下文环境已经消失了。如果<code>b()</code>或<code>c()</code>报错，错误堆栈将不包括<code>a()</code>。</p>
<p>现在将这个例子改成<code>async</code>函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">await</span> b();<br>  c();<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>b()</code>运行的时候，<code>a()</code>是暂停执行，上下文环境都保存着。一旦<code>b()</code>或<code>c()</code>报错，错误堆栈将包括<code>a()</code>。</p>
<h2 id="async-函数的实现原理"><a href="#async-函数的实现原理" class="headerlink" title="async 函数的实现原理"></a>async 函数的实现原理</h2><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">args</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 等同于</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">args</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> spawn(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p>
<p>下面给出<code>spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">spawn</span>(<span class="hljs-params">genF</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> gen = genF();<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step</span>(<span class="hljs-params">nextF</span>) </span>&#123;<br>      <span class="hljs-keyword">let</span> next;<br>      <span class="hljs-keyword">try</span> &#123;<br>        next = nextF();<br>      &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>        <span class="hljs-keyword">return</span> reject(e);<br>      &#125;<br>      <span class="hljs-keyword">if</span>(next.done) &#123;<br>        <span class="hljs-keyword">return</span> resolve(next.value);<br>      &#125;<br>      <span class="hljs-built_in">Promise</span>.resolve(next.value).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>&#123;<br>        step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> gen.next(v); &#125;);<br>      &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>        step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> gen.throw(e); &#125;);<br>      &#125;);<br>    &#125;<br>    step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> gen.next(<span class="hljs-literal">undefined</span>); &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="与其他异步处理方法的比较"><a href="#与其他异步处理方法的比较" class="headerlink" title="与其他异步处理方法的比较"></a>与其他异步处理方法的比较</h2><p>我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。</p>
<p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>
<p>首先是 Promise 的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chainAnimationsPromise</span>(<span class="hljs-params">elem, animations</span>) </span>&#123;<br><br>  <span class="hljs-comment">// 变量ret用来保存上一个动画的返回值</span><br>  <span class="hljs-keyword">let</span> ret = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 新建一个空的Promise</span><br>  <span class="hljs-keyword">let</span> p = <span class="hljs-built_in">Promise</span>.resolve();<br><br>  <span class="hljs-comment">// 使用then方法，添加所有动画</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> anim <span class="hljs-keyword">of</span> animations) &#123;<br>    p = p.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;<br>      ret = val;<br>      <span class="hljs-keyword">return</span> anim(elem);<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// 返回一个部署了错误捕捉机制的Promise</span><br>  <span class="hljs-keyword">return</span> p.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-comment">/* 忽略错误，继续执行 */</span><br>  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（<code>then</code>、<code>catch</code>等等），操作本身的语义反而不容易看出来。</p>
<p>接着是 Generator 函数的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chainAnimationsGenerator</span>(<span class="hljs-params">elem, animations</span>) </span>&#123;<br><br>  <span class="hljs-keyword">return</span> spawn(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> ret = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> anim <span class="hljs-keyword">of</span> animations) &#123;<br>        ret = <span class="hljs-keyword">yield</span> anim(elem);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>      <span class="hljs-comment">/* 忽略错误，继续执行 */</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在<code>spawn</code>函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的<code>spawn</code>函数就是自动执行器，它返回一个 Promise 对象，而且必须保证<code>yield</code>语句后面的表达式，必须返回一个 Promise。</p>
<p>最后是 async 函数的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chainAnimationsAsync</span>(<span class="hljs-params">elem, animations</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> ret = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> anim <span class="hljs-keyword">of</span> animations) &#123;<br>      ret = <span class="hljs-keyword">await</span> anim(elem);<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>    <span class="hljs-comment">/* 忽略错误，继续执行 */</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。</p>
<h2 id="实例：按顺序完成异步操作"><a href="#实例：按顺序完成异步操作" class="headerlink" title="实例：按顺序完成异步操作"></a>实例：按顺序完成异步操作</h2><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p>
<p>Promise 的写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logInOrder</span>(<span class="hljs-params">urls</span>) </span>&#123;<br>  <span class="hljs-comment">// 远程读取所有URL</span><br>  <span class="hljs-keyword">const</span> textPromises = urls.map(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> fetch(url).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.text());<br>  &#125;);<br><br>  <span class="hljs-comment">// 按次序输出</span><br>  textPromises.reduce(<span class="hljs-function">(<span class="hljs-params">chain, textPromise</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> chain.then(<span class="hljs-function">() =&gt;</span> textPromise)<br>      .then(<span class="hljs-function"><span class="hljs-params">text</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(text));<br>  &#125;, <span class="hljs-built_in">Promise</span>.resolve());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码使用<code>fetch</code>方法，同时远程读取一组 URL。每个<code>fetch</code>操作都返回一个 Promise 对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个 Promise 对象，然后使用<code>then</code>，将所有 Promise 对象连起来，因此就可以依次输出结果。</p>
<p>这种写法不太直观，可读性比较差。下面是 async 函数实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logInOrder</span>(<span class="hljs-params">urls</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> url <span class="hljs-keyword">of</span> urls) &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(url);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> response.text());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logInOrder</span>(<span class="hljs-params">urls</span>) </span>&#123;<br>  <span class="hljs-comment">// 并发读取远程URL</span><br>  <span class="hljs-keyword">const</span> textPromises = urls.map(<span class="hljs-keyword">async</span> url =&gt; &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(url);<br>    <span class="hljs-keyword">return</span> response.text();<br>  &#125;);<br><br>  <span class="hljs-comment">// 按次序输出</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> textPromise <span class="hljs-keyword">of</span> textPromises) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> textPromise);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码中，虽然<code>map</code>方法的参数是<code>async</code>函数，但它是并发执行的，因为只有<code>async</code>函数内部是继发执行，外部不受影响。后面的<code>for..of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。</p>
<h2 id="顶层-await"><a href="#顶层-await" class="headerlink" title="顶层 await"></a>顶层 await</h2><p>根据语法规格，<code>await</code>命令只能出现在 async 函数内部，否则都会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;https://api.example.com&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>await</code>命令独立使用，没有放在 async 函数里面，就会报错。</p>
<p>目前，有一个<a href="https://github.com/tc39/proposal-top-level-await">语法提案</a>，允许在模块的顶层独立使用<code>await</code>命令，使得上面那行代码不会报错了。这个提案的目的，是借用<code>await</code>解决模块异步加载的问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// awaiting.js</span><br><span class="hljs-keyword">let</span> output;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> dynamic = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(someMission);<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetch(url);<br>  output = someProcess(dynamic.default, data);<br>&#125;<br>main();<br><span class="hljs-keyword">export</span> &#123; output &#125;;<br></code></pre></td></tr></table></figure>

<p>上面代码中，模块<code>awaiting.js</code>的输出值<code>output</code>，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量<code>output</code>才会有值，否则就返回<code>undefined</code>。</p>
<p>上面的代码也可以写成立即执行函数的形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// awaiting.js</span><br><span class="hljs-keyword">let</span> output;<br>(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> dynamic = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(someMission);<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetch(url);<br>  output = someProcess(dynamic.default, data);<br>&#125;)();<br><span class="hljs-keyword">export</span> &#123; output &#125;;<br></code></pre></td></tr></table></figure>

<p>下面是加载这个模块的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// usage.js</span><br><span class="hljs-keyword">import</span> &#123; output &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./awaiting.js&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outputPlusValue</span>(<span class="hljs-params">value</span>) </span>&#123; <span class="hljs-keyword">return</span> output + value &#125;<br><br><span class="hljs-built_in">console</span>.log(outputPlusValue(<span class="hljs-number">100</span>));<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(outputPlusValue(<span class="hljs-number">100</span>), <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>outputPlusValue()</code>的执行结果，完全取决于执行的时间。如果<code>awaiting.js</code>里面的异步操作没执行完，加载进来的<code>output</code>的值就是<code>undefined</code>。</p>
<p>目前的解决方法，就是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// awaiting.js</span><br><span class="hljs-keyword">let</span> output;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> dynamic = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(someMission);<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetch(url);<br>  output = someProcess(dynamic.default, data);<br>&#125;)();<br><span class="hljs-keyword">export</span> &#123; output &#125;;<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>awaiting.js</code>除了输出<code>output</code>，还默认输出一个 Promise 对象（async 函数立即执行后，返回一个 Promise 对象），从这个对象判断异步操作是否结束。</p>
<p>下面是加载这个模块的新的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// usage.js</span><br><span class="hljs-keyword">import</span> promise, &#123; output &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./awaiting.js&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outputPlusValue</span>(<span class="hljs-params">value</span>) </span>&#123; <span class="hljs-keyword">return</span> output + value &#125;<br><br>promise.then(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(outputPlusValue(<span class="hljs-number">100</span>));<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(outputPlusValue(<span class="hljs-number">100</span>), <span class="hljs-number">1000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码中，将<code>awaiting.js</code>对象的输出，放在<code>promise.then()</code>里面，这样就能保证异步操作完成以后，才去读取<code>output</code>。</p>
<p>这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的<code>usage.js</code>又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载。</p>
<p>顶层的<code>await</code>命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// awaiting.js</span><br><span class="hljs-keyword">const</span> dynamic = <span class="hljs-keyword">import</span>(someMission);<br><span class="hljs-keyword">const</span> data = fetch(url);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> output = someProcess((<span class="hljs-keyword">await</span> dynamic).default, <span class="hljs-keyword">await</span> data);<br></code></pre></td></tr></table></figure>

<p>上面代码中，两个异步操作在输出的时候，都加上了<code>await</code>命令。只有等到异步操作完成，这个模块才会输出值。</p>
<p>加载这个模块的写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// usage.js</span><br><span class="hljs-keyword">import</span> &#123; output &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./awaiting.js&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outputPlusValue</span>(<span class="hljs-params">value</span>) </span>&#123; <span class="hljs-keyword">return</span> output + value &#125;<br><br><span class="hljs-built_in">console</span>.log(outputPlusValue(<span class="hljs-number">100</span>));<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(outputPlusValue(<span class="hljs-number">100</span>), <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>

<p>上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。</p>
<p>这时，模块的加载会等待依赖模块（上例是<code>awaiting.js</code>）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的<code>output</code>，不会因为加载时机的不同，而得到不一样的值。</p>
<p>注意，顶层<code>await</code>只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的<code>require()</code>是同步加载，如果有顶层<code>await</code>，就没法处理加载了。</p>
<p>下面是顶层<code>await</code>的一些使用场景。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// import() 方法加载</span><br><span class="hljs-keyword">const</span> strings = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">`/i18n/<span class="hljs-subst">$&#123;navigator.language&#125;</span>`</span>);<br><br><span class="hljs-comment">// 数据库操作</span><br><span class="hljs-keyword">const</span> connection = <span class="hljs-keyword">await</span> dbConnector();<br><br><span class="hljs-comment">// 依赖回滚</span><br><span class="hljs-keyword">let</span> jQuery;<br><span class="hljs-keyword">try</span> &#123;<br>  jQuery = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;https://cdn-a.com/jQuery&#x27;</span>);<br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>  jQuery = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;https://cdn-b.com/jQuery&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，如果加载多个包含顶层<code>await</code>命令的模块，加载命令是同步执行的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// x.js</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;X1&quot;</span>);<br><span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(r, <span class="hljs-number">1000</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;X2&quot;</span>);<br><br><span class="hljs-comment">// y.js</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Y&quot;</span>);<br><br><span class="hljs-comment">// z.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./x.js&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./y.js&quot;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Z&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>上面代码有三个模块，最后的<code>z.js</code>加载<code>x.js</code>和<code>y.js</code>，打印结果是<code>X1</code>、<code>Y</code>、<code>X2</code>、<code>Z</code>。这说明，<code>z.js</code>并没有等待<code>x.js</code>加载完成，再去加载<code>y.js</code>。</p>
<p>顶层的<code>await</code>命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// CommonJS模块</span><br><span class="hljs-keyword">let</span> &#123; stat, exists, readfile &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> _fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">let</span> stat = _fs.stat;<br><span class="hljs-keyword">let</span> exists = _fs.exists;<br><span class="hljs-keyword">let</span> readfile = _fs.readfile;<br></code></pre></td></tr></table></figure>

<p>上面代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>
<p>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES6模块</span><br><span class="hljs-keyword">import</span> &#123; stat, exists, readFile &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>上面代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>
<p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p>
<p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p>
<ul>
<li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li>
<li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li>
<li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li>
</ul>
<p>本章介绍 ES6 模块的语法，下一章介绍如何在浏览器和 Node 之中，加载 ES6 模块。</p>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p>
<p>严格模式主要有以下限制。</p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用<code>with</code>语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀 0 表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>
<li><code>eval</code>不会在它的外层作用域引入变量</li>
<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>
<li><code>arguments</code>不会自动反映函数参数的变化</li>
<li>不能使用<code>arguments.callee</code></li>
<li>不能使用<code>arguments.caller</code></li>
<li>禁止<code>this</code>指向全局对象</li>
<li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>
<li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li>
</ul>
<p>上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本书不再详细介绍了。</p>
<p>其中，尤其需要注意<code>this</code>的限制。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code>。</p>
<h2 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h2><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p>
<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// profile.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<br></code></pre></td></tr></table></figure>

<p>上面代码是<code>profile.js</code>文件，保存了用户信息。ES6 将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p>
<p><code>export</code>的写法，除了像上面这样，还有另外一种。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// profile.js</span><br><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br><span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<br><br><span class="hljs-keyword">export</span> &#123; firstName, lastName, year &#125;;<br></code></pre></td></tr></table></figure>

<p>上面代码在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在<code>var</code>语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p>
<p><code>export</code>命令除了输出变量，还可以输出函数或类（class）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x * y;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>上面代码对外输出一个函数<code>multiply</code>。</p>
<p>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">v1</span>(<span class="hljs-params"></span>) </span>&#123; ... &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">v2</span>(<span class="hljs-params"></span>) </span>&#123; ... &#125;<br><br><span class="hljs-keyword">export</span> &#123;<br>  v1 <span class="hljs-keyword">as</span> streamV1,<br>  v2 <span class="hljs-keyword">as</span> streamV2,<br>  v2 <span class="hljs-keyword">as</span> streamLatestVersion<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p>
<p>需要特别注意的是，<code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">export</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">export</span> m;<br></code></pre></td></tr></table></figure>

<p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量<code>m</code>，还是直接输出 1。<code>1</code>只是一个值，不是接口。正确的写法是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法一</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 写法二</span><br><span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">export</span> &#123;m&#125;;<br><br><span class="hljs-comment">// 写法三</span><br><span class="hljs-keyword">var</span> n = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">export</span> &#123;n <span class="hljs-keyword">as</span> m&#125;;<br></code></pre></td></tr></table></figure>

<p>上面三种写法都是正确的，规定了对外的接口<code>m</code>。其他脚本可以通过这个接口，取到值<code>1</code>。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p>
<p>同样的，<code>function</code>和<code>class</code>的输出，也必须遵守这样的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">export</span> f;<br><br><span class="hljs-comment">// 正确</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br><br><span class="hljs-comment">// 正确</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">export</span> &#123;f&#125;;<br></code></pre></td></tr></table></figure>

<p>另外，<code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> foo = <span class="hljs-string">&#x27;bar&#x27;</span>;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> foo = <span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-number">500</span>);<br></code></pre></td></tr></table></figure>

<p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500 毫秒之后变成<code>baz</code>。</p>
<p>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新，详见下文《Module 的加载实现》一节。</p>
<p>最后，<code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;bar&#x27;</span> <span class="hljs-comment">// SyntaxError</span><br>&#125;<br>foo()<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>export</code>语句放在函数之中，结果报错。</p>
<h2 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h2><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; firstName, lastName, year &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./profile.js&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setName</span>(<span class="hljs-params">element</span>) </span>&#123;<br>  element.textContent = firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码的<code>import</code>命令，用于加载<code>profile.js</code>文件，并从中输入变量。<code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p>
<p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; lastName <span class="hljs-keyword">as</span> surname &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./profile.js&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><code>import</code>命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;a&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./xxx.js&#x27;</span><br><br>a = &#123;&#125;; <span class="hljs-comment">// Syntax Error : &#x27;a&#x27; is read-only;</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，脚本加载了变量<code>a</code>，对其重新赋值就会报错，因为<code>a</code>是一个只读的接口。但是，如果<code>a</code>是一个对象，改写<code>a</code>的属性是允许的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;a&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./xxx.js&#x27;</span><br><br>a.foo = <span class="hljs-string">&#x27;hello&#x27;</span>; <span class="hljs-comment">// 合法操作</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。</p>
<p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径。如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; myMethod &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;util&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>util</code>是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p>
<p>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">foo();<br><br><span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;my_module&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。</p>
<p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-string">&#x27;f&#x27;</span> + <span class="hljs-string">&#x27;oo&#x27;</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;my_module&#x27;</span>;<br><br><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">let</span> <span class="hljs-built_in">module</span> = <span class="hljs-string">&#x27;my_module&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-built_in">module</span>;<br><br><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">if</span> (x === <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module1&#x27;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module2&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面三种写法都会报错，因为它们用到了表达式、变量和<code>if</code>结构。在静态分析阶段，这些语法都是没法得到值的。</p>
<p>最后，<code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p>
<p>如果多次重复执行同一句<code>import</code>语句，那么只会执行一次，而不会执行多次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>上面代码加载了两次<code>lodash</code>，但是只会执行一次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;my_module&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; bar &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;my_module&#x27;</span>;<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">import</span> &#123; foo, bar &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;my_module&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>上面代码中，虽然<code>foo</code>和<code>bar</code>在两个语句中加载，但是它们对应的是同一个<code>my_module</code>模块。也就是说，<code>import</code>语句是 Singleton 模式。</p>
<p>目前阶段，通过 Babel 转码，CommonJS 模块的<code>require</code>命令和 ES6 模块的<code>import</code>命令，可以写在同一个模块里面，但是最好不要这样做。因为<code>import</code>在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;core-js/modules/es6.symbol&#x27;</span>);<br><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;core-js/modules/es6.promise&#x27;</span>);<br><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;React&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h2 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</p>
<p>下面是一个<code>circle.js</code>文件，它输出两个方法<code>area</code>和<code>circumference</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// circle.js</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">area</span>(<span class="hljs-params">radius</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.PI * radius * radius;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">circumference</span>(<span class="hljs-params">radius</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI * radius;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，加载这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><br><span class="hljs-keyword">import</span> &#123; area, circumference &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./circle&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;圆面积：&#x27;</span> + area(<span class="hljs-number">4</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;圆周长：&#x27;</span> + circumference(<span class="hljs-number">14</span>));<br></code></pre></td></tr></table></figure>

<p>上面写法是逐一指定要加载的方法，整体加载的写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> circle <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./circle&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;圆面积：&#x27;</span> + circle.area(<span class="hljs-number">4</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;圆周长：&#x27;</span> + circle.circumference(<span class="hljs-number">14</span>));<br></code></pre></td></tr></table></figure>

<p>注意，模块整体加载所在的那个对象（上例是<code>circle</code>），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> circle <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./circle&#x27;</span>;<br><br><span class="hljs-comment">// 下面两行都是不允许的</span><br>circle.foo = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>circle.area = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h2><p>从前面的例子可以看出，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p>
<p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<code>export default</code>命令，为模块指定默认输出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// export-default.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p>
<p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// import-default.js</span><br><span class="hljs-keyword">import</span> customName <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./export-default&#x27;</span>;<br>customName(); <span class="hljs-comment">// &#x27;foo&#x27;</span><br></code></pre></td></tr></table></figure>

<p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p>
<p><code>export default</code>命令用在非匿名函数前，也是可以的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// export-default.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 或者写成</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> foo;<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>foo</code>函数的函数名<code>foo</code>，在模块外部是无效的。加载的时候，视同匿名函数加载。</p>
<p>下面比较一下默认输出和正常输出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一组</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">crc32</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 输出</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">import</span> crc32 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;crc32&#x27;</span>; <span class="hljs-comment">// 输入</span><br><br><span class="hljs-comment">// 第二组</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">crc32</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 输出</span><br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">import</span> &#123;crc32&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;crc32&#x27;</span>; <span class="hljs-comment">// 输入</span><br></code></pre></td></tr></table></figure>

<p>上面代码的两组写法，第一组是使用<code>export default</code>时，对应的<code>import</code>语句不需要使用大括号；第二组是不使用<code>export default</code>时，对应的<code>import</code>语句需要使用大括号。</p>
<p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令。</p>
<p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// modules.js</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x * y;<br>&#125;<br><span class="hljs-keyword">export</span> &#123;add <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>&#125;;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-comment">// export default add;</span><br><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;modules&#x27;</span>;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-comment">// import foo from &#x27;modules&#x27;;</span><br></code></pre></td></tr></table></figure>

<p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 正确</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 正确</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> a;<br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>export default a</code>的含义是将变量<code>a</code>的值赋给变量<code>default</code>。所以，最后一种写法会报错。</p>
<p>同样地，因为<code>export default</code>命令的本质是将后面的值，赋给<code>default</code>变量，所以可以直接将一个值写在<code>export default</code>之后。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 正确</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-number">42</span>;<br><br><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">export</span> <span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure>

<p>上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为<code>default</code>。</p>
<p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入 lodash 模块为例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>如果想在一条<code>import</code>语句中，同时输入默认方法和其他接口，可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> _, &#123; each, forEach &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>对应上面代码的<code>export</code>语句如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-comment">// ···</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">each</span>(<span class="hljs-params">obj, iterator, context</span>) </span>&#123;<br>  <span class="hljs-comment">// ···</span><br>&#125;<br><br><span class="hljs-keyword">export</span> &#123; each <span class="hljs-keyword">as</span> forEach &#125;;<br></code></pre></td></tr></table></figure>

<p>上面代码的最后一行的意思是，暴露出<code>forEach</code>接口，默认指向<code>each</code>接口，即<code>forEach</code>和<code>each</code>指向同一个方法。</p>
<p><code>export default</code>也可以用来输出类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// MyClass.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> </span>&#123; ... &#125;<br><br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> MyClass <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;MyClass&#x27;</span>;<br><span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> MyClass();<br></code></pre></td></tr></table></figure>

<h2 id="export-与-import-的复合写法"><a href="#export-与-import-的复合写法" class="headerlink" title="export 与 import 的复合写法"></a>export 与 import 的复合写法</h2><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> &#123; foo, bar &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;my_module&#x27;</span>;<br><br><span class="hljs-comment">// 可以简单理解为</span><br><span class="hljs-keyword">import</span> &#123; foo, bar &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;my_module&#x27;</span>;<br><span class="hljs-keyword">export</span> &#123; foo, bar &#125;;<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>export</code>和<code>import</code>语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，<code>foo</code>和<code>bar</code>实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用<code>foo</code>和<code>bar</code>。</p>
<p>模块的接口改名和整体输出，也可以采用这种写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 接口改名</span><br><span class="hljs-keyword">export</span> &#123; foo <span class="hljs-keyword">as</span> myFoo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;my_module&#x27;</span>;<br><br><span class="hljs-comment">// 整体输出</span><br><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;my_module&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>默认接口的写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;foo&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>具名接口改为默认接口的写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> &#123; es6 <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./someModule&#x27;</span>;<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">import</span> &#123; es6 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./someModule&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> es6;<br></code></pre></td></tr></table></figure>

<p>同样地，默认接口也可以改名为具名接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> es6 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./someModule&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>ES2020 之前，有一种<code>import</code>语句，没有对应的复合写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> someIdentifier <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;someModule&quot;</span>;<br></code></pre></td></tr></table></figure>

<p><a href="https://github.com/tc39/proposal-export-ns-from">ES2020</a>补上了这个写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> * <span class="hljs-keyword">as</span> ns <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mod&quot;</span>;<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ns <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mod&quot;</span>;<br><span class="hljs-keyword">export</span> &#123;ns&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h2><p>模块之间也可以继承。</p>
<p>假设有一个<code>circleplus</code>模块，继承了<code>circle</code>模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// circleplus.js</span><br><br><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;circle&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> e = <span class="hljs-number">2.71828182846</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.exp(x);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码中的<code>export *</code>，表示再输出<code>circle</code>模块的所有属性和方法。注意，<code>export *</code>命令会忽略<code>circle</code>模块的<code>default</code>方法。然后，上面代码又输出了自定义的<code>e</code>变量和默认方法。</p>
<p>这时，也可以将<code>circle</code>的属性或方法，改名后再输出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// circleplus.js</span><br><br><span class="hljs-keyword">export</span> &#123; area <span class="hljs-keyword">as</span> circleArea &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;circle&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>上面代码表示，只输出<code>circle</code>模块的<code>area</code>方法，且将其改名为<code>circleArea</code>。</p>
<p>加载上面模块的写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> math <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;circleplus&#x27;</span>;<br><span class="hljs-keyword">import</span> exp <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;circleplus&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(exp(math.e));<br></code></pre></td></tr></table></figure>

<p>上面代码中的<code>import exp</code>表示，将<code>circleplus</code>模块的默认方法加载为<code>exp</code>方法。</p>
<h2 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h2><p>本书介绍<code>const</code>命令的时候说过，<code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// constants.js 模块</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> A = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> B = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> C = <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">// test1.js 模块</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> constants <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./constants&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(constants.A); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(constants.B); <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// test2.js 模块</span><br><span class="hljs-keyword">import</span> &#123;A, B&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./constants&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(A); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(B); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<p>如果要使用的常量非常多，可以建一个专门的<code>constants</code>目录，将各种常量写在不同的文件里面，保存在该目录下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// constants/db.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> db = &#123;<br>  url: <span class="hljs-string">&#x27;http://my.couchdbserver.local:5984&#x27;</span>,<br>  admin_username: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>  admin_password: <span class="hljs-string">&#x27;admin password&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// constants/user.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> users = [<span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;staff&#x27;</span>, <span class="hljs-string">&#x27;ceo&#x27;</span>, <span class="hljs-string">&#x27;chief&#x27;</span>, <span class="hljs-string">&#x27;moderator&#x27;</span>];<br></code></pre></td></tr></table></figure>

<p>然后，将这些文件输出的常量，合并在<code>index.js</code>里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// constants/index.js</span><br><span class="hljs-keyword">export</span> &#123;db&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./db&#x27;</span>;<br><span class="hljs-keyword">export</span> &#123;users&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./users&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>使用的时候，直接加载<code>index.js</code>就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// script.js</span><br><span class="hljs-keyword">import</span> &#123;db, users&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./constants/index&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h2 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>前面介绍过，<code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（<code>import</code>命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">if</span> (x === <span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-keyword">import</span> MyModual <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./myModual&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码中，引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，<code>import</code>和<code>export</code>命令只能在模块的顶层，不能在代码块之中（比如，在<code>if</code>代码块之中，或在函数之中）。</p>
<p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果<code>import</code>命令要取代 Node 的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-string">&#x27;./&#x27;</span> + fileName;<br><span class="hljs-keyword">const</span> myModual = <span class="hljs-built_in">require</span>(path);<br></code></pre></td></tr></table></figure>

<p>上面的语句就是动态加载，<code>require</code>到底加载哪一个模块，只有运行时才知道。<code>import</code>命令做不到这一点。</p>
<p><a href="https://github.com/tc39/proposal-dynamic-import">ES2020提案</a> 引入<code>import()</code>函数，支持动态加载模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span>(specifier)<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</p>
<p><code>import()</code>返回一个 Promise 对象。下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> main = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;main&#x27;</span>);<br><br><span class="hljs-keyword">import</span>(<span class="hljs-string">`./section-modules/<span class="hljs-subst">$&#123;someVariable&#125;</span>.js`</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">module</span>.loadPageInto(main);<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    main.textContent = err.message;<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。<code>import()</code>类似于 Node 的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。</p>
<h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><p>下面是<code>import()</code>的一些适用场合。</p>
<p>（1）按需加载。</p>
<p><code>import()</code>可以在需要的时候，再加载某个模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">button.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./dialogBox.js&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">dialogBox</span> =&gt;</span> &#123;<br>    dialogBox.open();<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">/* Error handling */</span><br>  &#125;)<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>import()</code>方法放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p>
<p>（2）条件加载</p>
<p><code>import()</code>可以放在<code>if</code>代码块，根据不同的情况，加载不同的模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (condition) &#123;<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;moduleA&#x27;</span>).then(...);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;moduleB&#x27;</span>).then(...);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。</p>
<p>（3）动态的模块路径</p>
<p><code>import()</code>允许模块路径动态生成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span>(f())<br>.then(...);<br></code></pre></td></tr></table></figure>

<p>上面代码中，根据函数<code>f</code>的返回结果，加载不同的模块。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><code>import()</code>加载模块成功以后，这个模块会作为一个对象，当作<code>then</code>方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./myModule.js&#x27;</span>)<br>.then(<span class="hljs-function">(<span class="hljs-params">&#123;export1, export2&#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...·</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>export1</code>和<code>export2</code>都是<code>myModule.js</code>的输出接口，可以解构获得。</p>
<p>如果模块有<code>default</code>输出接口，可以用参数直接获得。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./myModule.js&#x27;</span>)<br>.then(<span class="hljs-function"><span class="hljs-params">myModule</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(myModule.default);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面的代码也可以使用具名输入的形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./myModule.js&#x27;</span>)<br>.then(<span class="hljs-function">(<span class="hljs-params">&#123;<span class="hljs-keyword">default</span>: theDefault&#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(theDefault);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>如果想同时加载多个模块，可以采用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.all([<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module1.js&#x27;</span>),<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module2.js&#x27;</span>),<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module3.js&#x27;</span>),<br>])<br>.then(<span class="hljs-function">(<span class="hljs-params">[module1, module2, module3]</span>) =&gt;</span> &#123;<br>   ···<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><code>import()</code>也可以用在 async 函数之中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> myModule = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./myModule.js&#x27;</span>);<br>  <span class="hljs-keyword">const</span> &#123;export1, export2&#125; = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./myModule.js&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [module1, module2, module3] =<br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([<br>      <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module1.js&#x27;</span>),<br>      <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module2.js&#x27;</span>),<br>      <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module3.js&#x27;</span>),<br>    ]);<br>&#125;<br>main();<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
</search>
