

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>vue源码理解——模板编译篇 - cocacola</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />

  
  
  <meta name="description" content="模板编译：在前几篇文章中，我们介绍了Vue中的虚拟DO..."> 
  
  <meta name="author" content="lc"> 

  
    <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  
  
    <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  
  
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  
  
    <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_h1619vhl1nr.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css">

  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        loadingImage: '',
      },
      donate: {
        enable: true,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      motto: {
        api: '',
        default: '将喜欢的一切留在身边，这便是努力的意义。'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        alwaysShow: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: true
      }
    }
  </script>

  

  
<meta name="generator" content="Hexo 5.4.0"></head>
<body class="lock-screen">
  <div class="loading"></div>
  


<nav class="navbar">
  <div class="left"></div>
  <div class="center">vue源码理解——模板编译篇</div>
  <div class="right">
    <i class="iconfont iconmenu j-navbar-menu"></i>
  </div>
</nav>

  <nav class="menu">
  <div class="menu-wrap">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content">
      
      
      
      
      <li class="menu-item"><a href="/ " class="underline"> 首页</a></li>
      
      
      
      
      <li class="menu-item"><a href="/galleries " class="underline"> 摄影</a></li>
      
      
      
      
      <li class="menu-item"><a href="/archives " class="underline"> 归档</a></li>
      
      
      
      
      <li class="menu-item"><a href="/tags " class="underline"> 标签</a></li>
      
      
      
      
      <li class="menu-item"><a href="/categories " class="underline"> 分类</a></li>
      
      
      
      
      <li class="menu-item"><a href="/about " class="underline"> 关于</a></li>
      
    </ul>
    <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  </div>
</nav>
  <main id="main">
  <div class="container" id="container">
    <article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1624873271622-80f42255a42e.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">vue源码理解——模板编译篇</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>March 18, 2021</span
        class="post-info-item">
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>25758</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h4 id="模板编译："><a href="#模板编译：" class="headerlink" title="模板编译："></a>模板编译：</h4><p>在前几篇文章中，我们介绍了<code>Vue</code>中的虚拟<code>DOM</code>以及虚拟<code>DOM</code>的<code>patch</code>(DOM-Diff)过程，而虚拟<code>DOM</code>存在的必要条件是得先有<code>VNode</code>，那么<code>VNode</code>又是从哪儿来的呢？这就是接下来几篇文章要说的模板编译。你可以这么理解：把用户写的模板进行编译，就会产生<code>VNode</code>。</p>
<h5 id="什么是模板编译"><a href="#什么是模板编译" class="headerlink" title="什么是模板编译"></a>什么是模板编译</h5><p>我们知道，在日常开发中，我们把写在<code>&lt;template&gt;&lt;/template&gt;</code>标签中的类似于原生<code>HTML</code>的内容称之为模板。这时你可能会问了，为什么说是“类似于原生<code>HTML</code>的内容”而不是“就是<code>HTML</code>的内容”？因为我们在开发中，在<code>&lt;template&gt;&lt;/template&gt;</code>标签中除了写一些原生<code>HTML</code>的标签，我们还会写一些变量插值，如，或者写一些<code>Vue</code>指令，如<code>v-on</code>、<code>v-if</code>等。而这些东西都是在原生<code>HTML</code>语法中不存在的，不被接受的。但是事实上我们确实这么写了，也被正确识别了，页面也正常显示了，这又是为什么呢？</p>
<p>这就归功于<code>Vue</code>的模板编译了，<code>Vue</code>会把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生<code>HTML</code>的内容进行编译，把原生<code>HTML</code>的内容找出来，再把非原生<code>HTML</code>找出来，经过一系列的逻辑处理生成渲染函数，也就是<code>render</code>函数，而<code>render</code>函数会将模板内容生成对应的<code>VNode</code>，而<code>VNode</code>再经过前几篇文章介绍的<code>patch</code>过程从而得到将要渲染的视图中的<code>VNode</code>，最后根据<code>VNode</code>创建真实的<code>DOM</code>节点并插入到视图中， 最终完成视图的渲染更新。</p>
<p>而把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生<code>HTML</code>的内容进行编译，把原生<code>HTML</code>的内容找出来，再把非原生<code>HTML</code>找出来，经过一系列的逻辑处理生成渲染函数，也就是<code>render</code>函数的这一段过程称之为模板编译过程。</p>
<h6 id="整体渲染流程"><a href="#整体渲染流程" class="headerlink" title="整体渲染流程"></a>整体渲染流程</h6><p>所谓渲染流程，就是把用户写的类似于原生<code>HTML</code>的模板经过一系列处理最终反应到视图中称之为整个渲染流程。这个流程在上文中其实已经说到了，下面我们以流程图的形式宏观的了解一下，流程图如下：</p>
<p><img   class="lazyload" data-original="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425144813349.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20210425144813349"></p>
<p>从图中我们也可以看到，模板编译过程就是把用户写的模板经过一系列处理最终生成<code>render</code>函数的过程。</p>
<h6 id="模板编译内部流程"><a href="#模板编译内部流程" class="headerlink" title="模板编译内部流程"></a>模板编译内部流程</h6><p>那么模板编译内部是怎么把用户写的模板经过处理最终生成<code>render</code>函数的呢？这内部的过程是怎样的呢？</p>
<h6 id="抽象语法树AST"><a href="#抽象语法树AST" class="headerlink" title="抽象语法树AST"></a>抽象语法树AST</h6><p>我们知道，用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的模板对<code>Vue</code>来说就是一堆字符串，那么如何解析这一堆字符串并且从中提取出元素的标签、属性、变量插值等有效信息呢？这就需要借助一个叫做抽象语法树的东西。</p>
<p>所谓抽象语法树，在计算机科学中，<strong>抽象语法树</strong>（<strong>A</strong>bstract<strong>S</strong>yntax<strong>T</strong>ree，AST），或简称<strong>语法树</strong>（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于if-condition-then这样的条件跳转语句，可以使用带有两个分支的节点来表示。——来自百度百科</p>
<p>我就知道，这段话贴出来也是白贴，因为看了也看不懂，哈哈。那么我们就以最直观的例子来理解什么是抽象语法树。请看下图：</p>
<p><img   class="lazyload" data-original="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210425144910621.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20210425144910621"></p>
<p>从图中我们可以看到，一个简单的<code>HTML</code>标签的代码被转换成了一个<code>JS</code>对象，而这个对象中的属性代表了这个标签中一些关键有效信息。如图中标识。 有兴趣的同学可以在这个网站在线转换试试：<a target="_blank" rel="noopener" href="https://astexplorer.net/">https://astexplorer.net/</a></p>
<h6 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程:"></a>具体流程:</h6><p>将一堆字符串模板解析成抽象语法树<code>AST</code>后，我们就可以对其进行各种操作处理了，处理完后用处理后的<code>AST</code>来生成<code>render</code>函数。其具体流程可大致分为三个阶段：</p>
<ol>
<li>模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树<code>AST</code>；</li>
<li>优化阶段：遍历<code>AST</code>，找出其中的静态节点，并打上标记；</li>
<li>代码生成阶段：将<code>AST</code>转换成渲染函数；</li>
</ol>
<p>这三个阶段在源码中分别对应三个模块，下面给出三个模块的源代码在源码中的路径：</p>
<ol>
<li>模板解析阶段——解析器——源码路径：<code>src/compiler/parser/index.js</code>;</li>
<li>优化阶段——优化器——源码路径：<code>src/compiler/optimizer.js</code>;</li>
<li>代码生成阶段——代码生成器——源码路径：<code>src/compiler/codegen/index.js</code>; 其对应的源码如下：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 源码位置: /src/complier/index.js</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createCompiler = createCompilerCreator(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseCompile</span> (<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  template: string,</span></span><br><span class="hljs-function"><span class="hljs-params">  options: CompilerOptions</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">CompiledResult</span> </span>&#123;<br>  <span class="hljs-comment">// 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST</span><br>  <span class="hljs-keyword">const</span> ast = parse(template.trim(), options)<br>  <span class="hljs-keyword">if</span> (options.optimize !== <span class="hljs-literal">false</span>) &#123;<br>    <span class="hljs-comment">// 优化阶段：遍历AST，找出其中的静态节点，并打上标记；</span><br>    optimize(ast, options)<br>  &#125;<br>  <span class="hljs-comment">// 代码生成阶段：将AST转换成渲染函数；</span><br>  <span class="hljs-keyword">const</span> code = generate(ast, options)<br>  <span class="hljs-keyword">return</span> &#123;<br>    ast,<br>    render: code.render,<br>    staticRenderFns: code.staticRenderFns<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>可以看到 <code>baseCompile</code> 的代码非常的简短主要核心代码。</p>
<ul>
<li><strong>const ast =parse(template.trim(), options)</strong>:<code>parse</code> 会用正则等方式解析 <code>template</code> 模板中的指令、<code>class</code>、<code>style</code>等数据，形成<code>AST</code>。</li>
<li><strong>optimize(ast, options)</strong>: <code>optimize</code> 的主要作用是标记静态节点，这是 <code>Vue</code> 在编译过程中的一处优化，挡在进行<code>patch</code> 的过程中， <code>DOM-Diff</code> 算法会直接跳过静态节点，从而减少了比较的过程，优化了 <code>patch</code> 的性能。</li>
<li><strong>const code =generate(ast, options)</strong>: 将 <code>AST</code> 转化成 <code>render</code>函数字符串的过程，得到结果是 <code>render</code>函数 的字符串以及 <code>staticRenderFns</code> 字符串。</li>
</ul>
<p>最终 <code>baseCompile</code> 的返回值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br> 	ast: ast,<br> 	render: code.render,<br> 	staticRenderFns: code.staticRenderFns<br> &#125;<br></code></pre></td></tr></table></figure>

<p>最终返回了抽象语法树( ast )，渲染函数( render )，静态渲染函数( staticRenderFns )，且<code>render</code> 的值为<code>code.render</code>，<code>staticRenderFns</code> 的值为<code>code.staticRenderFns</code>，也就是说通过 <code>generate</code>处理 <code>ast</code>之后得到的返回值 <code>code</code> 是一个对象。</p>
<p>下面再给出模板编译内部具体流程图，便于理解。流程图如下： <img   class="lazyload" data-original="https://vue-js.com/learn-vue/assets/img/3.15d9566b.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="img"></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>本篇文章首先引出了为什么会有模板编译，因为有了模板编译，才有了虚拟<code>DOM</code>，才有了后续的视图更新。接着介绍了什么是模板编译，以及介绍了把用户所写的模板经过层层处理直到最终渲染的视图中这个整体的渲染流程；最后介绍了模板编译过程中所需要使用的抽象语法树的概念以及分析了模板编译的具体实施流程，其流程大致分为三个阶段，分别是模板解析阶段、优化阶段和代码生成阶段。那么接下来的几篇文章将会把这三个阶段逐一进行分析介绍。</p>
<h5 id="1-整体流程"><a href="#1-整体流程" class="headerlink" title="1. 整体流程"></a>1. 整体流程</h5><p>上篇文章中我们说了，在模板解析阶段主要做的工作是把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签内写的模板使用正则等方式解析成抽象语法树（<code>AST</code>）。而这一阶段在源码中对应解析器（<code>parser</code>）模块。</p>
<p>解析器，顾名思义，就是把用户所写的模板根据一定的解析规则解析出有效的信息，最后用这些信息形成<code>AST</code>。我们知道在<code>&lt;template&gt;&lt;/template&gt;</code>模板内，除了有常规的<code>HTML</code>标签外，用户还会一些文本信息以及在文本信息中包含过滤器。而这些不同的内容在解析起来肯定需要不同的解析规则，所以解析器不可能只有一个，它应该除了有解析常规<code>HTML</code>的HTML解析器，还应该有解析文本的文本解析器以及解析文本中如果包含过滤器的过滤器解析器。</p>
<p>另外，文本信息和标签属性信息却又是存在于HTML标签之内的，所以在解析整个模板的时候它的流程应该是这样子的：HTML解析器是主线，先用HTML解析器进行解析整个模板，在解析过程中如果碰到文本内容，那就调用文本解析器来解析文本，如果碰到文本中包含过滤器那就调用过滤器解析器来解析。如下图所示：</p>
<p><img   class="lazyload" data-original="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210428165451685.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20210428165451685"></p>
<h5 id="2-回到源码"><a href="#2-回到源码" class="headerlink" title="2. 回到源码"></a>2. 回到源码</h5><p>解析器的源码位于<code>/src/complier/parser</code>文件夹下，其主线代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 代码位置：/src/complier/parser/index.js</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Convert HTML string to AST.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span>(<span class="hljs-params">template, options</span>) </span>&#123;<br>   <span class="hljs-comment">// ...</span><br>  parseHTML(template, &#123;<br>    warn,<br>    expectHTML: options.expectHTML,<br>    isUnaryTag: options.isUnaryTag,<br>    canBeLeftOpenTag: options.canBeLeftOpenTag,<br>    shouldDecodeNewlines: options.shouldDecodeNewlines,<br>    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,<br>    shouldKeepComment: options.comments,<br>    start (tag, attrs, unary) &#123;<br><br>    &#125;,<br>    end () &#123;<br><br>    &#125;,<br>    chars (text: string) &#123;<br><br>    &#125;,<br>    comment (text: string) &#123;<br><br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面代码中可以看到，<code>parse</code> 函数就是解析器的主函数，在<code>parse</code> 函数内调用了<code>parseHTML</code> 函数对模板字符串进行解析，在<code>parseHTML</code> 函数解析模板字符串的过程中，如果遇到文本信息，就会调用文本解析器<code>parseText</code>函数进行文本解析；如果遇到文本中包含过滤器，就会调用过滤器解析器<code>parseFilters</code>函数进行解析。</p>
<h5 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h5><p>本篇文章主要梳理了模板解析的整体运行流程，模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为HTML解析器，文本解析器和过滤器解析器。而文本信息与过滤器信息又存在于HTML标签中，所以在解析器主线函数<code>parse</code>中先调用HTML解析器<code>parseHTML</code> 函数对模板字符串进行解析，如果在解析过程中遇到文本或过滤器信息则再调用相应的解析器进行解析，最终完成对整个模板字符串的解析。</p>
<p>了解了模板解析阶段的整体运行流程后，接下来，我们就对流程中所涉及到的三种解析器分别深入分析，逐个击破。</p>
<p>上篇文章中我们说到，在模板解析阶段主线函数<code>parse</code>中，根据要解析的内容不同会调用不同的解析器，</p>
<p>而在三个不同的解析器中最主要的当属<code>HTML</code>解析器，为什么这么说呢？因为<code>HTML</code>解析器主要负责解析出模板字符串中有哪些内容，然后根据不同的内容才能调用其他的解析器以及做相应的处理。那么本篇文章就来介绍一下<code>HTML</code>解析器是如何解析出模板字符串中包含的不同的内容的。</p>
<h5 id="解析器内部运行流程"><a href="#解析器内部运行流程" class="headerlink" title="解析器内部运行流程"></a>解析器内部运行流程</h5><h5 id="2-HTML解析器内部运行流程"><a href="#2-HTML解析器内部运行流程" class="headerlink" title="2. HTML解析器内部运行流程"></a>2. HTML解析器内部运行流程</h5><p>在源码中，<code>HTML</code>解析器就是<code>parseHTML</code>函数，在模板解析主线函数<code>parse</code>中调用了该函数，并传入两个参数，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 代码位置：/src/complier/parser/index.js</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Convert HTML string to AST.</span><br><span class="hljs-comment"> * 将HTML模板字符串转化为AST</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span>(<span class="hljs-params">template, options</span>) </span>&#123;<br>   <span class="hljs-comment">// ...</span><br>  parseHTML(template, &#123;<br>    warn,<br>    expectHTML: options.expectHTML,<br>    isUnaryTag: options.isUnaryTag,<br>    canBeLeftOpenTag: options.canBeLeftOpenTag,<br>    shouldDecodeNewlines: options.shouldDecodeNewlines,<br>    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,<br>    shouldKeepComment: options.comments,<br>    <span class="hljs-comment">// 当解析到开始标签时，调用该函数</span><br>    start (tag, attrs, unary) &#123;<br><br>    &#125;,<br>    <span class="hljs-comment">// 当解析到结束标签时，调用该函数</span><br>    end () &#123;<br><br>    &#125;,<br>    <span class="hljs-comment">// 当解析到文本时，调用该函数</span><br>    chars (text) &#123;<br><br>    &#125;,<br>    <span class="hljs-comment">// 当解析到注释时，调用该函数</span><br>    comment (text) &#123;<br><br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从代码中我们可以看到，调用<code>parseHTML</code>函数时为其传入的两个参数分别是：</p>
<ul>
<li>template:待转换的模板字符串；</li>
<li>options:转换时所需的选项；</li>
</ul>
<p>第一个参数是待转换的模板字符串，无需多言；重点看第二个参数，第二个参数提供了一些解析<code>HTML</code>模板时的一些参数，同时还定义了4个钩子函数。这4个钩子函数有什么作用呢？我们说了模板编译阶段主线函数<code>parse</code>会将<code>HTML</code>模板字符串转化成<code>AST</code>，而<code>parseHTML</code>是用来解析模板字符串的，把模板字符串中不同的内容出来之后，那么谁来把提取出来的内容生成对应的<code>AST</code>呢？答案就是这4个钩子函数。</p>
<p>把这4个钩子函数作为参数传给解析器<code>parseHTML</code>，当解析器解析出不同的内容时调用不同的钩子函数从而生成不同的<code>AST</code>。</p>
<p>当解析到开始标签时调用<code>start</code>函数生成元素类型的<code>AST</code>节点，代码如下；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 当解析到标签的开始位置时，触发start</span><br>start (tag, attrs, unary) &#123;<br>	<span class="hljs-keyword">let</span> element = createASTElement(tag, attrs, currentParent)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createASTElement</span> (<span class="hljs-params">tag,attrs,parent</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    type: <span class="hljs-number">1</span>,<br>    tag,<br>    attrsList: attrs,<br>    attrsMap: makeAttrsMap(attrs),<br>    parent,<br>    children: []<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>从上面代码中我们可以看到，<code>start</code>函数接收三个参数，分别是标签名<code>tag</code>、标签属性<code>attrs</code>、标签是否自闭合<code>unary</code>。当调用该钩子函数时，内部会调用<code>createASTElement</code>函数来创建元素类型的<code>AST</code>节点</li>
<li>当解析到结束标签时调用<code>end</code>函数；</li>
<li>当解析到文本时调用<code>chars</code>函数生成文本类型的<code>AST</code>节点；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 当解析到标签的文本时，触发chars</span><br>chars (text) &#123;<br>	<span class="hljs-keyword">if</span>(text是带变量的动态文本)&#123;<br>    <span class="hljs-keyword">let</span> element = &#123;<br>      type: <span class="hljs-number">2</span>,<br>      expression: res.expression,<br>      tokens: res.tokens,<br>      text<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">let</span> element = &#123;<br>      type: <span class="hljs-number">3</span>,<br>      text<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>当解析到标签的文本时，触发<code>chars</code>钩子函数，在该钩子函数内部，首先会判断文本是不是一个带变量的动态文本，如“hello ”。如果是动态文本，则创建动态文本类型的<code>AST</code>节点；如果不是动态文本，则创建纯静态文本类型的<code>AST</code>节点。</li>
<li>当解析到注释时调用<code>comment</code>函数生成注释类型的<code>AST</code>节点；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/ 当解析到标签的注释时，触发comment<br>comment (text: string) &#123;<br>  <span class="hljs-keyword">let</span> element = &#123;<br>    type: <span class="hljs-number">3</span>,<br>    text,<br>    isComment: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>当解析到标签的注释时，触发<code>comment</code>钩子函数，该钩子函数会创建一个注释类型的<code>AST</code>节点。</li>
</ul>
<p>一边解析不同的内容一边调用对应的钩子函数生成对应的<code>AST</code>节点，最终完成将整个模板字符串转化成<code>AST</code>,这就是<code>HTML</code>解析器所要做的工作。</p>
<h5 id="3-如何解析不同的内容"><a href="#3-如何解析不同的内容" class="headerlink" title="3. 如何解析不同的内容"></a>3. 如何解析不同的内容</h5><p>要从模板字符串中解析出不同的内容，那首先要知道模板字符串中都会包含哪些内容。那么通常我们所写的模板字符串中都会包含哪些内容呢？经过整理，通常模板内会包含如下内容：</p>
<ul>
<li>文本，例如“难凉热血”</li>
<li>HTML注释，例如<!-- 我是注释 --></li>
<li>条件注释，例如<!-- [if !IE]> -->我是注释<!--< ![endif] --></li>
<li>DOCTYPE，例如<!DOCTYPE html></li>
<li>开始标签，例如<div></li>
<li>结束标签，例如</div></li>
</ul>
<p>这几种内容都有其各自独有的特点，也就是说我们要根据不同内容所具有的不同的的特点通过编写不同的正则表达式将这些内容从模板字符串中一一解析出来，然后再把不同的内容做不同的处理。</p>
<p>下面，我们就来分别看一下<code>HTML</code>解析器是如何从模板字符串中将以上不同种类的内容进行解析出来。</p>
<h5 id="3-1-解析HTML注释"><a href="#3-1-解析HTML注释" class="headerlink" title="3.1 解析HTML注释"></a>3.1 解析HTML注释</h5><p>解析注释比较简单，我们知道<code>HTML</code>注释是以<code>&lt;!--</code>开头，以<code>--&gt;</code>结尾，这两者中间的内容就是注释内容，那么我们只需用正则判断待解析的模板字符串<code>html</code>是否以<code>&lt;!--</code>开头，若是，那就继续向后寻找<code>--&gt;</code>，如果找到了，OK，注释就被解析出来了。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> comment = <span class="hljs-regexp">/^&lt;!\--/</span><br><span class="hljs-keyword">if</span> (comment.test(html)) &#123;<br>  <span class="hljs-comment">// 若为注释，则继续查找是否存在&#x27;--&gt;&#x27;</span><br>  <span class="hljs-keyword">const</span> commentEnd = html.indexOf(<span class="hljs-string">&#x27;--&gt;&#x27;</span>)<br><br>  <span class="hljs-keyword">if</span> (commentEnd &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 若存在 &#x27;--&gt;&#x27;,继续判断options中是否保留注释</span><br>    <span class="hljs-keyword">if</span> (options.shouldKeepComment) &#123;<br>      <span class="hljs-comment">// 若保留注释，则把注释截取出来传给options.comment，创建注释类型的AST节点</span><br>      options.comment(html.substring(<span class="hljs-number">4</span>, commentEnd))<br>    &#125;<br>    <span class="hljs-comment">// 若不保留注释，则将游标移动到&#x27;--&gt;&#x27;之后，继续向后解析</span><br>    advance(commentEnd + <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">continue</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面代码中，如果模板字符串<code>html</code>符合注释开始的正则，那么就继续向后查找是否存在<code>--&gt;</code>，若存在，则把<code>html</code>从第4位（”<!--"长度为4）开始截取，直到`--><code>处，截取得到的内容就是注释的真实内容，然后调用4个钩子函数中的</code>comment<code>函数，将真实的注释内容传进去，创建注释类型的</code>AST`节点。</p>
<p>上面代码中有一处值得注意的地方，那就是我们平常在模板中可以在<code>&lt;template&gt;&lt;/template&gt;</code>标签上配置<code>comments</code>选项来决定在渲染模板时是否保留注释，对应到上面代码中就是<code>options.shouldKeepComment</code>,如果用户配置了<code>comments</code>选项为<code>true</code>，则<code>shouldKeepComment</code>为<code>true</code>，则创建注释类型的<code>AST</code>节点，如不保留注释，则将游标移动到’–&gt;’之后，继续向后解析。</p>
<p><code>advance</code>函数是用来移动解析游标的，解析完一部分就把游标向后移动一部分，确保不会重复解析，其代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">advance</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  index += n   <span class="hljs-comment">// index为解析游标</span><br>  html = html.substring(n)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210428171551449.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20210428171551449"></p>
<p>调用 <code>advance</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">advance(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210428171638566.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20210428171638566"></p>
<p>从图中可以看到，解析游标<code>index</code>最开始在模板字符串的位置0处，当调用了<code>advance(3)</code>之后，解析游标到了位置3处，每次解析完一段内容就将游标向后移动一段，接着再从解析游标往后解析，这样就保证了解析过的内容不会被重复解析。</p>
<h5 id="3-2-解析条件注释"><a href="#3-2-解析条件注释" class="headerlink" title="3.2 解析条件注释"></a>3.2 解析条件注释</h5><p>解析条件注释也比较简单，其原理跟解析注释相同，都是先用正则判断是否是以条件注释特有的开头标识开始，然后寻找其特有的结束标识，若找到，则说明是条件注释，将其截取出来即可，由于条件注释不存在于真正的<code>DOM</code>树中，所以不需要调用钩子函数创建<code>AST</code>节点。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 解析是否是条件注释</span><br><span class="hljs-keyword">const</span> conditionalComment = <span class="hljs-regexp">/^&lt;!\[/</span><br><span class="hljs-keyword">if</span> (conditionalComment.test(html)) &#123;<br>  <span class="hljs-comment">// 若为条件注释，则继续查找是否存在&#x27;]&gt;&#x27;</span><br>  <span class="hljs-keyword">const</span> conditionalEnd = html.indexOf(<span class="hljs-string">&#x27;]&gt;&#x27;</span>)<br><br>  <span class="hljs-keyword">if</span> (conditionalEnd &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 若存在 &#x27;]&gt;&#x27;,则从原本的html字符串中把条件注释截掉，</span><br>    <span class="hljs-comment">// 把剩下的内容重新赋给html，继续向后匹配</span><br>    advance(conditionalEnd + <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">continue</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="3-3-解析DOCTYPE"><a href="#3-3-解析DOCTYPE" class="headerlink" title="3.3 解析DOCTYPE"></a>3.3 解析DOCTYPE</h5><p>解析<code>DOCTYPE</code>的原理同解析条件注释完全相同，此处不再赘述，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> doctype = <span class="hljs-regexp">/^&lt;!DOCTYPE [^&gt;]+&gt;/i</span><br><span class="hljs-comment">// 解析是否是DOCTYPE</span><br><span class="hljs-keyword">const</span> doctypeMatch = html.match(doctype)<br><span class="hljs-keyword">if</span> (doctypeMatch) &#123;<br>  advance(doctypeMatch[<span class="hljs-number">0</span>].length)<br>  <span class="hljs-keyword">continue</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="3-4-解析开始标签"><a href="#3-4-解析开始标签" class="headerlink" title="3.4 解析开始标签"></a>3.4 解析开始标签</h5><p>相较于前三种内容的解析，解析开始标签会稍微复杂一点，但是万变不离其宗，它的原理还是相通的，都是使用正则去匹配提取。</p>
<p>首先使用开始标签的正则去匹配模板字符串，看模板字符串是否具有开始标签的特征，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 匹配开始标签的正则</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> ncname = <span class="hljs-string">&#x27;[a-zA-Z_][\\w\\-\\.]*&#x27;</span><br><span class="hljs-keyword">const</span> qnameCapture = <span class="hljs-string">`((?:<span class="hljs-subst">$&#123;ncname&#125;</span>\\:)?<span class="hljs-subst">$&#123;ncname&#125;</span>)`</span><br><span class="hljs-keyword">const</span> startTagOpen = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`^&lt;<span class="hljs-subst">$&#123;qnameCapture&#125;</span>`</span>)<br><br><span class="hljs-keyword">const</span> start = html.match(startTagOpen)<br><span class="hljs-keyword">if</span> (start) &#123;<br>  <span class="hljs-keyword">const</span> match = &#123;<br>    tagName: start[<span class="hljs-number">1</span>],<br>    attrs: [],<br>    start: index<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 以开始标签开始的模板：</span><br><span class="hljs-string">&#x27;&lt;div&gt;&lt;/div&gt;&#x27;</span>.match(startTagOpen)  =&gt; [<span class="hljs-string">&#x27;&lt;div&#x27;</span>,<span class="hljs-string">&#x27;div&#x27;</span>,<span class="hljs-attr">index</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">input</span>:<span class="hljs-string">&#x27;&lt;div&gt;&lt;/div&gt;&#x27;</span>]<br><span class="hljs-comment">// 以结束标签开始的模板：</span><br><span class="hljs-string">&#x27;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&#x27;</span>.match(startTagOpen) =&gt; <span class="hljs-literal">null</span><br><span class="hljs-comment">// 以文本开始的模板：</span><br><span class="hljs-string">&#x27;我是文本&lt;/p&gt;&#x27;</span>.match(startTagOpen) =&gt; <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure>

<p>在上面代码中，我们用不同类型的内容去匹配开始标签的正则，发现只有<code>&lt;div&gt;&lt;/div&gt;</code>的字符串可以正确匹配，并且返回一个数组。</p>
<p>在前文中我们说到，当解析到开始标签时，会调用4个钩子函数中的<code>start</code>函数，而<code>start</code>函数需要传递3个参数，分别是标签名<code>tag</code>、标签属性<code>attrs</code>、标签是否自闭合<code>unary</code>。标签名通过正则匹配的结果就可以拿到，即上面代码中的<code>start[1]</code>，而标签属性<code>attrs</code>以及标签是否自闭合<code>unary</code>需要进一步解析。</p>
<p>解析标签属性</p>
<p>我们知道，标签属性一般是写在开始标签的标签名之后的，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>另外，我们在上面匹配是否是开始标签的正则中已经可以拿到开始标签的标签名，即上面代码中的<code>start[0]</code>，那么我们可以将这一部分先从模板字符串中截掉，则剩下的部分如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">class=&quot;a&quot; id=&quot;b&quot;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>那么我们只需用剩下的这部分去匹配标签属性的正则，就可以将标签属性提取出来了，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ncname = <span class="hljs-string">&#x27;[a-zA-Z_][\\w\\-\\.]*&#x27;</span><br><span class="hljs-keyword">const</span> qnameCapture = <span class="hljs-string">`((?:<span class="hljs-subst">$&#123;ncname&#125;</span>\\:)?<span class="hljs-subst">$&#123;ncname&#125;</span>)`</span><br><span class="hljs-keyword">const</span> endTag = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`^&lt;\\/<span class="hljs-subst">$&#123;qnameCapture&#125;</span>[^&gt;]*&gt;`</span>)<br><span class="hljs-keyword">const</span> endTagMatch = html.match(endTag)<br><br><span class="hljs-string">&#x27;&lt;/div&gt;&#x27;</span>.match(endTag)  <span class="hljs-comment">// [&quot;&lt;/div&gt;&quot;, &quot;div&quot;, index: 0, input: &quot;&lt;/div&gt;&quot;, groups: undefined]</span><br><span class="hljs-string">&#x27;&lt;div&gt;&#x27;</span>.match(endTag)  <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，如果模板字符串符合结束标签的特征，则会获得匹配结果数组；如果不合符，则得到null。</p>
<p>接着再调用<code>end</code>钩子函数，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (endTagMatch) &#123;<br>    <span class="hljs-keyword">const</span> curIndex = index<br>    advance(endTagMatch[<span class="hljs-number">0</span>].length)<br>    parseEndTag(endTagMatch[<span class="hljs-number">1</span>], curIndex, index)<br>    <span class="hljs-keyword">continue</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面代码中，没有直接去调用<code>end</code>函数，而是调用了<code>parseEndTag</code>函数，关于<code>parseEndTag</code>函数内部的作用我们后面会介绍到，在这里你暂时可以理解为该函数内部就是去调用了<code>end</code>钩子函数。</p>
<h5 id="3-6-解析文本"><a href="#3-6-解析文本" class="headerlink" title="3.6 解析文本"></a>3.6 解析文本</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">终于到了解析最后一种文本类型的内容了，为什么要把解析文本类型放在最后一个介绍呢？我们仔细想一下，前面五种类型都是以`&lt;`开头的，只有文本类型的内容不是以`&lt;`开头的，所以我们在解析模板字符串的时候可以先判断一下字符串是不是以`&lt;`开头的，如果是则继续判断是以上五种类型的具体哪一种，而如果不是的话，那它肯定就是文本了。<br></code></pre></td></tr></table></figure>

<p>解析文本也比较容易，在解析模板字符串之前，我们先查找一下第一个<code>&lt;</code>出现在什么位置，如果第一个<code>&lt;</code>在第一个位置，那么说明模板字符串是以其它5种类型开始的；如果第一个<code>&lt;</code>不在第一个位置而在模板字符串中间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个<code>&lt;</code>出现的位置就都是文本内容了；如果在整个模板字符串里没有找到<code>&lt;</code>，那说明整个模板字符串都是文本。这就是解析思路，接下来我们对照源码来了解一下实际的解析过程，源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> textEnd = html.indexOf(<span class="hljs-string">&#x27;&lt;&#x27;</span>)<br><span class="hljs-comment">// &#x27;&lt;&#x27; 在第一个位置，为其余5种类型</span><br><span class="hljs-keyword">if</span> (textEnd === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-comment">// &#x27;&lt;&#x27; 不在第一个位置，文本开头</span><br><span class="hljs-keyword">if</span> (textEnd &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 如果html字符串不是以&#x27;&lt;&#x27;开头,说明&#x27;&lt;&#x27;前面的都是纯文本，无需处理</span><br>    <span class="hljs-comment">// 那就把&#x27;&lt;&#x27;以后的内容拿出来赋给rest</span><br>    rest = html.slice(textEnd)<br>    <span class="hljs-keyword">while</span> (<br>        !endTag.test(rest) &amp;&amp;<br>        !startTagOpen.test(rest) &amp;&amp;<br>        !comment.test(rest) &amp;&amp;<br>        !conditionalComment.test(rest)<br>    ) &#123;<br>        <span class="hljs-comment">// &lt; in plain text, be forgiving and treat it as text</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">           * 用&#x27;&lt;&#x27;以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment</span><br><span class="hljs-comment">           * 如果都匹配不上，表示&#x27;&lt;&#x27;是属于文本本身的内容</span><br><span class="hljs-comment">           */</span><br>        <span class="hljs-comment">// 在&#x27;&lt;&#x27;之后查找是否还有&#x27;&lt;&#x27;</span><br>        next = rest.indexOf(<span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// 如果没有了，表示&#x27;&lt;&#x27;后面也是文本</span><br>        <span class="hljs-keyword">if</span> (next &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span><br>        <span class="hljs-comment">// 如果还有，表示&#x27;&lt;&#x27;是文本中的一个字符</span><br>        textEnd += next<br>        <span class="hljs-comment">// 那就把next之后的内容截出来继续下一轮循环匹配</span><br>        rest = html.slice(textEnd)<br>    &#125;<br>    <span class="hljs-comment">// &#x27;&lt;&#x27;是结束标签的开始 ,说明从开始到&#x27;&lt;&#x27;都是文本，截取出来</span><br>    text = html.substring(<span class="hljs-number">0</span>, textEnd)<br>    advance(textEnd)<br>&#125;<br><span class="hljs-comment">// 整个模板字符串里没有找到`&lt;`,说明整个模板字符串都是文本</span><br><span class="hljs-keyword">if</span> (textEnd &lt; <span class="hljs-number">0</span>) &#123;<br>    text = html<br>    html = <span class="hljs-string">&#x27;&#x27;</span><br>&#125;<br><span class="hljs-comment">// 把截取出来的text转化成textAST</span><br><span class="hljs-keyword">if</span> (options.chars &amp;&amp; text) &#123;<br>    options.chars(text)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>源码的逻辑很清晰，根据<code>&lt;</code>在不在第一个位置以及整个模板字符串里没有<code>&lt;</code>都分别进行了处理。</p>
<p>值得深究的是如果<code>&lt;</code>不在第一个位置而在模板字符串中间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个<code>&lt;</code>出现的位置就都是文本内容了，接着我们还要从第一个<code>&lt;</code>的位置继续向后判断，因为还存在这样一种情况，那就是如果文本里面本来就包含一个<code>&lt;</code>，例如<code>1&lt;2&lt;/div&gt;</code>。为了处理这种情况，我们把从第一个<code>&lt;</code>的位置直到模板字符串结束都截取出来记作<code>rest</code>，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> rest = html.slice(textEnd)<br></code></pre></td></tr></table></figure>

<p>接着用<code>rest</code>去匹配以上5种类型的正则，如果都匹配不上，则表明这个<code>&lt;</code>是属于文本本身的内容，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (<br>    !endTag.test(rest) &amp;&amp;<br>    !startTagOpen.test(rest) &amp;&amp;<br>    !comment.test(rest) &amp;&amp;<br>    !conditionalComment.test(rest)<br>) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果都匹配不上，则表明这个<code>&lt;</code>是属于文本本身的内容，接着以这个<code>&lt;</code>的位置继续向后查找，看是否还有<code>&lt;</code>，如果没有了，则表示后面的都是文本；如果后面还有下一个<code>&lt;</code>，那表明至少在这个<code>&lt;</code>到下一个<code>&lt;</code>中间的内容都是文本，至于下一个<code>&lt;</code>以后的内容是什么，则还需要重复以上的逻辑继续判断。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (<br>    !endTag.test(rest) &amp;&amp;<br>    !startTagOpen.test(rest) &amp;&amp;<br>    !comment.test(rest) &amp;&amp;<br>    !conditionalComment.test(rest)<br>) &#123;<br>    <span class="hljs-comment">// &lt; in plain text, be forgiving and treat it as text</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用&#x27;&lt;&#x27;以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment</span><br><span class="hljs-comment">    * 如果都匹配不上，表示&#x27;&lt;&#x27;是属于文本本身的内容</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 在&#x27;&lt;&#x27;之后查找是否还有&#x27;&lt;&#x27;</span><br>    next = rest.indexOf(<span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// 如果没有了，表示&#x27;&lt;&#x27;后面也是文本</span><br>    <span class="hljs-keyword">if</span> (next &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span><br>    <span class="hljs-comment">// 如果还有，表示&#x27;&lt;&#x27;是文本中的一个字符</span><br>    textEnd += next<br>    <span class="hljs-comment">// 那就把next之后的内容截出来继续下一轮循环匹配</span><br>    rest = html.slice(textEnd)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后截取文本内容<code>text</code>并调用4个钩子函数中的<code>chars</code>函数创建文本型的<code>AST</code>节点。</p>
<h5 id="4-如何保证AST节点层级关系"><a href="#4-如何保证AST节点层级关系" class="headerlink" title="4. 如何保证AST节点层级关系"></a>4. 如何保证AST节点层级关系</h5><p>上一章节我们介绍了<code>HTML</code>解析器是如何解析各种不同类型的内容并且调用钩子函数创建不同类型的<code>AST</code>节点。此时你可能会有个疑问，我们上面创建的<code>AST</code>节点都是单独创建且分散的，而真正的<code>DOM</code>节点都是有层级关系的，那如何来保证<code>AST</code>节点的层级关系与真正的<code>DOM</code>节点相同呢？</p>
<p>关于这个问题，<code>Vue</code>也注意到了。<code>Vue</code>在<code>HTML</code>解析器的开头定义了一个栈<code>stack</code>，这个栈的作用就是用来维护<code>AST</code>节点层级的，那么它是怎么维护的呢？通过前文我们知道，<code>HTML</code>解析器在从前向后解析模板字符串时，每当遇到开始标签时就会调用<code>start</code>钩子函数，那么在<code>start</code>钩子函数内部我们可以将解析得到的开始标签推入栈中，而每当遇到结束标签时就会调用<code>end</code>钩子函数，那么我们也可以在<code>end</code>钩子函数内部将解析得到的结束标签所对应的开始标签从栈中弹出。请看如下例子：</p>
<p>假如有如下模板字符串：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>当解析到开始标签<code>&lt;div&gt;</code>时，就把<code>div</code>推入栈中，然后继续解析，当解析到<code>&lt;p&gt;</code>时，再把<code>p</code>推入栈中，同理，再把<code>span</code>推入栈中，当解析到结束标签<code>&lt;/span&gt;</code>时，此时栈顶的标签刚好是<code>span</code>的开始标签，那么就用<code>span</code>的开始标签和结束标签构建<code>AST</code>节点，并且从栈中把<code>span</code>的开始标签弹出，那么此时栈中的栈顶标签<code>p</code>就是构建好的<code>span</code>的<code>AST</code>节点的父节点，如下图：</p>
<p><img   class="lazyload" data-original="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210428173344529.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20210428173344529"></p>
<p>这样我们就找到了当前被构建节点的父节点。这只是栈的一个用途，它还有另外一个用途，我们再看如下模板字符串：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>按照上面的流程解析这个模板字符串时，当解析到结束标签<code>&lt;/p&gt;</code>时，此时栈顶的标签应该是<code>p</code>才对，而现在是<code>span</code>，那么就说明<code>span</code>标签没有被正确闭合，此时控制台就会抛出警告：‘tag has no matching end tag.’相信这个警告你一定不会陌生。这就是栈的第二个用途： 检测模板字符串中是否有未正确闭合的标签。</p>
<p>OK，有了这个栈的概念之后，我们再回看上一章<code>HTML</code>解析器解析不同内容的代码。</p>
<h5 id="5-回归源码"><a href="#5-回归源码" class="headerlink" title="5. 回归源码"></a>5. 回归源码</h5><h6 id="5-1-HTML解析器源码"><a href="#5-1-HTML解析器源码" class="headerlink" title="5.1 HTML解析器源码"></a>5.1 HTML解析器源码</h6><p>以上内容都了解了之后，我们回归源码，逐句分析<code>HTML</code>解析器<code>parseHTML</code>函数，函数定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseHTML</span>(<span class="hljs-params">html, options</span>) </span>&#123;<br>	<span class="hljs-keyword">var</span> stack = [];<br>	<span class="hljs-keyword">var</span> expectHTML = options.expectHTML;<br>	<span class="hljs-keyword">var</span> isUnaryTag$$<span class="hljs-number">1</span> = options.isUnaryTag || no;<br>	<span class="hljs-keyword">var</span> canBeLeftOpenTag$$<span class="hljs-number">1</span> = options.canBeLeftOpenTag || no;<br>	<span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">var</span> last, lastTag;<br><br>	<span class="hljs-comment">// 开启一个 while 循环，循环结束的条件是 html 为空，即 html 被 parse 完毕</span><br>	<span class="hljs-keyword">while</span> (html) &#123;<br>		last = html;<br>		<span class="hljs-comment">// 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)</span><br>		<span class="hljs-keyword">if</span> (!lastTag || !isPlainTextElement(lastTag)) &#123;<br>		   <span class="hljs-keyword">let</span> textEnd = html.indexOf(<span class="hljs-string">&#x27;&lt;&#x27;</span>)<br>              <span class="hljs-comment">/**</span><br><span class="hljs-comment">               * 如果html字符串是以&#x27;&lt;&#x27;开头,则有以下几种可能</span><br><span class="hljs-comment">               * 开始标签:&lt;div&gt;</span><br><span class="hljs-comment">               * 结束标签:&lt;/div&gt;</span><br><span class="hljs-comment">               * 注释:&lt;!-- 我是注释 --&gt;</span><br><span class="hljs-comment">               * 条件注释:&lt;!-- [if !IE] --&gt; &lt;!-- [endif] --&gt;</span><br><span class="hljs-comment">               * DOCTYPE:&lt;!DOCTYPE html&gt;</span><br><span class="hljs-comment">               * 需要一一去匹配尝试</span><br><span class="hljs-comment">               */</span><br>            <span class="hljs-keyword">if</span> (textEnd === <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 解析是否是注释</span><br>        		<span class="hljs-keyword">if</span> (comment.test(html)) &#123;<br><br>                &#125;<br>                <span class="hljs-comment">// 解析是否是条件注释</span><br>                <span class="hljs-keyword">if</span> (conditionalComment.test(html)) &#123;<br><br>                &#125;<br>                <span class="hljs-comment">// 解析是否是DOCTYPE</span><br>                <span class="hljs-keyword">const</span> doctypeMatch = html.match(doctype)<br>                <span class="hljs-keyword">if</span> (doctypeMatch) &#123;<br><br>                &#125;<br>                <span class="hljs-comment">// 解析是否是结束标签</span><br>                <span class="hljs-keyword">const</span> endTagMatch = html.match(endTag)<br>                <span class="hljs-keyword">if</span> (endTagMatch) &#123;<br><br>                &#125;<br>                <span class="hljs-comment">// 匹配是否是开始标签</span><br>                <span class="hljs-keyword">const</span> startTagMatch = parseStartTag()<br>                <span class="hljs-keyword">if</span> (startTagMatch) &#123;<br><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果html字符串不是以&#x27;&lt;&#x27;开头,则解析文本类型</span><br>            <span class="hljs-keyword">let</span> text, rest, next<br>            <span class="hljs-keyword">if</span> (textEnd &gt;= <span class="hljs-number">0</span>) &#123;<br><br>            &#125;<br>            <span class="hljs-comment">// 如果在html字符串中没有找到&#x27;&lt;&#x27;，表示这一段html字符串都是纯文本</span><br>            <span class="hljs-keyword">if</span> (textEnd &lt; <span class="hljs-number">0</span>) &#123;<br>                text = html<br>                html = <span class="hljs-string">&#x27;&#x27;</span><br>            &#125;<br>            <span class="hljs-comment">// 把截取出来的text转化成textAST</span><br>            <span class="hljs-keyword">if</span> (options.chars &amp;&amp; text) &#123;<br>                options.chars(text)<br>            &#125;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// 父元素为script、style、textarea时，其内部的内容全部当做纯文本处理</span><br>		&#125;<br><br>		<span class="hljs-comment">//将整个字符串作为文本对待</span><br>		<span class="hljs-keyword">if</span> (html === last) &#123;<br>			options.chars &amp;&amp; options.chars(html);<br>			<span class="hljs-keyword">if</span> (!stack.length &amp;&amp; options.warn) &#123;<br>				options.warn((<span class="hljs-string">&quot;Mal-formatted tag at end of template: \&quot;&quot;</span> + html + <span class="hljs-string">&quot;\&quot;&quot;</span>));<br>			&#125;<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// Clean up any remaining tags</span><br>	parseEndTag();<br>	<span class="hljs-comment">//parse 开始标签</span><br>	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseStartTag</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>	&#125;<br>	<span class="hljs-comment">//处理 parseStartTag 的结果</span><br>	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleStartTag</span>(<span class="hljs-params">match</span>) </span>&#123;<br><br>	&#125;<br>	<span class="hljs-comment">//parse 结束标签</span><br>	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseEndTag</span>(<span class="hljs-params">tagName, start, end</span>) </span>&#123;<br><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    上述代码中大致可分为三部分：</p>
<ul>
<li>定义的一些常量和变量</li>
<li>while 循环</li>
<li>解析过程中用到的辅助函数</li>
</ul>
<p>我们一一来分析：</p>
<p>首先定义了几个常量，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> stack = []       <span class="hljs-comment">// 维护AST节点层级的栈</span><br><span class="hljs-keyword">const</span> expectHTML = options.expectHTML<br><span class="hljs-keyword">const</span> isUnaryTag = options.isUnaryTag || no<br><span class="hljs-keyword">const</span> canBeLeftOpenTag = options.canBeLeftOpenTag || no   <span class="hljs-comment">//用来检测一个标签是否是可以省略闭合标签的非自闭合标签</span><br><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>   <span class="hljs-comment">//解析游标，标识当前从何处开始解析模板字符串</span><br><span class="hljs-keyword">let</span> last,   <span class="hljs-comment">// 存储剩余还未解析的模板字符串</span><br>    lastTag  <span class="hljs-comment">// 存储着位于 stack 栈顶的元素</span><br></code></pre></td></tr></table></figure>

<p>接着开启<code>while</code> 循环，循环的终止条件是 模板字符串<code>html</code>为空，即模板字符串被全部编译完毕。在每次<code>while</code>循环中， 先把 <code>html</code>的值赋给变量 <code>last</code>，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">last = html<br></code></pre></td></tr></table></figure>

<p>这样做的目的是，如果经过上述所有处理逻辑处理过后，<code>html</code>字符串没有任何变化，即表示<code>html</code>字符串没有匹配上任何一条规则，那么就把<code>html</code>字符串当作纯文本对待，创建文本类型的<code>AST</code>节点并且如果抛出异常：模板字符串中标签格式有误。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//将整个字符串作为文本对待</span><br><span class="hljs-keyword">if</span> (html === last) &#123;<br>    options.chars &amp;&amp; options.chars(html);<br>    <span class="hljs-keyword">if</span> (!stack.length &amp;&amp; options.warn) &#123;<br>        options.warn((<span class="hljs-string">&quot;Mal-formatted tag at end of template: \&quot;&quot;</span> + html + <span class="hljs-string">&quot;\&quot;&quot;</span>));<br>    &#125;<br>    <span class="hljs-keyword">break</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>接着，我们继续看<code>while</code>循环体内的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (html) &#123;<br>  <span class="hljs-comment">// 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)</span><br>  <span class="hljs-keyword">if</span> (!lastTag || !isPlainTextElement(lastTag)) &#123;<br><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// parse 的内容是在纯文本标签里 (script,style,textarea)</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在循环体内，首先判断了待解析的<code>html</code>字符串是否在纯文本标签里，如<code>script</code>,<code>style</code>,<code>textarea</code>，因为在这三个标签里的内容肯定不会有<code>HTML</code>标签，所以我们可直接当作文本处理，判断条件如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">!lastTag || !isPlainTextElement(lastTag)<br></code></pre></td></tr></table></figure>

<p>前面我们说了，<code>lastTag</code>为栈顶元素，<code>!lastTag</code>即表示当前<code>html</code>字符串没有父节点，而<code>isPlainTextElement(lastTag)</code> 是检测 <code>lastTag</code> 是否为是那三个纯文本标签之一，是的话返回<code>true</code>，不是返回<code>fasle</code>。</p>
<p>也就是说当前<code>html</code>字符串要么没有父节点要么父节点不是纯文本标签，则接下来就可以依次解析那6种类型的内容了，关于6种类型内容的处理方式前文已经逐个介绍过，此处不再重复。</p>
<h5 id="5-2-parseEndTag函数源码"><a href="#5-2-parseEndTag函数源码" class="headerlink" title="5.2 parseEndTag函数源码"></a>5.2 parseEndTag函数源码</h5><p>接下来我们看一下之前在解析结束标签时遗留的<code>parseEndTag</code>函数，该函数定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseEndTag</span> (<span class="hljs-params">tagName, start, end</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> pos, lowerCasedTagName<br>    <span class="hljs-keyword">if</span> (start == <span class="hljs-literal">null</span>) start = index<br>    <span class="hljs-keyword">if</span> (end == <span class="hljs-literal">null</span>) end = index<br><br>    <span class="hljs-keyword">if</span> (tagName) &#123;<br>      lowerCasedTagName = tagName.toLowerCase()<br>    &#125;<br><br>    <span class="hljs-comment">// Find the closest opened tag of the same type</span><br>    <span class="hljs-keyword">if</span> (tagName) &#123;<br>      <span class="hljs-keyword">for</span> (pos = stack.length - <span class="hljs-number">1</span>; pos &gt;= <span class="hljs-number">0</span>; pos--) &#123;<br>        <span class="hljs-keyword">if</span> (stack[pos].lowerCasedTag === lowerCasedTagName) &#123;<br>          <span class="hljs-keyword">break</span><br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// If no tag name is provided, clean shop</span><br>      pos = <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pos &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// Close all the open elements, up the stack</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = stack.length - <span class="hljs-number">1</span>; i &gt;= pos; i--) &#123;<br>        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp;<br>          (i &gt; pos || !tagName) &amp;&amp;<br>          options.warn<br>        ) &#123;<br>          options.warn(<br>            <span class="hljs-string">`tag &lt;<span class="hljs-subst">$&#123;stack[i].tag&#125;</span>&gt; has no matching end tag.`</span><br>          )<br>        &#125;<br>        <span class="hljs-keyword">if</span> (options.end) &#123;<br>          options.end(stack[i].tag, start, end)<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// Remove the open elements from the stack</span><br>      stack.length = pos<br>      lastTag = pos &amp;&amp; stack[pos - <span class="hljs-number">1</span>].tag<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lowerCasedTagName === <span class="hljs-string">&#x27;br&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (options.start) &#123;<br>        options.start(tagName, [], <span class="hljs-literal">true</span>, start, end)<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lowerCasedTagName === <span class="hljs-string">&#x27;p&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (options.start) &#123;<br>        options.start(tagName, [], <span class="hljs-literal">false</span>, start, end)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (options.end) &#123;<br>        options.end(tagName, start, end)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该函数接收三个参数，分别是结束标签名<code>tagName</code>、结束标签在<code>html</code>字符串中的起始和结束位置<code>start</code>和<code>end</code>。</p>
<p>这三个参数其实都是可选的，根据传参的不同其功能也不同。</p>
<ul>
<li>第一种是三个参数都传递，用于处理普通的结束标签</li>
<li>第二种是只传递<code>tagName</code></li>
<li>第三种是三个参数都不传递，用于处理栈中剩余未处理的标签</li>
</ul>
<p>如果<code>tagName</code>存在，那么就从后往前遍历栈，在栈中寻找与<code>tagName</code>相同的标签并记录其所在的位置<code>pos</code>，如果<code>tagName</code>不存在，则将<code>pos</code>置为0。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (tagName) &#123;<br>    <span class="hljs-keyword">for</span> (pos = stack.length - <span class="hljs-number">1</span>; pos &gt;= <span class="hljs-number">0</span>; pos--) &#123;<br>        <span class="hljs-keyword">if</span> (stack[pos].lowerCasedTag === lowerCasedTagName) &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// If no tag name is provided, clean shop</span><br>    pos = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>接着当<code>pos&gt;=0</code>时，开启一个<code>for</code>循环，从栈顶位置从后向前遍历直到<code>pos</code>处，如果发现<code>stack</code>栈中存在索引大于<code>pos</code>的元素，那么该元素一定是缺少闭合标签的。这是因为在正常情况下，<code>stack</code>栈的栈顶元素应该和当前的结束标签<code>tagName</code> 匹配，也就是说正常的<code>pos</code>应该是栈顶位置，后面不应该再有元素，如果后面还有元素，那么后面的元素就都缺少闭合标签 那么这个时候如果是在非生产环境会抛出警告，告诉你缺少闭合标签。除此之外，还会调用 <code>options.end(stack[i].tag, start, end)</code>立即将其闭合，这是为了保证解析结果的正确性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (pos &gt;= <span class="hljs-number">0</span>) &#123;<br>	<span class="hljs-comment">// Close all the open elements, up the stack</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = stack.length - <span class="hljs-number">1</span>; i &gt;= pos; i--) &#123;<br>		<span class="hljs-keyword">if</span> (i &gt; pos || !tagName ) &#123;<br>			options.warn(<br>				(<span class="hljs-string">&quot;tag &lt;&quot;</span> + (stack[i].tag) + <span class="hljs-string">&quot;&gt; has no matching end tag.&quot;</span>)<br>			);<br>		&#125;<br>		<span class="hljs-keyword">if</span> (options.end) &#123;<br>			options.end(stack[i].tag, start, end);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// Remove the open elements from the stack</span><br>	stack.length = pos;<br>	lastTag = pos &amp;&amp; stack[pos - <span class="hljs-number">1</span>].tag;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后把<code>pos</code>位置以后的元素都从<code>stack</code>栈中弹出，以及把<code>lastTag</code>更新为栈顶元素:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">stack.length = pos;<br>lastTag = pos &amp;&amp; stack[pos - <span class="hljs-number">1</span>].tag;<br></code></pre></td></tr></table></figure>

<p>接着，如果<code>pos</code>没有大于等于0，即当 <code>tagName</code> 没有在 <code>stack</code> 栈中找到对应的开始标签时，<code>pos</code> 为 -1 。那么此时再判断 <code>tagName</code> 是否为<code>br</code> 或<code>p</code>标签，为什么要单独判断这两个标签呢？这是因为在浏览器中如果我们写了如下<code>HTML</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>​    浏览器会自动把<code>&lt;/br&gt;</code>标签解析为正常的 <br>标签，而对于<code>&lt;/p&gt;</code>浏览器则自动将其补全为<code>&lt;p&gt;&lt;/p&gt;</code>，所以<code>Vue</code>为了与浏览器对这两个标签的行为保持一致，故对这两个便签单独判断处理，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">f (lowerCasedTagName === <span class="hljs-string">&#x27;br&#x27;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (options.start) &#123;<br>        options.start(tagName, [], <span class="hljs-literal">true</span>, start, end)  <span class="hljs-comment">// 创建&lt;br&gt;AST节点</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 补全p标签并创建AST节点</span><br><span class="hljs-keyword">if</span> (lowerCasedTagName === <span class="hljs-string">&#x27;p&#x27;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (options.start) &#123;<br>        options.start(tagName, [], <span class="hljs-literal">false</span>, start, end)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (options.end) &#123;<br>        options.end(tagName, start, end)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上就是对结束标签的解析与处理。</p>
<p>另外，在<code>while</code>循环后面还有一行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">parseEndTag()<br></code></pre></td></tr></table></figure>

<p>这行代码执行的时机是<code>html === last</code>，即<code>html</code>字符串中的标签格式有误时会跳出<code>while</code>循环，此时就会执行这行代码，这行代码是调用<code>parseEndTag</code>函数并不传递任何参数，前面我们说过如果<code>parseEndTag</code>函数不传递任何参数是用于处理栈中剩余未处理的标签。这是因为如果不传递任何函数，此时<code>parseEndTag</code>函数里的<code>pos</code>就为0，那么<code>pos&gt;=0</code>就会恒成立，那么就会逐个警告缺少闭合标签，并调用 <code>options.end</code>将其闭合。</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>本篇文章主要介绍了<code>HTML</code>解析器的工作流程以及工作原理，文章比较长，但是逻辑并不复杂。</p>
<p>首先介绍了<code>HTML</code>解析器的工作流程，一句话概括就是：一边解析不同的内容一边调用对应的钩子函数生成对应的<code>AST</code>节点，最终完成将整个模板字符串转化成<code>AST</code>。</p>
<p>接着介绍了<code>HTML</code>解析器是如何解析用户所写的模板字符串中各种类型的内容的，把各种类型的解析方式都分别进行了介绍。</p>
<p>其次，介绍了在解析器内维护了一个栈，用来保证构建的<code>AST</code>节点层级与真正<code>DOM</code>层级一致。</p>
<p>了解了思想之后，最后回归源码，学习了源码中一些处理细节的地方。</p>
<h5 id="文本解析器"><a href="#文本解析器" class="headerlink" title="文本解析器"></a>文本解析器</h5><p>在上篇文章中我们说了，当<code>HTML</code>解析器解析到文本内容时会调用4个钩子函数中的<code>chars</code>函数来创建文本型的<code>AST</code>节点，并且也说了在<code>chars</code>函数中会根据文本内容是否包含变量再细分为创建含有变量的<code>AST</code>节点和不包含变量的<code>AST</code>节点，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 当解析到标签的文本时，触发chars</span><br>chars (text) &#123;<br>  <span class="hljs-keyword">if</span>(res = parseText(text))&#123;<br>       <span class="hljs-keyword">let</span> element = &#123;<br>           type: <span class="hljs-number">2</span>,<br>           expression: res.expression,<br>           tokens: res.tokens,<br>           text<br>       &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-keyword">let</span> element = &#123;<br>           type: <span class="hljs-number">3</span>,<br>           text<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面代码中可以看到，创建含有变量的<code>AST</code>节点时节点的<code>type</code>属性为2，并且相较于不包含变量的<code>AST</code>节点多了两个属性：<code>expression</code>和<code>tokens</code>。那么如何来判断文本里面是否包含变量以及多的那两个属性是什么呢？这就涉及到文本解析器了，当<code>Vue</code>用<code>HTML</code>解析器解析出文本时，再将解析出来的文本内容传给文本解析器，最后由文本解析器解析该段文本里面是否包含变量以及如果包含变量时再解析<code>expression</code>和<code>tokens</code>。那么接下来，本篇文章就来分析一下文本解析器都干了些什么。</p>
<p>撸码一时爽，一直撸码一直爽！！！</p>

      </section>
      <section class="extra">
        
        <ul class="copyright">
  
  <li><strong>本文作者：</strong>lc</li>
  <li><strong>本文链接：</strong><a href="http://example.com/2021/03/18/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A33/index.html">http://example.com/2021/03/18/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A33/index.html</a></li>
  <li><strong>版权声明：</strong>本博客所有文章均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"
      rel="external nofollow" target="_blank"> BY-NC-SA </a>许可协议，转载请注明出处！</li>
  
</ul>
        
        
        <section class="donate">
  <div class="qrcode">
    <img   class="lazyload" data-original="https://pic.izhaoo.com/alipay.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E7%AF%87/" rel="tag">vue源码理解——模板编译篇</a></li></ul>

        
<nav class="nav">
  
    <a href="/2021/03/18/typeScript/"><i class="iconfont iconleft"></i>Ts</a>
  
  
    <a href="/2021/03/18/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A32/">vue源码理解——虚拟DOM篇<i class="iconfont iconright"></i></a>
  
</nav>

      </section>
      
      <section class="comments">
  
  <div class="btn" id="comments-btn">查看评论</div>
  
  
</section>
      
    </section>
  </div>
</article>
  </div>
</main>
  <footer class="footer">
  <div class="footer-social">
    
    
    
    
    
    <a href="tencent://message/?Menu=yes&uin=2504971404 " target="_blank" onMouseOver="this.style.color= '#12B7F5'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconQQ "></i>
    </a>
    
    
    
    
    
    <a href="javascript:; " target="_blank" onMouseOver="this.style.color= '#09BB07'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconwechat-fill "></i>
    </a>
    
    
    
    
    
    <a href="https://www.instagram.com/izhaoo/ " target="_blank" onMouseOver="this.style.color= '#DA2E76'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconinstagram "></i>
    </a>
    
    
    
    
    
    <a href="https://github.com/izhaoo " target="_blank" onMouseOver="this.style.color= '#24292E'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  icongithub-fill "></i>
    </a>
    
    
    
    
    
    <a href="mailto:izhaoo@163.com " target="_blank" onMouseOver="this.style.color='#FFBE5B'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconmail"></i>
    </a>
    
  </div>
  <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  <div class="fab fab-daovoice">
    <i class="iconfont iconcomment"></i>
  </div>
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>


<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>






<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>






<script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>






<script src="/js/utils.js"></script>
<script src="/js/modules.js"></script>
<script src="/js/zui.js"></script>
<script src="/js/script.js"></script>





<script>
  (function (i, s, o, g, r, a, m) {
    i["DaoVoiceObject"] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o), m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    a.charset = "utf-8";
    m.parentNode.insertBefore(a, m)
  })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
    "//widget.daovoice.io/widget/0f81ff2f.js", "daovoice")
  daovoice('init', {
    app_id: "abcdefg"
  }, {
    launcher: {
      disableLauncherIcon: true,
    },
  });
  daovoice('update');
</script>



<script>
  (function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>


<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4c204d8bc027a0455b5fc642ac334ca8";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>










</html>