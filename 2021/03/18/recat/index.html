

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>React - cocacola</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />

  
  
  <meta name="description" content="
$ 前言  最近在考虑框架转型，鉴于作为一名JSer..."> 
  
  <meta name="author" content="lc"> 

  
    <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  
  
    <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  
  
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  
  
    <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_h1619vhl1nr.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css">

  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: false,
        loadingImage: '',
      },
      donate: {
        enable: true,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      motto: {
        api: '',
        default: '将喜欢的一切留在身边，这便是努力的意义。'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        alwaysShow: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: true
      }
    }
  </script>

  

  
<meta name="generator" content="Hexo 5.4.0"></head>
<body class="lock-screen">
  <div class="loading"></div>
  


<nav class="navbar">
  <div class="left"></div>
  <div class="center">React</div>
  <div class="right">
    <i class="iconfont iconmenu j-navbar-menu"></i>
  </div>
</nav>

  <nav class="menu">
  <div class="menu-wrap">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content">
      
      
      
      
      <li class="menu-item"><a href="/ " class="underline"> 首页</a></li>
      
      
      
      
      <li class="menu-item"><a href="/galleries " class="underline"> 摄影</a></li>
      
      
      
      
      <li class="menu-item"><a href="/archives " class="underline"> 归档</a></li>
      
      
      
      
      <li class="menu-item"><a href="/tags " class="underline"> 标签</a></li>
      
      
      
      
      <li class="menu-item"><a href="/categories " class="underline"> 分类</a></li>
      
      
      
      
      <li class="menu-item"><a href="/about " class="underline"> 关于</a></li>
      
    </ul>
    <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  </div>
</nav>
  <main id="main">
  <div class="container" id="container">
    <article class="article">
  <div class="wrap">
    <section class="head">
  <img src="https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1624428749974-de7e3175a469.jpg" draggable="false">
  <div class="head-mask">
    <h1 class="head-title">React</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>March 18, 2021</span
        class="post-info-item">
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>22476</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <p><img src="https://images.weserv.nl/?url=https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1626257435667-5d942b1bd7d3.jpg" alt="img"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="$ 前言"></a>$ 前言</h3><p>  最近在考虑框架转型，鉴于作为一名JSer，要时时刻刻保持对新技术和流行技术的敏感性，而 React、Vue、Angular 已基本占领现前端市场，React作为领头大哥，建议年轻的JSer们都要学习使用或至少了解这门技术。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8646214-f35c42e6276e7a16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/453/format/webp" alt="img"></p>
<h3 id="版本声明"><a href="#版本声明" class="headerlink" title="$ 版本声明"></a>$ 版本声明</h3><p>  本文使用版本 <strong>React  v16.2.0</strong></p>
<h3 id="什么是-React"><a href="#什么是-React" class="headerlink" title="$ 什么是 React ?"></a>$ 什么是 React ?</h3><p>  React是一个声明式的，高效的，并且灵活的<strong>用于构建用户界面的 JavaScript 库</strong></p>
<p>  一个最简单的React例子</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">ReactDom.render(<br>    &lt;h1&gt;Hello World&lt;/h1&gt;,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p>  <code>ReactDom.render</code>接受两个参数，第一个是要被插入的内容，第二个是插入到DOM或者说<code>index.html</code>的位置</p>
<h3 id="一个与Html对比的简单组件"><a href="#一个与Html对比的简单组件" class="headerlink" title="$ 一个与Html对比的简单组件"></a>$ 一个与Html对比的简单组件</h3><p>  如下是一个 <code>React 组件</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShoppingList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Componnet</span> </span>&#123;<br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div className=<span class="hljs-string">&quot;shopping-list&quot;</span>&gt;<br>                &lt;h1&gt;Shoping List <span class="hljs-keyword">for</span> &#123;<span class="hljs-built_in">this</span>.props.name&#125;&lt;/h1&gt;<br>                &lt;ul&gt;<br>                    &lt;li&gt;Instagram&lt;/li&gt;<br>                    &lt;li&gt;WhatApp&lt;/li&gt;<br>                    &lt;li&gt;Oculus&lt;/li&gt;<br>                &lt;/ul&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Example usage:  &lt;ShoppingList name=&quot;Mark&quot; /&gt;</span><br></code></pre></td></tr></table></figure>

<p>  在这里，ShoppingList是一个 React组件类，或 React组件类型。组件接受参数，称为属性 <code>props</code>, 并通过 <code>render</code>方法返回一个现实的视图层次结构。</p>
<p>  <code>render</code> 方法返回您要渲染的内容描述，然后React接受该描述并将其渲染到屏幕上，特别是，<code>render</code> 返回一个React 元素，这是一个渲染内容的轻量级的描述。大多数<br> React 开发人员使用 <code>JSX</code> 语法，也是上述案例写到的语法。</p>
<p>   <code>JSX</code> 语法的转换规则为： <code>&lt;div /&gt;</code> 语法在构建是被转换为 <code>React.createElement(&#39;div&#39;)</code>。因此，上面的例子等价于：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">return</span> React.createElement(<span class="hljs-string">&#x27;div&#x27;</span>, &#123;className: <span class="hljs-string">&#x27;shopping-list&#x27;</span>&#125;,<br>    React.createElement(<span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-comment">/* h1 children ... */</span>),<br>    React.createElement(<span class="hljs-string">&#x27;ul&#x27;</span>, <span class="hljs-comment">/* ul children ... */</span>)<br>);<br></code></pre></td></tr></table></figure>

<p>  既然 <code>JSX</code> 在 React 开发者中这么流行，那 <code>JSX</code> 又是什么呢？</p>
<h3 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="$ JSX 语法"></a>$ JSX 语法</h3><p>  <code>JSX</code> 它是 <code>Javascript</code> 的一种拓展语法，能够让你的 <code>Javascript</code> 中和正常描述 HTML一样编写 HTML。</p>
<p>  你可以用 <code>花括号</code> 将任意 <code>Javascript</code> 表达式嵌入到 <code>JSX</code> 中。例如：表达式 <code>1 + 2</code>, 变量 <code>user.firstName</code>, 和函数 <code>formatName(User)</code> 等都可以嵌入使用</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatName</span>(<span class="hljs-params">user</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> user.firstName + <span class="hljs-string">&#x27; &#x27;</span> + user.lastName;<br>&#125;<br><br><span class="hljs-keyword">const</span> user = &#123;<br>    firstName: <span class="hljs-string">&#x27;harper&#x27;</span>,<br>    lastName: <span class="hljs-string">&#x27;Perez&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> element = &#123;<br>    &lt;h1&gt; Hello, &#123;formatName(user)&#125;! &lt;/h1&gt;<br>&#125;<br><br>ReactDOM.render (<br>    element,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p>  请注意，为了方便阅读开发者们常将 <code>JSX</code>分割成多行包裹起来，因为这可以避免<a href="!%5Bimage.png%5D(https://upload-images.jianshu.io/upload_images/8646214-7743ed84018f8ac7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)">分号自动插入</a>的陷阱，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123; <span class="hljs-number">1</span><br><span class="hljs-number">2</span> &#125; <span class="hljs-number">3</span><br><span class="hljs-comment">// is transformed to</span><br>&#123; <span class="hljs-number">1</span><br>;<span class="hljs-number">2</span> ;&#125; <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure>

<h5 id="JSX-也是一个表达式"><a href="#JSX-也是一个表达式" class="headerlink" title="JSX 也是一个表达式"></a>JSX 也是一个表达式</h5><p>  编译之后， <code>JSX</code> 表达式也就成了一个常规的 <code>javascript</code> 对象</p>
<p>  也正因为如此，我们可以在 <code>if</code> 语句或这是 <code>for</code> 循环语句中使用 <code>JSX</code>，用它给变量赋值，当做参数接受，或者作为函数的返回值</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getGreeting</span>(<span class="hljs-params">user</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (user) &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello. &#123;formatName(User&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, Stranger<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="用-JSX-指定属性值"><a href="#用-JSX-指定属性值" class="headerlink" title="用  JSX 指定属性值"></a>用  JSX 指定属性值</h5><p>  你可以用花括号嵌入一个 JavaScript 表达式作为属性值</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 用引号形式</span><br><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">tableIndex</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br><span class="hljs-comment">// 用表达式，并且表达式用花括号包裹</span><br><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">img</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure>

<h5 id="用-JSX-指定子元素"><a href="#用-JSX-指定子元素" class="headerlink" title="用 JSX 指定子元素"></a>用 JSX 指定子元素</h5><p>  如果是空标签，可以直接用 <code>/&gt;</code> 闭合</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;user.avatarUrl&#125;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>  如果包含子标签：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Good to see you here.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>比起 <code>HTML</code>，<code>JSX</code> 更接近于<code>Javascript</code>，所以<code>React DOM</code>规范使用驼峰（camelCase）属性命名约定，而不是HTML属性名称，当然，html的部分属性名称也作为保留字，不可使用，例如 <code>class</code>；<br> 因此，<code>class</code> 在 JSX 中 变为 <code>className</code>,  <code>tableindex</code> 变为 <code>tableIndex</code>。</p>
</blockquote>
<h5 id="用-JSX-防止注入攻击"><a href="#用-JSX-防止注入攻击" class="headerlink" title="用 JSX 防止注入攻击"></a>用 JSX 防止注入攻击</h5><p>  在JSX 中嵌入用户输入是安全的:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> title = response.potentiallyMaliciousInput;<br><span class="hljs-comment">// 这样是安全的</span><br><span class="hljs-keyword">const</span> element  = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>  默认情况下， 在渲染之前, React DOM 会格式化(<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html">escapes</a>) JSX中的所有值. 从而保证用户无法注入任何应用之外的代码. 在被渲染之前，所有的数据都被转义成为了字符串处理。 以避免 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS(跨站脚本)</a> 攻击。</p>
<h3 id="元素渲染到DOM"><a href="#元素渲染到DOM" class="headerlink" title="$ 元素渲染到DOM"></a>$ 元素渲染到DOM</h3><p>  正常情况下，你的 <code>index.html</code> 文件下会有这么一个<code>div</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;root&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>  这个<code>root</code> DOM 节点挂在所有React DOM的位置。正常情况下，对于一个React单页面应用构建，只需要一个单独的根DOM节点即可。但如果要把React整合到现有的APP中，则可能会使用到多个DOM节点。</p>
<p>  React利用<code>render</code>方法将React元素渲染到DOM上，一旦元素被渲染到页面了之后，就不能在修改器子元素或任何元素的属性，就像电影里的一帧，在某以特定的时间点的UI效果，那元素的更新呢？没错，就是重新 <code>render</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>&#123;<br>    cosnt element = &#123;<br>        &lt;div&gt;<br>            &lt;h1&gt;Hello, world&lt;/h1&gt;<br>            &lt;h2&gt;It is &#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleTimeString()&#125;.&lt;/h2&gt;<br>        &lt;/div&gt;<br>    &#125;；<br>    ReactDom.render (<br>        element,<br>        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>    )<br>&#125;<br><br><span class="hljs-built_in">setInterval</span>(tick, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>实际上，大多数 React 应用只会调用一次ReactDom.render()，而实现组件更新的办法就是将代码封装在<strong>有状态的组件</strong>中。</p>
</blockquote>
<h5 id="React-只更新必须更新的部分"><a href="#React-只更新必须更新的部分" class="headerlink" title="React 只更新必须更新的部分"></a>React 只更新必须更新的部分</h5><p>  这正是 React 的强大之处。React DOM 会将元素及其子元素与之前版本逐一对比，并只对有必要更新的 DOM 进行更新, 以达到 DOM 所需的状态。</p>
<p>  开发过程中，更应该每个时间点UI的表现, 而不是关注随着时间不断更新UI的状态, 可以减少很多奇怪的 bug</p>
<h3 id="组件和属性"><a href="#组件和属性" class="headerlink" title="$ 组件和属性"></a>$ 组件和属性</h3><p>  组件 <code>components</code> 和属性 <code>props</code>，其中，属性是单词 <code>property</code> 的代码简写。</p>
<h5 id="定义组件的两种办法"><a href="#定义组件的两种办法" class="headerlink" title="定义组件的两种办法"></a>定义组件的两种办法</h5><p>   定义组件有两种方式</p>
<ol>
<li><strong>函数式组件定义</strong></li>
<li><strong>类组件定义</strong><br>  最简单的定义组件的方法就是写一个 <code>Javascript</code> 函数</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>)  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, props.name<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>  这就是一个有效的组件，它接首了一个 <code>props</code> 参数，并返回了一个React元素，这是一个函数式组件，表面上看，他就是一个 <code>Javascript</code>函数。</p>
<p>  类组件的定义则依赖ES6 的 <code>class</code> 来定义，下面这种定义方法和上方是等效的;</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    render() &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="渲染一个组件"><a href="#渲染一个组件" class="headerlink" title="渲染一个组件"></a>渲染一个组件</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// DOM标签作为组件</span><br><span class="hljs-keyword">const</span> element = &lt;div /&gt;;<br><span class="hljs-comment">// React 元素作为组件</span><br><span class="hljs-keyword">const</span> element = &lt;Welcome name=<span class="hljs-string">&quot;Sara&quot;</span> /&gt;;<br></code></pre></td></tr></table></figure>

<p>  当React 遇到一个代表用户定义组件的元素时，它将 <code>JSX</code> 属性以一个单独对象即<br> <code>props对象</code> 的形式传递给相应的组件，例如</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.mname] <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Wlecome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Sara&quot;</span> /&gt;</span></span>;<br>ReactDOM.render(<br>    element,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p>【<strong>理解</strong>】</p>
<ol>
<li>调用 <code>ReactDOM.render()</code> 方法并向其传入了<code>&lt;Welcome name=&quot;Sara&quot; /&gt;</code>元素</li>
<li>Raect 调用 <code>Welcome</code> 组件，并向其传入了 <code>&#123;name： ‘Sara’&#125;</code> 作为 <code>props对象</code></li>
<li><code>Welcome</code> 组件返回 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code></li>
<li>React DOM 迅速更新 DOM，使其显示为 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code></li>
</ol>
<blockquote>
<p>组件名称总是以大写字母开始， 如本例子中 <code>&lt;Welcome /&gt;</code>, 而不是 <code>&lt;welcome /&gt;</code></p>
</blockquote>
<h5 id="构成组件"><a href="#构成组件" class="headerlink" title="构成组件"></a>构成组件</h5><p>  既然组件是单独的一个React元素，那他能单独工作，因此我们能在一个React 元素中多次引用到相同的组件, 举个例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;Welcome name=<span class="hljs-string">&quot;Sara&quot;</span> /&gt;<br>        &lt;Welcome name=<span class="hljs-string">&quot;Lucy&quot;</span> /&gt;<br>        &lt;Welcome name=<span class="hljs-string">&quot;Edite&quot;</span> /&gt;<br>    )<br>&#125;<br><br>ReactDOM.render(<br>    &lt;App /&gt;,<br>    document.getElementBuId(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p>  通常情况下， React apps 都有一个单独的顶层的 <code>App</code> 组件。如果是在已有的应用中整合React，也需要由下至上的从小的组件开始逐步整合到视图顶层的组件中。</p>
<blockquote>
<p>组件必须返回一个单独的根元素，这就是为什么我们要添加一个 <code>&lt;div&gt;</code>来包裹所有的<code>&lt;Welcome /&gt;</code> 元素的原因</p>
</blockquote>
<h5 id="提取组件"><a href="#提取组件" class="headerlink" title="提取组件"></a>提取组件</h5><p>  对于一个React 元素，如果其中含有可复用或可能会重复使用的内容，不要害怕把它单拿出来多个更小的组件。</p>
<p>  提取组件可能看起来是一个繁琐的工作，但是在大型的 <code>App</code> 中可以回报给我们的是大量的可复用组件。一个好的经验准则是如果你 UI 的一部分需要用多次 (<code>Button</code>，<code>Panel</code>，<code>Avatar</code>)，或者本身足够复杂(<code>App</code>，<code>FeedStory</code>，<code>Comment</code>)，最好的做法是使其成为可复用组件。</p>
<h5 id="Props-是只读的"><a href="#Props-是只读的" class="headerlink" title="Props 是只读的"></a>Props 是只读的</h5><p>  无论你用<a target="_blank" rel="noopener" href="http://www.css88.com/react/docs/components-and-props.html#functional-and-class-components">函数或类</a>的方法来声明组件,</p>
<p>  虽然 React 很灵活，但是它有一条严格的规则：**所有 React 组件都必须是纯函数，并禁止修改其自身 props **。所谓的纯函数就是：传入函数参数不会在函数执行过程中发生改变，比如自增操作 <code>a++</code>。</p>
<p>  如果<code>props</code>是只读的，那传递给子元素（子组件）的参数岂不是不能修改了？那子元素如何与父元素做交互呢？React还给我们提供了状态属性 <code>state</code>供我们在子组件内部修改值</p>
<h3 id="状态和生命周期"><a href="#状态和生命周期" class="headerlink" title="状态和生命周期"></a>状态和生命周期</h3><p>  状态<code>state</code>, 生命周期 <code>liftcircle</code>.<br>  之前说过，一旦元素被渲染了之后就不可改变了，但我们可以通过重新渲染的方法使页面得以刷新，同样我们提到过最常用的方法是编写一个可复用的具有状态的组件，这里的状态，就是我们将要说的 <code>state</code></p>
<p>  我们对上述提过的计时器<code>tick</code> 中的计时功能封装成一个函数式组件如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Clock</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;<br>            &lt;h1&gt;Hello, world!&lt;/h1&gt;<br>            &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;<br>        &lt;/div&gt;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  然后把他当做一个元素放入 <code>tick</code> 中进行渲染</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx">function tick() &#123;<br>    ReactDOM.render(<br>        &lt;Clock date&#x3D;&#123;new Date()&#125; &#x2F;&gt;,<br>        document.getElementById(&#39;root&#39;)<br>    )<br>&#125;<br><br>setInterval(tick, 1000);<br></code></pre></td></tr></table></figure>

<p>  在这个例子中，我们将计时功能代码封装成了一个独立的可复用的组件，并通过属性date的方式将参数传入，但还不能到达我们想要的结果，那就是不能再组件内部修改参数值，组件中显示的数据依旧受控于父组件中<code>date</code>属性传递过来的值，那如果我们把这个<code>date</code>属性也添加到<code>Clock</code>内部呢？来看下</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">ReactDOM.render(<br>    &lt;Clock /&gt;,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p>  这时父组件中只保留了对计时组件<code>Clock</code>的一个单纯的引用。剩下的事情全部依托以组件<code>Clock</code>自己去实现。要怎么实现这个需求？这里React提出了另一个数据对象，即<code>state</code>，它用来保存组件内部的数据，与<code>props</code>类似，不同的是<code>state</code>是组件私有的，并且由组件本身完全控制。它能实现数据在组件内部的修改和更新。怎么使用这个<code>state</code>？继续往下讲之前我们先拓展一个知识</p>
<p>  我们知道组件有两种定义方式，即函数式组件和类组件，虽然函数式组件更加简洁更加接近原生 <code>javascript</code>，但类组件却拥有一些额外的属性，这个<strong>类组件专有特性</strong>，就是<strong>状态</strong>和<strong>生命周期钩子</strong>，到这里也能清楚知道状态的关键作用，然而函数式组件没有这两个特性，因此，在需要使用到状态<code>state</code>情况下，我们需要将函数式组件转换成类组件</p>
<h5 id="函数式组件转化成类组件"><a href="#函数式组件转化成类组件" class="headerlink" title="函数式组件转化成类组件"></a>函数式组件转化成类组件</h5><p>  尝试把一个函数式组件转化成类组件，官网给出了以下步骤，以<code>Clock</code>组件为例</p>
<ol>
<li>创建一个继承自 <code>React.Component</code> 类的 <code>ES6 class</code> 同名类</li>
<li>添加一个名为 <code>render()</code> 的空方法</li>
<li>把原函数中的所有内容移至 <code>render()</code> 中</li>
<li>在 <code>render()</code> 方法中使用 <code>this.props</code> 替代 <code>props</code></li>
<li>删除保留的空函数声明</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-title">extents</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;h1&gt;Hello, world&lt;/h1&gt;<br>                &lt;h2&gt;It is &#123;<span class="hljs-built_in">this</span>.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  到此，<code>Clock</code> 组件已经成功被我们修改成了一个类组件，我们便可以在其中添加本地状态<code>state</code>和生命周期钩子</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-comment">// 用类构造函数constructor初始化 this.state</span><br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-comment">// 使用super()将props传递给基础构造函数</span><br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;;<br>    &#125;<br><br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;h1&gt;Hello, world&lt;/h1&gt;<br>                &lt;h2&gt;It is &#123;<span class="hljs-built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  这样，我们的类组件<code>Clock</code> 就拥有了自己的属性 <code>this.state.date</code>，也就不需要引用组件向其传递值了，因此，我么可以把组件引用中的<code>date</code>属性删掉，最终，我们将其渲染到DOM上，只使用组件引用，其他都交给组件<code>Clock</code>自己去实现</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">ReactDOM.render(<br>    &lt;Clock /&gt;,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p>  到这里就结束了？细心的你会发现，组件<code>Clock</code>只是实现了当前时间的显示，而我们要改装的功能是一个计时器，计时功能去哪里了？没实现啊？我们需要在组件<code>Clock</code>中找到一个合适的时机去实现这个功能，为此，React团队引入了 声明周期方法，也叫生命周期钩子</p>
<h5 id="在类组件中添加生命周期方法"><a href="#在类组件中添加生命周期方法" class="headerlink" title="在类组件中添加生命周期方法"></a>在类组件中添加生命周期方法</h5><p>  在一个具有许多组件的应用程序中，在组件被销毁时释放所占用的资源是非常重要的。就像浏览器的垃圾回收机制，近期内不需要再用的资源，应该及时清除。</p>
<p>  当 <code>Clock</code> 第一次渲染到DOM时，我们要<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval">设置一个定时器</a> 。 这在 React 中称为 “挂载(mounting)” 。它有一个生命钩子<code>componentDidMount()</code></p>
<p>当 <code>Clock</code> 产生的 DOM 被销毁时，我们也想<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval">清除该计时器</a>。 这在 React 中称为 “卸载(unmounting)” 。它的生命钩子是<code>componentWillUnmount()</code></p>
<p>  我们的计时器是在页面加载之后，页面生成初始化状态，然后由计时器去触发状态的刷新，因此，在挂载完成是去设置计时器是个非常不错的选择</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">componentDidMount() &#123;<br>    <span class="hljs-built_in">this</span>.timerID = <span class="hljs-built_in">setInterval</span>(<br>        () =&gt; <span class="hljs-built_in">this</span>.tick(), <span class="hljs-number">1000</span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  这样我们就实现了组件计时功能，或许你注意到了，在该例中，我们把<code>timerID</code>存放在<code>this</code>中而不是<code>this.state</code>中。</p>
<p>  其实，<code>this.props</code>和<code>this.state</code>也是数据对象与普通对象一样用来存放数据，只是他们被React团队赋予了新的职能， <code>this.props</code>由React本身设定，用来存放在组件引用时的属性键值对对象集，不允许Coder们自己去修改；而<code>this.state</code>也具有特殊的含义，即存放组件本身的、用于视觉输出的数据，但也不是说在编写React程序的时候就必须用用这两个，我们依然可以自己定义普通的数据结构。</p>
<p>  既然<code>state</code>是用于存放组件视觉输出的数据，那在<code>render()</code>方法中没有被引用的，就不应该出现在<code>state</code>中了。</p>
<p>  养成良好的编码习惯，编写好计时器时，及时的编写卸载事件。卸载时我们清除的数据也是从<code>this</code>中拿的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">componentWillUnmount() &#123;<br>    clearInterval(<span class="hljs-keyword">this</span>.timerID);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  挂载时我们声明了一个<code>tick()</code>方法，接下来我们就要实现这个方法，是用来触发UI更新。嗯哼？UI更新？我们的页面状态<code>state</code>不是已经更新了吗？为啥还要UI更新？</p>
<p>  这里有一个非常重要的方法：<code>setState()</code>。我们先把代码补充完整再说明</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx">componentDidMount() &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>tick() &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>        date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>    &#125;)<br>&#125;<br><br>componentWillUnmount() &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>  <code>setState()</code>是React触发页面更新的第二个办法，第一个办法开篇即说过，即<code>render()</code>方法。<code>setState</code>作用就是通知React检查带状态的组件中是否含有脏值。此时react会生成一个虚拟DOM与之前的版本进行对比，只有有必要更新时才会更新。关于 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/54a8a0688197">state 与 setState过程</a> 在我的另一篇文章中有详细说明，有兴趣的可以翻过去看看。</p>
<p>  为什么不把<code>tick()</code>方法写到<code>componentDidMount()</code>中？因为<code>tick()</code>只是一个普通方法，他不需要在生命周期中触发，也不用自动触发。只要谁调用了触发即可。因此不需要也不能放在生命周期钩子函数中。</p>
<p>  现在这个时钟每秒都会走了。整理一下，我们整个计时器代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(props) &#123;<br>    <span class="hljs-built_in">super</span>(props);<br>    <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;;<br>  &#125;<br><br>  componentDidMount() &#123;<br>    <span class="hljs-built_in">this</span>.timerID = <span class="hljs-built_in">setInterval</span>(<br>      () =&gt; <span class="hljs-built_in">this</span>.tick(),<br>      <span class="hljs-number">1000</span><br>    );<br>  &#125;<br><br>  componentWillUnmount() &#123;<br>    <span class="hljs-built_in">clearInterval</span>(<span class="hljs-built_in">this</span>.timerID);<br>  &#125;<br><br>  tick() &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>    &#125;);<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &lt;h1&gt;Hello, world!&lt;/h1&gt;<br>        &lt;h2&gt;It is &#123;<span class="hljs-built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br><br>ReactDOM.render(<br>  &lt;Clock /&gt;,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>

<p>整个流程的执行过程是这样的：</p>
<ol>
<li>当 <code>&lt;Clock /&gt;</code> 被传入<code>ReactDOM.render()</code> 时,  React 会调用 <code>Clock</code>组件的构造函数。 因为 <code>Clock</code> 要显示的是当前时间，所以它将使用包含当前时间的对象来初始化 <code>this.state</code>。我们稍后会更新此状态。</li>
<li>然后 React 调用了 <code>Clock</code> 组件的 <code>render()</code> 方法。 React 从该方法返回内容中得到要显示在屏幕上的内容。然后，React 然后更新 DOM 以匹配 <code>Clock</code> 的渲染输出。</li>
<li>当 <code>Clock</code> 输出被插入到 DOM 中时，React 调用 <code>componentDidMount()</code> 生命周期钩子。在该方法中，<code>Clock</code> 组件请求浏览器设置一个定时器来一次调用 <code>tick()</code>。</li>
<li>浏览器会每隔一秒调用一次 <code>tick()</code>方法。在该方法中， <code>Clock</code> 组件通过 <code>setState()</code> 方法并传递一个包含当前时间的对象来安排一个 UI 的更新。通过 <code>setState()</code>, React 得知了组件 <code>state</code>(状态)的变化, 随即再次调用 <code>render()</code> 方法，获取了当前应该显示的内容。 这次，<code>render()</code> 方法中的 <code>this.state.date</code> 的值已经发生了改变， 从而，其输出的内容也随之改变。React 于是据此对 DOM 进行更新。</li>
<li>如果通过其他操作将 <code>Clock</code> 组件从 DOM 中移除了, React 会调用 <code>componentWillUnmount()</code> 生命周期钩子, 所以计时器也会被停止。</li>
</ol>
<h5 id="正确的使用State（状态）"><a href="#正确的使用State（状态）" class="headerlink" title="正确的使用State（状态）"></a>正确的使用State（状态）</h5><p>  对于<code>setState()</code> 有三件事情是我们应该要知道的</p>
<p><strong>（1）不要直接修改state</strong><br>  真正触发React对比不同版本的虚拟DOM是<code>setState()</code> 方法，直接修改<code>state</code>页面不会刷新，这一点与原生<code>javascript</code>区别较大，需要理解。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这么做不会触发React更新页面</span><br><span class="hljs-keyword">this</span>.state.comment = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-comment">// 使用 setState() 代替</span><br><span class="hljs-keyword">this</span>.setState(&#123; comment: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure>

<p>  【注意】在组件中，唯一可以初始化分配<code>this.state</code>的地方就是构造函数<code>constructor()&#123;&#125;</code></p>
<p><strong>（2）state（状态）更新可能是异步的</strong><br>  React为了优化性能，有可能会将多个<code>setState()</code> 调用合并为一次更新。这就导致 <code>this.props</code> 和<code>this.state</code> 可能是异步更新的，你不能依赖他们的值计算下一个<code>state(状态)</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// counter 计数更新会失败</span><br><span class="hljs-keyword">this</span>.setState(&#123;<br>    counter: <span class="hljs-keyword">this</span>.state.counter <span class="hljs-keyword">this</span>.props.increment<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>  如果我们有这种需求，可以使用以下<code>setState()</code>办法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// ES6 箭头函数法</span><br><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">prevState, props</span>) =&gt;</span> (&#123;<br>    counter: prevState.counter + props.increment<br>&#125;));<br><span class="hljs-comment">// 常规函数法</span><br><span class="hljs-built_in">this</span>.setState(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prevState, props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        counter: prevState.counter + props.increment<br>    &#125;;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><strong>（3）state（状态）更新会被合并</strong><br> 当你调用<code>setState()</code>, React将合并你提供的对象到当前状态中。例如，你的状态可能包含几个独立的变量，然后你用几个独立的setState方法去调用更新，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs tsx">constructor(props) &#123;<br>    super(props);<br>    this.state &#x3D; &#123;<br>        posts: [],<br>        comments: []<br>    &#125;;<br>&#125;<br><br>componentDidMount() &#123;<br>    fetchPosts().then(response &#x3D;&gt; &#123;<br>        this.setState(&#123;<br>            posts: response.posts<br>        &#125;);<br>    &#125;);<br><br>    fetchComments().then(response &#x3D;&gt; &#123;<br>        this.setState(&#123;<br>            comments: response.comments<br>        &#125;);<br>    &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>  合并是<strong>浅合并</strong>，所以，<code>this.setState(&#123;comments&#125;)</code>在合并过程中不会改变<code>this.state.posts</code>的值，但是会完全替换<code>this.state.comments</code> 的值</p>
<h5 id="数据向下流动"><a href="#数据向下流动" class="headerlink" title="数据向下流动"></a>数据向下流动</h5><p>  无论是作为父组件还是子组件，它都无法或者一个组件是否有状体，同时也不需要关心另一个组件是定义为函数组件还是类组件。这就是为什么<code>state</code>经常被称为 <strong>本地状态</strong>  或 <strong>封装状态</strong>  的原因， 他不能被拥有并设置它的组件以外的任何组件访问。那如果需要访问怎么处理？<br> <strong>（1）作为其子组件的props（属性）</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在组件中使用</span><br>&lt;h2&gt;It <span class="hljs-keyword">is</span> &#123;<span class="hljs-keyword">this</span>.state.date.toLocaleTimeString()&#125;&lt;/h2&gt;<br><span class="hljs-comment">// 传递给子组件作为props</span><br>&lt;FormattedDate date=&#123;<span class="hljs-keyword">this</span>.state.date&#125; /&gt;<br></code></pre></td></tr></table></figure>

<p>  虽然<code>FormattedDate</code>组件通过<code>props</code>接收了<code>date</code>的值，但它仍然不能获知该值是来自于<code>Clock</code>的<code>state</code>, 还是 <code>Clock</code>的<code>props</code>, 或者一个手动创建的变量.</p>
<p>  这种数据关系，一般称为”从上到下”或”单向”的数据流。任何<code>state(状态)</code>始终由某个特定组件所有，并且从该<code>state</code>导出的任何数据 或 UI 只能影响树”下方”的组件</p>
<p>  如果把组件树想像为 <code>props(属性)</code> 的瀑布，所有组件的 <code>state(状态)</code> 就如同一个额外的水源汇入主流，且只能随着主流的方向向下流动。</p>
<h5 id="各组件完全独立"><a href="#各组件完全独立" class="headerlink" title="各组件完全独立"></a>各组件完全独立</h5><p>  借用上文的<code>Clock</code>组件，我们创建一个<code>App</code>组件，并在其中渲染三个<code>Clock</code>:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="hljs-comment">// 之前说过组件只能返回一个根节点，所以用&lt;div&gt;包起来</span><br>        &lt;div&gt;<br>            &lt;Clock /&gt;<br>            &lt;Clock /&gt;<br>            &lt;Clock /&gt;<br>        &lt;/div&gt;<br>    );<br>&#125;<br>ReactDOM.render(<br>    &lt;App /&gt;,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>

<p>  每个<code>Clock</code>都设立它自己的计时器并独立更新，如果<code>App</code>中有一个数据变量，也能被三个<code>Clock</code>相互独立修改。</p>
<p>  至于何时使用有状态组件，何时使用无状态组件，被认为是组件的一个实现细节，取决于你当时的需求，你可以在有状态组件中使用无状态组件，也可以在无状态组件中使用有状态组件</p>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="$ 事件处理"></a>$ 事件处理</h3><p>  通过 React 元素处理事件跟在 DOM 元素上处理事件非常相似。但是有一些语法上的区别：</p>
<ol>
<li>React 事件使用驼峰命名，而不是全部小写</li>
<li>通过 JSX , 传递一个函数作为事件处理程序，而不是一个字符串</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">// html usage<br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;todo()&quot;</span>&gt;</span>click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>// React usage<br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;todo&#125;</span>&gt;</span>click me&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol>
<li>在React中不能通过返回<code>false</code>来阻止默认行为。必须明确的调用<code>preventDefault</code></li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">// html usage<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;clicked&#x27;); return false&quot;</span>&gt;</span><br>    Click me<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>



<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// React usage</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActionLink</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleClick</span>(<span class="hljs-params">e</span>) </span>&#123;<br>        e.preventDefault();<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;clicked.&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;a href=<span class="hljs-string">&quot;#&quot;</span> onClick=&#123;handleClick&#125;&gt;<br>            Click me<br>        &lt;/a&gt;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  在这里，React团队帮Coder们实现了e事件的跨浏览器兼容问题。当使用React时，我们也不需要调用<code>addEventListener</code>在DOM 元素被创建后添加事件监听器。相反，只要当元素被初始渲染的时候提供一个监听器就可以了。</p>
<p>  当使用ES6类定义一个组件时，通常的一个事件处理程序就是类上的一个方法，看个例子，<code>Toggle</code> 组件渲染一个按钮，让用户在 “ON” 和 “OFF” 状态之间切换：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Toggle</span> <span class="hljs-title">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.state = &#123;isToggleOn: <span class="hljs-literal">true</span>&#125;;<br><br>    <span class="hljs-comment">// 这个绑定是必要的，使`this`在回调中起作用</span><br>    <span class="hljs-keyword">this</span>.handleClick = <span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>);<br>  &#125;<br><br>  handleClick() &#123;<br>    <span class="hljs-keyword">this</span>.setState(prevState =&gt; (&#123;<br>      isToggleOn: !prevState.isToggleOn<br>    &#125;));<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;button onClick=&#123;<span class="hljs-keyword">this</span>.handleClick&#125;&gt;<br>        &#123;<span class="hljs-keyword">this</span>.state.isToggleOn ? <span class="hljs-string">&#x27;ON&#x27;</span> : <span class="hljs-string">&#x27;OFF&#x27;</span>&#125;<br>      &lt;/button&gt;<br>    );<br>  &#125;<br>&#125;<br><br>ReactDOM.render(<br>  &lt;Toggle /&gt;,<br>  document.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>

<h5 id="绑定类方法"><a href="#绑定类方法" class="headerlink" title="绑定类方法"></a>绑定类方法</h5><p>  在JSX回调中你必须注意 <code>this</code> 的指向。 在 JavaScript 中，类方法默认没有 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind">绑定</a> 的。如果你忘记绑定 <code>this.handleClick</code> 并将其传递给<code>onClick</code>，那么在直接调用该函数时，<code>this</code> 会是 <code>undefined</code> 。</p>
<p> 这不是 React 特有的行为；这是 <code>JavaScript</code> 中的函数如何工作的一部分，可以使用属性初始值设置来正确地 绑定(<code>bind</code>) 回调，但这是实验性做法，不建议使用，以后有可能会废弃，如果你没有使用属性初始化语法<br> （1）可以在回调中使用一个 <code>arrow functions</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    handleClick() &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this is: &#x27;</span>, <span class="hljs-built_in">this</span>)<br>    &#125;<br><br>    render() &#123;<br>        <span class="hljs-comment">// 这个语法确保 `this` 被绑定在 handleClick 中</span><br>        <span class="hljs-keyword">return</span> (<br>            &lt;button onClick=&#123;<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-built_in">this</span>.handleClick(e)&#125;&gt;<br>                Click me<br>            &lt;/button&gt;<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>（2）使用<code>Function.prototype.bind</code> 方法，相对简洁方便</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;button onClick=&#123;<span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>)&#125;&gt;<br>    Click me<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<h5 id="传递参数给事件处理程序"><a href="#传递参数给事件处理程序" class="headerlink" title="传递参数给事件处理程序"></a>传递参数给事件处理程序</h5><p>  在循环内部，通常需要将一个额外的参数传递给事件处理程序，常用的有一下两种方案;</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;button onClick=&#123;(e)  =&gt; <span class="hljs-keyword">this</span>.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;<br>&lt;button onClick=&#123;<span class="hljs-keyword">this</span>.deleteRow.bind(<span class="hljs-keyword">this</span>.id)&#125;&gt;Delete Row&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<p>  上面两个例子中，参数 <code>e</code> 作为 React 事件对象将会被作为第二个参数进行传递。通过箭头函数的方式，事件对象必须显式的进行传递，但是通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="$ 条件渲染"></a>$ 条件渲染</h3><blockquote>
<p>在 React 中，你可以创建不同的组件封装你所需要的行为。然后，只渲染它们之中的一些，取决于你的应用的状态。</p>
</blockquote>
<h5 id="整个组件的条件渲染"><a href="#整个组件的条件渲染" class="headerlink" title="整个组件的条件渲染"></a>整个组件的条件渲染</h5><p>  React 中的条件渲染就可在JS中的条件语句一样，使用JS操作符如<code>if</code>或者条件控制符来创建渲染当前的元素，并且让React更新匹配的UI。比如我们有一个需求，需要判断用户是否登录，来显示不同组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserGreeting</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome back!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GustGrreeting</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Please sign up.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> isLoggedIn = props.isLoggedIn;<br>    <span class="hljs-keyword">if</span> (isLoggedIn) &#123;<br>        <span class="hljs-keyword">return</span> &lt;UserGreeting /&gt;<br>    &#125; <br>    <span class="hljs-keyword">return</span> &lt;GuestGreeting /&gt;<br>&#125;<br><br>ReactDOM.render(<br>    &lt;Greeting isLoggedIn=&#123;<span class="hljs-literal">false</span>&#125; /&gt;,<br>    document.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>

<h5 id="使用元素变量条件渲染部分内容"><a href="#使用元素变量条件渲染部分内容" class="headerlink" title="使用元素变量条件渲染部分内容"></a>使用元素变量条件渲染部分内容</h5><p>  你可以用变量来存储元素。这可以帮助您有条件地渲染组件的一部分，而输出的其余部分不会更改。下方两个组件用于显示登出和登入按钮</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LoginButton</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span>(<br>        &lt;button onClick=&#123;props.onClick&#125;&gt;Login&lt;/button&gt;<br>    )<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LogoutButton</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;button onClick=&#123;props.onclick&#125;&gt;Logout&lt;/button&gt;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  登入登出按钮已做好，接下来需要实现有切换功能的一个有状态的组件，为了更系统化学习，我们把前面的<code>Greeting</code>组件一起加进来</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginControl</span> <span class="hljs-title">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-keyword">super</span>(props);<br>        <span class="hljs-keyword">this</span>.state = &#123;<br>            isLoginedIn: <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br><br>    handleLoginClick() &#123;<br>        <span class="hljs-keyword">this</span>.setState(&#123;   isLoggedIn: <span class="hljs-literal">true</span> &#125;);<br>    &#125;<br><br>    handleLogoutClick() &#123;<br>        <span class="hljs-keyword">this</span>.setState(&#123; isLoggedIn: <span class="hljs-literal">false</span> &#125;);<br>    &#125;<br><br>    render() &#123;<br>        <span class="hljs-keyword">const</span> isLoggedIn = <span class="hljs-keyword">this</span>.state.isLoggedIn;<br><br>        let button = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (isLoggedIn) &#123;<br>            button = &lt;LogoutButton onClick=&#123;<span class="hljs-keyword">this</span>.handleLogoutClick.bind(<span class="hljs-keyword">this</span>)&#125; /&gt;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            button = &lt;LoginButton onclick=&#123;<span class="hljs-keyword">this</span>.handleLoginClick.bind(<span class="hljs-keyword">this</span>)&#125; /&gt;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;&#123;button&#125;&lt;/div&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br><br>reactDOM.render(<br>    &lt;LoginControl /&gt;,<br>    document.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p>  使用<code>if</code>是很常见的一种做法，当然也有一些更简短的语。<code>JSX</code>中有几种内联条件的方法，</p>
<p><strong>（1）使用逻辑与&amp;&amp;操作符的内联if用法</strong><br>  我们可以在 <code>JSX</code> 中嵌入任何表达式，方法是将其包裹在花括号中，同样适用于JS的逻辑与&amp;&amp;运算符</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mailbox</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> unreadMessages = props.unreadMessages;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;<br>            &lt;h1&gt;Hello!&lt;/h1&gt;<br>            &#123; unreadMeaasges.length &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                &lt;h2&gt; You have &#123;unreadMessages.length&#125; unread messages.<br>            &#125;<br>        &lt;/div&gt;<br>    )<br>&#125;<br><br>cosnt message = [<span class="hljs-string">&#x27;React&#x27;</span>, <span class="hljs-string">&#x27;Re: React&#x27;</span>, <span class="hljs-string">&#x27;Re:Re: React&#x27;</span>];<br>ReactDOM.render(<br>    &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;,<br>    document.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>

<p>  该案例是可以正常运行的，因为在 <code>JavaScript</code> 中， <code>true &amp;&amp; expression</code> 总是会评估为 <code>expression</code> ，而 <code>false &amp;&amp; expression</code> 总是执行为 <code>false</code> 。并且我们可以在表达式中嵌入表达式</p>
<p><strong>（2）使用条件操作符的内联If-Else</strong><br>  条件操作符 即三目表达式：<code>condition ？ trueExpression : falseExpression</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 条件渲染字符串</span><br>&lt;div&gt;The user <span class="hljs-keyword">is</span> &#123;isLoggedIn ? <span class="hljs-string">&#x27;currently&#x27;</span> : <span class="hljs-string">&#x27;not&#x27;</span>&#125; logged <span class="hljs-keyword">in</span>.&lt;/div&gt;<br><span class="hljs-comment">// 条件渲染组件</span><br>&lt;div&gt;<br>    &#123;isLoggedIn ? (<br>        &lt;LogoutButton onClick=&#123;<span class="hljs-keyword">this</span>.handleLogoutClick&#125; /&gt;<br>    ) : (<br>        &lt;LoginButton onClick=&#123;<span class="hljs-keyword">this</span>.handleLoginClick&#125; /&gt;<br>    )&#125;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>  总之，遵循一个原则，哪种方式易于阅读，就选择哪种写法。并且，但条件变得越来越复杂时，可能是提取组件的好时机。</p>
<h5 id="阻止组件渲染"><a href="#阻止组件渲染" class="headerlink" title="阻止组件渲染"></a>阻止组件渲染</h5><p>  在极少数情况下，您可能希望组件隐藏自身，即使它是由另一个组件渲染的。为此，返回 <code>null</code> 而不是其渲染输出。注意这里是不渲染，不是不显示。</p>
<p>  在下面的例子中，根据名为<code>warn</code>的 <code>props</code> 值，呈现 <code>&lt;WarningBanner /&gt;</code> 。如果 <code>props</code> 值为 <code>false</code> ，则该组件不渲染：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WarningBanner</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (props.warn) &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> (<br>        &lt;div className=<span class="hljs-string">&quot;warning&quot;</span>&gt;Warning&lt;/div&gt;<br>    )<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">showWarning</span>: <span class="hljs-literal">true</span> &#125;<br>    &#125;<br><br>    handleToggleClick() &#123;<br>        <span class="hljs-built_in">this</span>.setState(<span class="hljs-function"><span class="hljs-params">prevState</span> =&gt;</span> (&#123;<br>            showWarning: !prevState.showWarning<br>        &#125;));<br>    &#125;<br><br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;Warningbanner warn=&#123;<span class="hljs-built_in">this</span>.state.showWarning&#125; /&gt;<br>                &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.handleToggleClick.bind(<span class="hljs-built_in">this</span>)&#125;&gt;<br>                    &#123; <span class="hljs-built_in">this</span>.state.showWarning ?   <span class="hljs-string">&#x27;Hide&#x27;</span> : <span class="hljs-string">&#x27;Show&#x27;</span>&#125;<br>                 &lt;/button&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br><br>ReactDOM.render(<br>    &lt;Page /&gt;,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p>  从组件的 <code>render</code> 方法返回 <code>null</code> 不会影响组件生命周期方法的触发。 例如， <code>componentWillUpdate</code> 和<code>componentDidUpdate</code> 仍将被调用。因此需要组件刚载入时就要判断执行返回<code>null</code></p>
<h3 id="后语"><a href="#后语" class="headerlink" title="$ 后语"></a>$ 后语</h3><p>  本文为React系统性需学习上半文，下半文主要包括：</p>
<ol>
<li>列表(<code>List</code>) 和 键(<code>keys</code>)</li>
<li>表单(<code>Forms</code>)</li>
<li>状态提升(<code>Lifting State Up</code>)</li>
<li>组合 VS 继承 (<code>Composition vs inheritance</code>)</li>
</ol>

      </section>
      <section class="extra">
        
        <ul class="copyright">
  
  <li><strong>本文作者：</strong>lc</li>
  <li><strong>本文链接：</strong><a href="http://example.com/2021/03/18/recat/index.html">http://example.com/2021/03/18/recat/index.html</a></li>
  <li><strong>版权声明：</strong>本博客所有文章均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"
      rel="external nofollow" target="_blank"> BY-NC-SA </a>许可协议，转载请注明出处！</li>
  
</ul>
        
        
        <section class="donate">
  <div class="qrcode">
    <img src="https://pic.izhaoo.com/alipay.jpg">
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

        
<nav class="nav">
  
    <a href="/2021/03/18/%E6%B5%85%E6%9E%90webpack%E5%8E%9F%E7%90%86/"><i class="iconfont iconleft"></i>浅析webpack原理</a>
  
  
    <a href="/2021/03/18/typeScript/">Ts<i class="iconfont iconright"></i></a>
  
</nav>

      </section>
      
      <section class="comments">
  
  <div class="btn" id="comments-btn">查看评论</div>
  
  
</section>
      
    </section>
  </div>
</article>
  </div>
</main>
  <footer class="footer">
  <div class="footer-social">
    
    
    
    
    
    <a href="tencent://message/?Menu=yes&uin=2504971404 " target="_blank" onMouseOver="this.style.color= '#12B7F5'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconQQ "></i>
    </a>
    
    
    
    
    
    <a href="javascript:; " target="_blank" onMouseOver="this.style.color= '#09BB07'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconwechat-fill "></i>
    </a>
    
    
    
    
    
    <a href="https://www.instagram.com/izhaoo/ " target="_blank" onMouseOver="this.style.color= '#DA2E76'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconinstagram "></i>
    </a>
    
    
    
    
    
    <a href="https://github.com/izhaoo " target="_blank" onMouseOver="this.style.color= '#24292E'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  icongithub-fill "></i>
    </a>
    
    
    
    
    
    <a href="mailto:izhaoo@163.com " target="_blank" onMouseOver="this.style.color='#FFBE5B'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconmail"></i>
    </a>
    
  </div>
  <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  <div class="fab fab-daovoice">
    <i class="iconfont iconcomment"></i>
  </div>
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>


<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>






<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>






<script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>






<script src="/js/utils.js"></script>
<script src="/js/modules.js"></script>
<script src="/js/zui.js"></script>
<script src="/js/script.js"></script>





<script>
  (function (i, s, o, g, r, a, m) {
    i["DaoVoiceObject"] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o), m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    a.charset = "utf-8";
    m.parentNode.insertBefore(a, m)
  })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
    "//widget.daovoice.io/widget/0f81ff2f.js", "daovoice")
  daovoice('init', {
    app_id: "abcdefg"
  }, {
    launcher: {
      disableLauncherIcon: true,
    },
  });
  daovoice('update');
</script>



<script>
  (function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>


<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4c204d8bc027a0455b5fc642ac334ca8";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>










</html>