

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>vue源码理解——变化侦测篇 - cocacola</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />

  
  
  <meta name="description" content="1.变化侦测篇Vue中如何实现数据的响应式系统，从而达..."> 
  
  <meta name="author" content="lc"> 

  
    <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  
  
    <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  
  
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  
  
    <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_h1619vhl1nr.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css">

  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        loadingImage: '',
      },
      donate: {
        enable: true,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      motto: {
        api: '',
        default: '将喜欢的一切留在身边，这便是努力的意义。'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        alwaysShow: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: true
      }
    }
  </script>

  

  
<meta name="generator" content="Hexo 5.4.0"></head>
<body class="lock-screen">
  <div class="loading"></div>
  


<nav class="navbar">
  <div class="left"></div>
  <div class="center">vue源码理解——变化侦测篇</div>
  <div class="right">
    <i class="iconfont iconmenu j-navbar-menu"></i>
  </div>
</nav>

  <nav class="menu">
  <div class="menu-wrap">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content">
      
      
      
      
      <li class="menu-item"><a href="/ " class="underline"> 首页</a></li>
      
      
      
      
      <li class="menu-item"><a href="/galleries " class="underline"> 摄影</a></li>
      
      
      
      
      <li class="menu-item"><a href="/archives " class="underline"> 归档</a></li>
      
      
      
      
      <li class="menu-item"><a href="/tags " class="underline"> 标签</a></li>
      
      
      
      
      <li class="menu-item"><a href="/categories " class="underline"> 分类</a></li>
      
      
      
      
      <li class="menu-item"><a href="/about " class="underline"> 关于</a></li>
      
    </ul>
    <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  </div>
</nav>
  <main id="main">
  <div class="container" id="container">
    <article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1622495506073-56b1152a010c.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">vue源码理解——变化侦测篇</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>March 18, 2021</span
        class="post-info-item">
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>18456</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h3 id="1-变化侦测篇"><a href="#1-变化侦测篇" class="headerlink" title="1.变化侦测篇"></a>1.变化侦测篇</h3><p><code>Vue</code>中如何实现数据的响应式系统，从而达到数据驱动视图。</p>
<h5 id="变化侦测"><a href="#变化侦测" class="headerlink" title="变化侦测"></a>变化侦测</h5><p>vue最大的特点之一就是数据驱动视图</p>
<p>什么是数据驱动视图？我们可以把数据理解成状态，而视图就是用户可以直观看到的，页面不是一层不变的，它是动态变化的，它可能是用户操作引起变化，也可能因为后台数据引起变化的，不管它尤什么引起的，我们统称状态变了由前一个状态变到了后一个状态，页面也就应该随之而变化，所以我们就可以得到如下一个公式：**<em>UI = render(state)**</em></p>
<p>公式中：状态<code>state</code>是输入，页面<code>UI</code>输出，状态输入一旦变化了，页面输出也随之而变化。我们把这种特性称之为数据驱动视图。</p>
<p>OK，有了基本概念以后，我们再把上述公式拆成三部分：<code>state</code>、<code>render()</code>以及<code>UI</code>。我们知道<code>state</code>和<code>UI</code>都是用户定的，而不变的是这个<code>render()</code>。所以<code>Vue</code>就扮演了<code>render()</code>这个角色，当<code>Vue</code>发现<code>state</code>变化之后，经过一系列加工，最终将变化反应在<code>UI</code>上。</p>
<h5 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h5><h5 id="Object的变化侦测"><a href="#Object的变化侦测" class="headerlink" title="Object的变化侦测"></a>Object的变化侦测</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> car = &#123;&#125;<br>        <span class="hljs-keyword">let</span> val = <span class="hljs-number">3000</span><br>        <span class="hljs-built_in">Object</span>.defineProperty(car, <span class="hljs-string">&#x27;price&#x27;</span>, &#123;<br>            enumerable: <span class="hljs-literal">true</span>,<br>            configurable: <span class="hljs-literal">true</span>,<br>            get() &#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;price 的属性被读取了&#x27;</span>)<br>                <span class="hljs-keyword">return</span> val<br>            &#125;,<br>            set(newval) &#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;price的属性被修改了&#x27;</span>)<br>                val = newval<br>            &#125;<br>        &#125;)<br><span class="hljs-comment">//通过Object.defineProperty()方法给car定义了一个price属性，并把这个属性的读和写分别使用get()和set()进行拦截，每当该属性进行读或写操作的时候就会触发get()和set()  如下图</span><br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210421145548907.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20210421145548907"></p>
<p>注：enumerable控制是否可以删除</p>
<p>​         configurable控制是否可以枚举（循环遍历）</p>
<p>怎么把<code>car</code>的所有属性都变得可观测？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>            <span class="hljs-keyword">constructor</span>(value) &#123;<br>                <span class="hljs-built_in">this</span>.value = value<br><span class="hljs-comment">// 给value新增一个__ob__属性，值为该value的Observer实例</span><br><span class="hljs-comment">// 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作</span><br>                def(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>, <span class="hljs-built_in">this</span>)<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>                    <span class="hljs-comment">// 当value为数组时的逻辑</span><br>                    <span class="hljs-comment">// ...</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">this</span>.walk(value)<br>                &#125;<br>            &#125;<br><br>            walk(obj:<span class="hljs-built_in">Object</span>) &#123;<br>                <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(obj)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) &#123;<br>                    defineReactive(obj, keys[i])<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 使一个对象转化成可观测对象</span><br><span class="hljs-comment">         * @param &#123; Object &#125; obj 对象</span><br><span class="hljs-comment">         * @param &#123; String &#125; key 对象的key</span><br><span class="hljs-comment">         * @param &#123; Any &#125; val 对象的某个key的值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) </span>&#123;<br>            <span class="hljs-comment">// 如果只传了obj和key，那么val = obj[key]</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) &#123;<br>                val = obj[key]<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>                <span class="hljs-keyword">new</span> Observer(val)<br>            &#125;<br>            <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>                enumerable: <span class="hljs-literal">true</span>,<br>                configurable: <span class="hljs-literal">true</span>,<br>                get() &#123;<br>                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>属性被读取了`</span>);<br>                    <span class="hljs-keyword">return</span> val;<br>                &#125;,<br>                set(newVal) &#123;<br>                    <span class="hljs-keyword">if</span> (val === newVal) &#123;<br>                        <span class="hljs-keyword">return</span><br>                    &#125;<br>                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>属性被修改了`</span>);<br>                    val = newVal;<br>                &#125;<br>            &#125;)<br>        &#125;<br>        <span class="hljs-keyword">let</span> car = <span class="hljs-keyword">new</span> Observer(&#123;<br>            <span class="hljs-string">&#x27;brand&#x27;</span>: <span class="hljs-string">&#x27;BMW&#x27;</span>,<br>            <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">3000</span><br>        &#125;)<br></code></pre></td></tr></table></figure>

<p>​             在上面的代码中，我们定义了<code>observer</code>类，它用来将一个正常的<code>object</code>转换成可观测的<code>object</code>。</p>
<p>并且给<code>value</code>新增一个<code>__ob__</code>属性，值为该<code>value</code>的<code>Observer</code>实例。这个操作相当于为<code>value</code>打上标记，表示它已经被转化成响应式了，避免重复操作</p>
<p>然后判断数据的类型，只有<code>object</code>类型的数据才会调用<code>walk</code>将每一个属性转换成<code>getter/setter</code>的形式来侦测变化。 最后，在<code>defineReactive</code>中当传入的属性值还是一个<code>object</code>时使用<code>new observer（val）</code>来递归子属性，这样我们就可以把<code>obj</code>中的所有属性（包括子属性）都转换成<code>getter/seter</code>的形式来侦测变化。 也就是说，只要我们将一个<code>object</code>传到<code>observer</code>中，那么这个<code>object</code>就会变成可观测的、响应式的<code>object</code>。</p>
<h6 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h6><p>什么是依赖收集？</p>
<p>如上，我们可以做到数据可观测性，这样我们就可以知道什么时候发生了什么变化，当数据发生变化后，我们去通知视图去更新就好了，但是视图有好多，到底去通知谁去变化？肯定不能一个数据变了然后去刷新所有视图，所以要做到：视图里谁用到了这个数据就更新谁</p>
<p>视图里谁用到了这个数据就更新谁，换个说法就是我们把”谁用到了这个数据”称为”谁依赖了这个数据”,我们给每个数据都建一个依赖数组(因为一个数据可能被多处使用)，谁依赖了这个数据(即谁用到了这个数据)我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们：”你们依赖的数据变啦，你们该更新啦！”。这个过程就是<code>依赖收集</code></p>
<p>谁用到了这个数据，其实就是谁获取了这个数据，而可观测的数据被获取时会触发<code>getter</code>属性，那么我们就可以在<code>getter</code>中收集这个依赖。同样，当这个数据变化时会触发<code>setter</code>属性，那么我们就可以在<code>setter</code>中通知依赖更新。</p>
<p>总结一句话就是：<strong>在getter中收集依赖，在setter中通知依赖更新</strong></p>
<h6 id="把依赖收集到哪？？？"><a href="#把依赖收集到哪？？？" class="headerlink" title="把依赖收集到哪？？？"></a>把依赖收集到哪？？？</h6><p>我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中。单单用一个数组来存放依赖的话，功能好像有点欠缺并且代码过于耦合。我们应该将依赖数组的功能扩展一下，更好的做法是我们应该为每一个数据都建立一个依赖管理器，把这个数据所有的依赖都管理起来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span> () &#123;<br>    <span class="hljs-built_in">this</span>.subs = []<br>  &#125;<br><br>  addSub (sub) &#123;<br>    <span class="hljs-built_in">this</span>.subs.push(sub)<br>  &#125;<br>  <span class="hljs-comment">// 删除一个依赖</span><br>  removeSub (sub) &#123;<br>    remove(<span class="hljs-built_in">this</span>.subs, sub)<br>  &#125;<br>  <span class="hljs-comment">// 添加一个依赖</span><br>  depend () &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.target) &#123;<br>      <span class="hljs-built_in">this</span>.addSub(<span class="hljs-built_in">window</span>.target)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 通知所有依赖更新</span><br>  notify () &#123;<br>    <span class="hljs-keyword">const</span> subs = <span class="hljs-built_in">this</span>.subs.slice()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = subs.length; i &lt; l; i++) &#123;<br>      subs[i].update()<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Remove an item from an array</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span> (<span class="hljs-params">arr, item</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (arr.length) &#123;<br>    <span class="hljs-keyword">const</span> index = arr.indexOf(item)<br>    <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-keyword">return</span> arr.splice(index, <span class="hljs-number">1</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的依赖管理器<code>Dep</code>类中，我们先初始化了一个<code>subs</code>数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作</p>
<p>有了依赖管理器后，我们就可以在getter中收集依赖，在setter中通知依赖更新了，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) </span>&#123;<br>           <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) &#123;<br>               val = obj[key]<br>           &#125;<br>           <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>               <span class="hljs-keyword">new</span> Observer(val)<br>           &#125;<br>           <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep() <span class="hljs-comment">//实例化一个依赖管理器，生成一个依赖管理数组dep</span><br>           <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>               enumerable: <span class="hljs-literal">true</span>,<br>               configurable: <span class="hljs-literal">true</span>,<br>               get() &#123;<br>                   dep.depend() <span class="hljs-comment">// 在getter中收集依赖</span><br>                   <span class="hljs-keyword">return</span> val;<br>               &#125;,<br>               set(newVal) &#123;<br>                   <span class="hljs-keyword">if</span> (val === newVal) &#123;<br>                       <span class="hljs-keyword">return</span><br>                   &#125;<br>                   val = newVal;<br>                   dep.notify() <span class="hljs-comment">// 在setter中通知依赖更新</span><br>               &#125;<br>           &#125;)<br>       &#125;<br></code></pre></td></tr></table></figure>

<p>在上述代码中，我们在<code>getter</code>中调用了<code>dep.depend()</code>方法收集依赖，在<code>setter</code>中调用<code>dep.notify()</code>方法通知所有依赖更新。</p>
<h6 id="依赖是谁？？？"><a href="#依赖是谁？？？" class="headerlink" title="依赖是谁？？？"></a>依赖是谁？？？</h6><p>通过上一章节，我们明白了什么是依赖？何时收集依赖？以及收集的依赖存放到何处？那么我们收集的依赖到底是谁？</p>
<p>虽然我们一直在说”谁用到了这个数据谁就是依赖“，但是这仅仅是在口语层面上，那么反应在代码上该如何来描述这个”谁“呢？</p>
<p>其实在<code>Vue</code>中还实现了一个叫做<code>Watcher</code>的类，而<code>Watcher</code>类的实例就是我们上面所说的那个”谁”。换句话说就是：谁用到了数据，谁就是依赖，我们就为谁创建一个<code>Watcher</code>实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的<code>Watch</code>实例，由<code>Watcher</code>实例去通知真正的视图。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span> (vm,expOrFn,cb) &#123;<br>    <span class="hljs-built_in">this</span>.vm = vm;<br>    <span class="hljs-built_in">this</span>.cb = cb;<br>    <span class="hljs-built_in">this</span>.getter = parsePath(expOrFn)<br>    <span class="hljs-built_in">this</span>.value = <span class="hljs-built_in">this</span>.get()<br>  &#125;<br>  get () &#123;<br>    <span class="hljs-built_in">window</span>.target = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">this</span>.vm<br>    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.getter.call(vm, vm)<br>    <span class="hljs-built_in">window</span>.target = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-keyword">return</span> value<br>  &#125;<br>  update () &#123;<br>    <span class="hljs-keyword">const</span> oldValue = <span class="hljs-built_in">this</span>.value<br>    <span class="hljs-built_in">this</span>.value = <span class="hljs-built_in">this</span>.get()<br>    <span class="hljs-built_in">this</span>.cb.call(<span class="hljs-built_in">this</span>.vm, <span class="hljs-built_in">this</span>.value, oldValue)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Parse simple path.</span><br><span class="hljs-comment"> * 把一个形如&#x27;data.a.b.c&#x27;的字符串路径所表示的值，从真实的data对象中取出来</span><br><span class="hljs-comment"> * 例如：</span><br><span class="hljs-comment"> * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125;</span><br><span class="hljs-comment"> * parsePath(&#x27;a.b.c&#x27;)(data)  // 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> bailRE = <span class="hljs-regexp">/[^\w.$]/</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parsePath</span> (<span class="hljs-params">path</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (bailRE.test(path)) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> segments = path.split(<span class="hljs-string">&#x27;.&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; segments.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span><br>      obj = obj[segments[i]]<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>当实例化<code>Watcher</code>类时，会先执行其构造函数；</li>
<li>在构造函数中调用了<code>this.get()</code>实例方法；</li>
<li>在<code>get()</code>方法中，首先通过<code>window.target = this</code>把实例自身赋给了全局的一个唯一对象<code>window.target</code>上，然后通过<code>let value = this.getter.call(vm, vm)</code>获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的<code>getter</code>，上文我们说过，在<code>getter</code>里会调用<code>dep.depend()</code>收集依赖，而在<code>dep.depend()</code>中取到挂载<code>window.target</code>上的值并将其存入依赖数组中，在<code>get()</code>方法最后将<code>window.target</code>释放掉。</li>
<li>而当数据变化时，会触发数据的<code>setter</code>，在<code>setter</code>中调用了<code>dep.notify()</code>方法，在<code>dep.notify()</code>方法中，遍历所有依赖(即watcher实例)，执行依赖的<code>update()</code>方法，也就是<code>Watcher</code>类中的<code>update()</code>实例方法，在<code>update()</code>方法中调用数据变化的更新回调函数，从而更新视图。</li>
</ol>
<p>简单总结一下就是：<code>Watcher</code>先把自己设置到全局唯一的指定位置（<code>window.target</code>），然后读取数据。因为读取了数据，所以会触发这个数据的<code>getter</code>。接着，在<code>getter</code>中就会从全局唯一的那个位置读取当前正在读取数据的<code>Watcher</code>，并把这个<code>watcher</code>收集到<code>Dep</code>中去。收集好之后，当数据发生变化时，会向<code>Dep</code>中的每个<code>Watcher</code>发送通知。通过这样的方式，<code>Watcher</code>可以主动去订阅任意一个数据的变化。</p>
<h6 id="不足："><a href="#不足：" class="headerlink" title="不足："></a>不足：</h6><p>虽然我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，但是这个方法仅仅只能观测到<code>object</code>数据的取值及设置值，当我们向<code>object</code>数据里添加一对新的<code>key/value</code>或删除一对已有的<code>key/value</code>时，它是无法观测到的，导致当我们对<code>object</code>数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。</p>
<p>当然，<code>Vue</code>也注意到了这一点，为了解决这一问题，<code>Vue</code>增加了两个全局API:<code>Vue.set</code>和<code>Vue.delete</code>，这两个API的实现原理将会在后面学习全局API的时候说到</p>
<h6 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h6><p>首先，我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，并且封装了<code>Observer</code>类，让我们能够方便的把<code>object</code>数据中的所有属性（包括子属性）都转换成<code>getter/seter</code>的形式来侦测变化。</p>
<p>接着，我们学习了什么是依赖收集？并且知道了在<code>getter</code>中收集依赖，在<code>setter</code>中通知依赖更新，以及封装了依赖管理器<code>Dep</code>，用于存储收集到的依赖。</p>
<p>最后，我们为每一个依赖都创建了一个<code>Watcher</code>实例，当数据发生变化时，通知<code>Watcher</code>实例，由<code>Watcher</code>实例去做真实的更新操作。</p>
<p>其整个流程大致如下：</p>
<ol>
<li><code>Data</code>通过<code>observer</code>转换成了<code>getter/setter</code>的形式来追踪变化。</li>
<li>当外界通过<code>Watcher</code>读取数据时，会触发<code>getter</code>从而将<code>Watcher</code>添加到依赖中。</li>
<li>当数据发生了变化时，会触发<code>setter</code>，从而向<code>Dep</code>中的依赖（即Watcher）发送通知。</li>
<li><code>Watcher</code>接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</li>
</ol>
<h5 id="Array的变化侦测"><a href="#Array的变化侦测" class="headerlink" title="Array的变化侦测"></a>Array的变化侦测</h5><p>上一篇文章中我们介绍了<code>Object</code>数据的变化侦测方式，本篇文章我们来看一下对<code>Array</code>型数据的变化<code>Vue</code>是如何进行侦测的。</p>
<p>为什么<code>Object</code>数据和<code>Array</code>型数据会有两种不同的变化侦测方式？</p>
<p>这是因为对于<code>Object</code>数据我们使用的是<code>JS</code>提供的对象原型上的方法<code>Object.defineProperty</code>，而这个方法是对象原型上的，所以<code>Array</code>无法使用这个方法，所以我们需要对<code>Array</code>型数据设计一套另外的变化侦测机制。</p>
<p>万变不离其宗，虽然对<code>Array</code>型数据设计了新的变化侦测机制，但是其根本思路还是不变的。那就是：还是在获取数据时收集依赖，数据变化时通知依赖更新。</p>
<p>下面我们就通过源码来看看<code>Vue</code>对<code>Array</code>型数据到底是如何进行变化侦测的。</p>
<p>大同小异思路同object一样还是先把用到<code>Array</code>型数据的地方作为依赖收集起来。</p>
<p>那么如何收集呢？？？</p>
<p>其实<code>Array</code>型数据的依赖收集方式和<code>Object</code>数据的依赖收集方式相同，都是在<code>getter</code>中收集。那么问题就来了，不是说<code>Array</code>无法使用<code>Object.defineProperty</code>方法吗？无法使用怎么还在<code>getter</code>中收集依赖呢？</p>
<p>那么我们回想一下平常在开发的时候，在组件的<code>data</code>中是不是都这么写的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">data()&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    arr:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>arr</code>这个数据始终都存在于一个<code>object</code>数据对象中，而且我们也说了，谁用到了数据谁就是依赖，那么要用到<code>arr</code>这个数据，是不是得先从<code>object</code>数据对象中获取一下<code>arr</code>数据，而从<code>object</code>数据对象中获取<code>arr</code>数据自然就会触发<code>arr</code>的<code>getter</code>，所以我们就可以在<code>getter</code>中收集依赖。</p>
<p>总结一句话就是：<strong>Array型数据还是在getter中收集依赖。</strong></p>
<p>如何使Array数据成为可观测性呢？？？</p>
<p><code>Object</code>数据变化侦测的时候，我们先让<code>Object</code>数据变的可观测，即我们能够知道数据什么时候被读取了、什么时候发生变化了。同理，对于<code>Array</code>型数据我们也得让它变的可观测，目前我们已经完成了一半可观测，即我们只知道了<code>Array</code>型数据何时被读取了，而何时发生变化我们无法知道，那么接下来我们就来解决这一问题：当<code>Array</code>型数据发生变化时我们如何得知？</p>
<p>分析：</p>
<p><code>Object</code>的变化时通过<code>setter</code>来追踪的，只有某个数据发生了变化，就一定会触发这个数据上的<code>setter</code>。但是<code>Array</code>型数据没有<code>setter</code>，怎么办？</p>
<p>我们试想一下，要想让<code>Array</code>型数据发生变化，那必然是操作了<code>Array</code>，而<code>JS</code>中提供的操作数组的方法就那么几种，我们可以把这些方法都重写一遍，在不改变原有功能的前提下，我们为其新增一些其他功能，例如下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>        arr.push(<span class="hljs-number">4</span>)<br>        <span class="hljs-built_in">Array</span>.prototype.newPush=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;arr 被修改了&#x27;</span>)<br>            <span class="hljs-built_in">this</span>.push(val)<br>        &#125;<br>        arr.newPush(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure>

<p><img   class="lazyload" data-original="C:\Users\梁超\AppData\Roaming\Typora\typora-user-images\image-20210422103153864.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="image-20210422103153864"></p>
<p>在上面这个例子中，我们针对数组的原生<code>push</code>方法定义个一个新的<code>newPush</code>方法，这个<code>newPush</code>方法内部调用了原生<code>push</code>方法，这样就保证了新的<code>newPush</code>方法跟原生<code>push</code>方法具有相同的功能，而且我们还可以在新的<code>newPush</code>方法内部干一些别的事情，比如通知变化。</p>
<p>是不是很巧妙？<code>Vue</code>内部就是这么干的。</p>
<p>数组方法拦截器：</p>
<p>在<code>Vue</code>中创建了一个数组方法拦截器，它拦截在数组实例与<code>Array.prototype</code>之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用<code>Array.prototype</code>上的原生方法。</p>
<p>经过整理，<code>Array</code>原型中可以改变数组自身内容的方法有7个，分别是：<code>push</code>,<code>pop</code>,<code>shift</code>,<code>unshift</code>,<code>splice</code>,<code>sort</code>,<code>reverse</code>。那么源码中的拦截器代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arrayProto = <span class="hljs-built_in">Array</span>.prototype<br><span class="hljs-comment">// 创建一个对象作为拦截器</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arrayMethods = <span class="hljs-built_in">Object</span>.create(arrayProto)<br><br><span class="hljs-comment">// 改变数组自身内容的7个方法</span><br><span class="hljs-keyword">const</span> methodsToPatch = [<br>  <span class="hljs-string">&#x27;push&#x27;</span>,<br>  <span class="hljs-string">&#x27;pop&#x27;</span>,<br>  <span class="hljs-string">&#x27;shift&#x27;</span>,<br>  <span class="hljs-string">&#x27;unshift&#x27;</span>,<br>  <span class="hljs-string">&#x27;splice&#x27;</span>,<br>  <span class="hljs-string">&#x27;sort&#x27;</span>,<br>  <span class="hljs-string">&#x27;reverse&#x27;</span><br>]<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Intercept mutating methods and emit events</span><br><span class="hljs-comment"> */</span><br>methodsToPatch.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> original = arrayProto[method]      <span class="hljs-comment">// 缓存原生方法</span><br>  <span class="hljs-built_in">Object</span>.defineProperty(arrayMethods, method, &#123;<br>    enumerable: <span class="hljs-literal">false</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    writable: <span class="hljs-literal">true</span>,<br>    value:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutator</span>(<span class="hljs-params">...args</span>)</span>&#123;<br>      <span class="hljs-keyword">const</span> result = original.apply(<span class="hljs-built_in">this</span>, args)<br>      <span class="hljs-keyword">return</span> result<br>    &#125;<br>  &#125;)<br>&#125;)<br><br></code></pre></td></tr></table></figure>

<p>在上面的代码中，首先创建了继承自<code>Array</code>原型的空对象<code>arrayMethods</code>，接着在<code>arrayMethods</code>上使用<code>object.defineProperty</code>方法将那些可以改变数组自身的7个方法遍历逐个进行封装。最后，当我们使用<code>push</code>方法的时候，其实用的是<code>arrayMethods.push</code>，而<code>arrayMethods.push</code>就是封装的新函数<code>mutator</code>，也就后说，实标上执行的是函数<code>mutator</code>，而<code>mutator</code>函数内部执行了<code>original</code>函数，这个<code>original</code>函数就是<code>Array.prototype</code>上对应的原生方法。 那么，接下来我们就可以在<code>mutato</code>r函数中做一些其他的事，比如说发送变化通知。</p>
<p>使用拦截器：</p>
<p>上一小节的图中，我们把拦截器做好还不够，还要把它挂载到数组实例与<code>Array.prototype</code>之间，这样拦截器才能够生效。</p>
<p>其实挂载不难，我们只需把数据的<code>__proto__</code>属性设置为拦截器<code>arrayMethods</code>即可，源码实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span> (value) &#123;<br>    <span class="hljs-built_in">this</span>.value = value<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>      <span class="hljs-keyword">const</span> augment = hasProto<br>        ? protoAugment<br>        : copyAugment<br>      augment(value, arrayMethods, arrayKeys)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">this</span>.walk(value)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> hasProto = <span class="hljs-string">&#x27;__proto__&#x27;</span> <span class="hljs-keyword">in</span> &#123;&#125;<br><br><span class="hljs-keyword">const</span> arrayKeys = <span class="hljs-built_in">Object</span>.getOwnPropertyNames(arrayMethods)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Augment an target Object or Array by intercepting</span><br><span class="hljs-comment"> * the prototype chain using __proto__</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">protoAugment</span> (<span class="hljs-params">target, src: Object, keys: any</span>) </span>&#123;<br>  target.__proto__ = src<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Augment an target Object or Array by defining</span><br><span class="hljs-comment"> * hidden properties.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* istanbul ignore next */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyAugment</span> (<span class="hljs-params">target: Object, src: Object, keys: Array&lt;string&gt;</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = keys.length; i &lt; l; i++) &#123;<br>    <span class="hljs-keyword">const</span> key = keys[i]<br>    def(target, key, src[key])<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上面代码中首先判断了浏览器是否支持<code>__proto__</code>，如果支持，则调用<code>protoAugment</code>函数把<code>value.__proto__ = arrayMethods</code>；如果不支持，则调用<code>copyAugment</code>函数把拦截器中重写的7个方法循环加入到<code>value</code>上。</p>
<p>拦截器生效以后，当数组数据再发生变化时，我们就可以在拦截器中通知变化了，也就是说现在我们就可以知道数组数据何时发生变化了，OK，以上我们就完成了对<code>Array</code>型数据的可观测。</p>
<p>收集依赖：</p>
<p>把依赖收集到哪里？？？</p>
<p>我们说了，数组数据的依赖也在<code>getter</code>中收集，而给数组数据添加<code>getter/setter</code>都是在<code>Observer</code>类中完成的，所以我们也应该在<code>Observer</code>类中收集依赖，源码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span> (value) &#123;<br>    <span class="hljs-built_in">this</span>.value = value<br>    <span class="hljs-built_in">this</span>.dep = <span class="hljs-keyword">new</span> Dep()    <span class="hljs-comment">// 实例化一个依赖管理器，用来收集数组依赖</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>      <span class="hljs-keyword">const</span> augment = hasProto<br>        ? protoAugment<br>        : copyAugment<br>      augment(value, arrayMethods, arrayKeys)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">this</span>.walk(value)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码中，在<code>Observer</code>类中实例化了一个依赖管理器，用来收集数组依赖</p>
<p>如何收集依赖？？？</p>
<p>，数组的依赖也在<code>getter</code>中收集，那么在<code>getter</code>中到底该如何收集呢？这里有一个需要注意的点，那就是依赖管理器定义在<code>Observer</code>类中，而我们需要在<code>getter</code>中收集依赖，也就是说我们必须在<code>getter</code>中能够访问到<code>Observer</code>类中的依赖管理器，才能把依赖存进去。源码是这么做的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span> (<span class="hljs-params">obj,key,val</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> childOb = observe(val)<br>  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    get()&#123;<br>      <span class="hljs-keyword">if</span> (childOb) &#123;<br>        childOb.dep.depend()<br>      &#125;<br>      <span class="hljs-keyword">return</span> val;<br>    &#125;,<br>    set(newVal)&#123;<br>      <span class="hljs-keyword">if</span>(val === newVal)&#123;<br>        <span class="hljs-keyword">return</span><br>      &#125;<br>      val = newVal;<br>      dep.notify()   <span class="hljs-comment">// 在setter中通知依赖更新</span><br>    &#125;<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Attempt to create an observer instance for a value,</span><br><span class="hljs-comment"> * returns the new observer if successfully observed,</span><br><span class="hljs-comment"> * or the existing observer if the value already has one.</span><br><span class="hljs-comment"> * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。</span><br><span class="hljs-comment"> * 如果 Value 已经存在一个Observer实例，则直接返回它</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span> (<span class="hljs-params">value, asRootData</span>)</span>&#123;<br>  <span class="hljs-keyword">if</span> (!isObject(value) || value <span class="hljs-keyword">instanceof</span> VNode) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> ob<br>  <span class="hljs-keyword">if</span> (hasOwn(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="hljs-keyword">instanceof</span> Observer) &#123;<br>    ob = value.__ob__<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    ob = <span class="hljs-keyword">new</span> Observer(value)<br>  &#125;<br>  <span class="hljs-keyword">return</span> ob<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面代码中，我们首先通过<code>observe</code>函数为被获取的数据<code>arr</code>尝试创建一个<code>Observer</code>实例，在<code>observe</code>函数内部，先判断当前传入的数据上是否有<code>__ob__</code>属性，因为在上篇文章中说了，如果数据有<code>__ob__</code>属性，表示它已经被转化成响应式的了，如果没有则表示该数据还不是响应式的，那么就调用<code>new Observer(value)</code>将其转化成响应式的，并把数据对应的<code>Observer</code>实例返回。</p>
<p>而在<code>defineReactive</code>函数中，首先获取数据对应的<code>Observer</code>实例<code>childOb</code>，然后在<code>getter</code>中调用<code>Observer</code>实例上依赖管理器，从而将依赖收集起来。</p>
<p>到现在为止，依赖已经收集好了，并且也已经存放好了，那么我们该如何通知依赖呢？</p>
<p>其实不难，在前文说过，我们应该在拦截器里通知依赖，要想通知依赖，首先要能访问到依赖。要访问到依赖也不难，因为我们只要能访问到被转化成响应式的数据<code>value</code>即可，因为<code>vaule</code>上的<code>__ob__</code>就是其对应的<code>Observer</code>类实例，有了<code>Observer</code>类实例我们就能访问到它上面的依赖管理器，然后只需调用依赖管理器的<code>dep.notify()</code>方法，让它去通知依赖更新即可。源码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Intercept mutating methods and emit events</span><br><span class="hljs-comment"> */</span><br>methodsToPatch.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> original = arrayProto[method]<br>  def(arrayMethods, method, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutator</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> result = original.apply(<span class="hljs-built_in">this</span>, args)<br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-built_in">this</span>.__ob__<br>    <span class="hljs-comment">// notify change</span><br>    ob.dep.notify()<br>    <span class="hljs-keyword">return</span> result<br>  &#125;)<br>&#125;)<br><br></code></pre></td></tr></table></figure>

<p>上面代码中，由于我们的拦截器是挂载到数组数据的原型上的，所以拦截器中的<code>this</code>就是数据<code>value</code>，拿到<code>value</code>上的<code>Observer</code>类实例，从而你就可以调用<code>Observer</code>类实例上面依赖管理器的<code>dep.notify()</code>方法，以达到通知依赖的目的。</p>
<p>OK，以上就基本完成了<code>Array</code>数据的变化侦测。</p>
<h5 id="深度侦测："><a href="#深度侦测：" class="headerlink" title="深度侦测："></a>深度侦测：</h5><p>在前文所有讲的<code>Array</code>型数据的变化侦测都仅仅说的是数组自身变化的侦测，比如给数组新增一个元素或删除数组中一个元素，而在<code>Vue</code>中，不论是<code>Object</code>型数据还是<code>Array</code>型数据所实现的数据变化侦测都是深度侦测，所谓深度侦测就是不但要侦测数据自身的变化，还要侦测数据中所有子数据的变化。举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<br>  &#123;<br>    name:<span class="hljs-string">&#x27;NLRX&#x27;</span>，<br>    age:<span class="hljs-string">&#x27;18&#x27;</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure>

<p>数组中包含了一个对象，如果该对象的某个属性发生了变化也应该被侦测到，这就是深度侦测。</p>
<p>这个实现起来比较简单，源码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>  value: any;<br>  dep: Dep;<br><br>  <span class="hljs-keyword">constructor</span> (value: any) &#123;<br>    <span class="hljs-built_in">this</span>.value = value<br>    <span class="hljs-built_in">this</span>.dep = <span class="hljs-keyword">new</span> Dep()<br>    def(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>, <span class="hljs-built_in">this</span>)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>      <span class="hljs-keyword">const</span> augment = hasProto<br>        ? protoAugment<br>        : copyAugment<br>      augment(value, arrayMethods, arrayKeys)<br>      <span class="hljs-built_in">this</span>.observeArray(value)   <span class="hljs-comment">// 将数组中的所有元素都转化为可被侦测的响应式</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">this</span>.walk(value)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Observe a list of Array items.</span><br><span class="hljs-comment">   */</span><br>  observeArray (items: <span class="hljs-built_in">Array</span>&lt;any&gt;) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = items.length; i &lt; l; i++) &#123;<br>      observe(items[i])<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span> (<span class="hljs-params">value, asRootData</span>)</span>&#123;<br>  <span class="hljs-keyword">if</span> (!isObject(value) || value <span class="hljs-keyword">instanceof</span> VNode) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> ob<br>  <span class="hljs-keyword">if</span> (hasOwn(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="hljs-keyword">instanceof</span> Observer) &#123;<br>    ob = value.__ob__<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    ob = <span class="hljs-keyword">new</span> Observer(value)<br>  &#125;<br>  <span class="hljs-keyword">return</span> ob<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面代码中，对于<code>Array</code>型数据，调用了<code>observeArray()</code>方法，该方法内部会遍历数组中的每一个元素，然后通过调用<code>observe</code>函数将每一个元素都转化成可侦测的响应式数据。</p>
<p>而对应<code>object</code>数据，在上一篇文章中我们已经在<code>defineReactive</code>函数中进行了递归操作。</p>
<h5 id="数组新增元素的侦测"><a href="#数组新增元素的侦测" class="headerlink" title="数组新增元素的侦测"></a>数组新增元素的侦测</h5><p>对于数组中已有的元素我们已经可以将其全部转化成可侦测的响应式数据了，但是如果向数组里新增一个元素的话，我们也需要将新增的这个元素转化成可侦测的响应式数据。</p>
<p>这个实现起来也很容易，我们只需拿到新增的这个元素，然后调用<code>observe</code>函数将其转化即可。我们知道，可以向数组内新增元素的方法有3个，分别是：<code>push</code>、<code>unshift</code>、<code>splice</code>。我们只需对这3中方法分别处理，拿到新增的元素，再将其转化即可。源码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">methodsToPatch.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>&#123;<br>  <span class="hljs-comment">// cache original method</span><br>  <span class="hljs-keyword">const</span> original = arrayProto[method]<br>  def(arrayMethods, method, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutator</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> result = original.apply(<span class="hljs-built_in">this</span>, args)<br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-built_in">this</span>.__ob__<br>    <span class="hljs-keyword">let</span> inserted<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;push&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;unshift&#x27;</span>:<br>        inserted = args   <span class="hljs-comment">// 如果是push或unshift方法，那么传入参数就是新增的元素</span><br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;splice&#x27;</span>:<br>        inserted = args.slice(<span class="hljs-number">2</span>) <span class="hljs-comment">// 如果是splice方法，那么传入参数列表中下标为2的就是新增的元素</span><br>        <span class="hljs-keyword">break</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (inserted) ob.observeArray(inserted) <span class="hljs-comment">// 调用observe函数将新增的元素转化成响应式</span><br>    <span class="hljs-comment">// notify change</span><br>    ob.dep.notify()<br>    <span class="hljs-keyword">return</span> result<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>不足：</p>
<p>前文中我们说过，对于数组变化侦测是通过拦截器实现的，也就是说只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是别忘了，我们在日常开发中，还可以通过数组的下标来操作数据，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;       <span class="hljs-comment">// 通过数组下标修改数组中的数据</span><br>arr.length = <span class="hljs-number">0</span>    <span class="hljs-comment">// 通过修改数组长度清空数组</span><br></code></pre></td></tr></table></figure>

<p>而使用上述例子中的操作方式来修改数组是无法侦测到的。 同样，<code>Vue</code>也注意到了这个问题， 为了解决这一问题，<code>Vue</code>增加了两个全局API:<code>Vue.set</code>和<code>Vue.delete</code>，这两个API的实现原理将会在后面学习全局API的时候说到</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>在本篇文章中，首先我们分析了对于<code>Array</code>型数据也在<code>getter</code>中进行依赖收集；其次我们发现，当数组数据被访问时我们轻而易举可以知道，但是被修改时我们却很难知道，为了解决这一问题，我们创建了数组方法拦截器，从而成功的将数组数据变的可观测。接着我们对数组的依赖收集及数据变化如何通知依赖进行了深入分析；最后我们发现<code>Vue</code>不但对数组自身进行了变化侦测，还对数组中的每一个元素以及新增的元素都进行了变化侦测，我们也分析了其实现原理。</p>
<p>以上就是对<code>Array</code>型数据的变化侦测分析。</p>
<p>撸码一时爽，一直撸码一直爽！！！</p>

      </section>
      <section class="extra">
        
        <ul class="copyright">
  
  <li><strong>本文作者：</strong>lc</li>
  <li><strong>本文链接：</strong><a href="http://example.com/2021/03/18/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A31/index.html">http://example.com/2021/03/18/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A31/index.html</a></li>
  <li><strong>版权声明：</strong>本博客所有文章均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"
      rel="external nofollow" target="_blank"> BY-NC-SA </a>许可协议，转载请注明出处！</li>
  
</ul>
        
        
        <section class="donate">
  <div class="qrcode">
    <img   class="lazyload" data-original="https://pic.izhaoo.com/alipay.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3%E2%80%94%E2%80%94%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E7%AF%87/" rel="tag">vue源码理解——变化侦测篇</a></li></ul>

        
<nav class="nav">
  
    <a href="/2021/03/18/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A39/"><i class="iconfont iconleft"></i>vue源码理解——内置组件篇</a>
  
  
    <a href="/2021/03/18/%E6%B5%85%E6%9E%90webpack%E5%8E%9F%E7%90%86/">浅析webpack原理<i class="iconfont iconright"></i></a>
  
</nav>

      </section>
      
      <section class="comments">
  
  <div class="btn" id="comments-btn">查看评论</div>
  
  
</section>
      
    </section>
  </div>
</article>
  </div>
</main>
  <footer class="footer">
  <div class="footer-social">
    
    
    
    
    
    <a href="tencent://message/?Menu=yes&uin=2504971404 " target="_blank" onMouseOver="this.style.color= '#12B7F5'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconQQ "></i>
    </a>
    
    
    
    
    
    <a href="javascript:; " target="_blank" onMouseOver="this.style.color= '#09BB07'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconwechat-fill "></i>
    </a>
    
    
    
    
    
    <a href="https://www.instagram.com/izhaoo/ " target="_blank" onMouseOver="this.style.color= '#DA2E76'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconinstagram "></i>
    </a>
    
    
    
    
    
    <a href="https://github.com/izhaoo " target="_blank" onMouseOver="this.style.color= '#24292E'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  icongithub-fill "></i>
    </a>
    
    
    
    
    
    <a href="mailto:izhaoo@163.com " target="_blank" onMouseOver="this.style.color='#FFBE5B'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconmail"></i>
    </a>
    
  </div>
  <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  <div class="fab fab-daovoice">
    <i class="iconfont iconcomment"></i>
  </div>
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>


<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>






<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>






<script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>






<script src="/js/utils.js"></script>
<script src="/js/modules.js"></script>
<script src="/js/zui.js"></script>
<script src="/js/script.js"></script>





<script>
  (function (i, s, o, g, r, a, m) {
    i["DaoVoiceObject"] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o), m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    a.charset = "utf-8";
    m.parentNode.insertBefore(a, m)
  })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
    "//widget.daovoice.io/widget/0f81ff2f.js", "daovoice")
  daovoice('init', {
    app_id: "abcdefg"
  }, {
    launcher: {
      disableLauncherIcon: true,
    },
  });
  daovoice('update');
</script>



<script>
  (function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>


<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4c204d8bc027a0455b5fc642ac334ca8";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>










</html>