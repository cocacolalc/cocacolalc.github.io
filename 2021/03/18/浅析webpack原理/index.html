

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>浅析webpack原理 - cocacola</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />

  
  
  <meta name="description" content="现在随着前端开发的复杂度和规模越来越大，鹰不能抛开工程..."> 
  
  <meta name="author" content="lc"> 

  
    <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  
  
    <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  
  
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  
  
    <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_h1619vhl1nr.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css">

  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        loadingImage: '',
      },
      donate: {
        enable: true,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      motto: {
        api: '',
        default: '将喜欢的一切留在身边，这便是努力的意义。'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        alwaysShow: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: true
      }
    }
  </script>

  

  
<meta name="generator" content="Hexo 5.4.0"></head>
<body class="lock-screen">
  <div class="loading"></div>
  


<nav class="navbar">
  <div class="left"></div>
  <div class="center">浅析webpack原理</div>
  <div class="right">
    <i class="iconfont iconmenu j-navbar-menu"></i>
  </div>
</nav>

  <nav class="menu">
  <div class="menu-wrap">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content">
      
      
      
      
      <li class="menu-item"><a href="/ " class="underline"> 首页</a></li>
      
      
      
      
      <li class="menu-item"><a href="/galleries " class="underline"> 摄影</a></li>
      
      
      
      
      <li class="menu-item"><a href="/archives " class="underline"> 归档</a></li>
      
      
      
      
      <li class="menu-item"><a href="/tags " class="underline"> 标签</a></li>
      
      
      
      
      <li class="menu-item"><a href="/categories " class="underline"> 分类</a></li>
      
      
      
      
      <li class="menu-item"><a href="/about " class="underline"> 关于</a></li>
      
    </ul>
    <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  </div>
</nav>
  <main id="main">
  <div class="container" id="container">
    <article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1618335829737-2228915674e0.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">浅析webpack原理</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>March 18, 2021</span
        class="post-info-item">
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>12310</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <p>现在随着前端开发的复杂度和规模越来越大，鹰不能抛开工程化来独立开发，比如：react的jsx代码必须编译后才能在浏览器中使用，比如sass和less代码浏览器是不支持的。如果摒弃这些开发框架，开发效率会大幅下降。</p>
<p>在众多前端工程化工具中，webpack脱颖而出成为了当今最流行的前端构建工具。</p>
<h4 id="webpack的原理"><a href="#webpack的原理" class="headerlink" title="webpack的原理"></a>webpack的原理</h4><h5 id="1、核心概念"><a href="#1、核心概念" class="headerlink" title="1、核心概念"></a>1、核心概念</h5><p>（1）entry：一个可执行模块或者库的入口</p>
<p>（2）chunk：多个文件组成一个代码块，可以将可执行的模块和他所依赖的模块组成一个chunk，这是打包</p>
<p>（3）loader：文件转换器。比如：sass转成css</p>
<p>（4）plugin：扩展webpack功能的插件。在webpack构建的生命周期节点上加入扩展hook，添加功能。</p>
<h4 id="2、webpack构建流程（原理）"><a href="#2、webpack构建流程（原理）" class="headerlink" title="2、webpack构建流程（原理）"></a>2、webpack构建流程（原理）</h4><p>从启动构建到输出结果一系列过程：</p>
<p>（1）初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。</p>
<p>（2）开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。</p>
<p>（3）确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。</p>
<p>（4）编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</p>
<p>（5）完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry配置生成代码块chunk。</p>
<p>（6）输出完成：输出所有的chunk到文件系统。</p>
<p>注意：在构建生命周期中有一系列插件在做合适的时机做合适事情，比如UglifyPlugin会在loader转换递归完对结果使用UglifyJs压缩覆盖之前的结果。</p>
<p><strong>三、业务场景和对应解决方案</strong></p>
<p><strong>1、单页应用</strong></p>
<p>一个单页应用需要配置一个entry指明执行入口，<a target="_blank" rel="noopener" href="https://github.com/gwuhaolin/web-webpack-plugin">web-webpack-plugin</a>里的<code>WebPlugin</code>可以自动的完成这些工作：webpack会为entry生成一个包含这个入口的所有依赖文件的chunk，但是还需要一个html来加载chunk生成的js，如果还提取出css需要HTML文件中引入提取的css。</p>
<p>一个简单的webpack配置文件栗子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; WebPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;web-webpack-plugin&#x27;</span>);<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: &#123;<br>    app: <span class="hljs-string">&#x27;./src/doc/index.js&#x27;</span>,<br>    home: <span class="hljs-string">&#x27;./src/doc/home.js&#x27;</span><br>  &#125;,<br>  plugins: [<br>    <span class="hljs-comment">// 一个WebPlugin对应生成一个html文件</span><br>    <span class="hljs-keyword">new</span> WebPlugin(&#123;<br>      <span class="hljs-comment">//输出的html文件名称</span><br>      filename: <span class="hljs-string">&#x27;index.html&#x27;</span>,<br>      <span class="hljs-comment">//这个html依赖的`entry`</span><br>      requires: [<span class="hljs-string">&#x27;app&#x27;</span>,<span class="hljs-string">&#x27;home&#x27;</span>],<br>    &#125;),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>说明：require: [‘app’, ‘home’]指明这个html依赖哪些entry，entry生成的js和css会自动注入到html中。</p>
<p>还支持配置这些资源注入方式，支持如下属性：</p>
<p>（1）_dist只有在生产环境中才引入的资源；</p>
<p>（2）_dev只有在开发环境中才引入的资源；</p>
<p>（3）_inline把资源的内容潜入到html中；</p>
<p>（4）_ie只有IE浏览器才需要引入的资源。</p>
<p>这些属性可以通过在js里配置，看个简单例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> WebPlugin(&#123;<br>    filename: <span class="hljs-string">&#x27;index.html&#x27;</span>,<br>    requires: &#123;<br>         app:&#123;<br>              _dist:<span class="hljs-literal">true</span>,<br>              _inline:<span class="hljs-literal">false</span>,<br>         &#125;<br>    &#125;,<br>&#125;),<br></code></pre></td></tr></table></figure>

<p>这些属性还可以在模板中设置，使用模板好处就是可以灵活的控制资源的注入点。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">new WebPlugin(&#123;<br>      filename: &#x27;index.html&#x27;,<br>      template: &#x27;./template.html&#x27;,<br>&#125;),<br><br>//template模板<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-cn&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;app?_inline&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;ie-polyfill?_ie&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;react-body&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><code>WebPlugin</code>插件借鉴了<code>fis3</code>的思想，<strong>补足了webpack缺失的以HTML为入口的功能</strong>。想了解<code>WebPlugin</code>的更多功能，见<a target="_blank" rel="noopener" href="https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md#%E8%BE%93%E5%87%BAhtml%E6%96%87%E4%BB%B6-demo">文档</a>。</p>
<p><strong>2、一个项目管理多个单页面</strong></p>
<p>一个项目中会包含多个单页应用，虽然多个单页面应用可以合成一个，但是这样做会导致用户没有访问的部分也加载了，如果项目中有很多的单页应用。为每一个单页应用配置一个entry和WebPlugin？如果又新增，又要新增webpack配置，这样做麻烦，这时候有一个插件web-webpack-plugin里的AutoWebPlugin方法可以解决这些问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    plugins: [<br>        <span class="hljs-comment">// 所有页面的入口目录</span><br>        <span class="hljs-keyword">new</span> AutoWebPlugin(<span class="hljs-string">&#x27;./src/&#x27;</span>),<br>    ]<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>分析：1、<code>AutoWebPlugin</code>会把<code>./src/</code>目录下所有每个文件夹作为一个单页页面的入口，自动为所有的页面入口配置一个WebPlugin输出对应的html。</p>
<p>2、要新增一个页面就在<code>./src/</code>下新建一个文件夹包含这个单页应用所依赖的代码，<code>AutoWebPlugin</code>自动生成一个名叫文件夹名称的html文件。</p>
<p><strong>3、代码分隔优化</strong></p>
<p>一个好的代码分割对浏览器首屏效果提升很大。</p>
<p>最常见的react体系：</p>
<p><strong>（1）先抽出基础库</strong><code>react</code> <code>react-dom</code> <code>redux</code> <code>react-redux</code>到一个单独的文件而不是和其它文件放在一起打包为一个文件，这样做的好处是只要你不升级他们的版本这个文件永远不会被刷新。如果你把这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致文件hash值变化从而导致缓存失效浏览器重复下载这些包含基础库的代码。所以把<strong>基础库打包成一个文件</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// vender.js 文件抽离基础库到单独的一个文件里防止跟随业务代码被刷新</span><br><span class="hljs-comment">// 所有页面都依赖的第三方库</span><br><span class="hljs-comment">// react基础</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><span class="hljs-comment">// redux基础</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;<br><span class="hljs-comment">// webpack配置</span><br>&#123;<br>  entry: &#123;<br>    vendor: <span class="hljs-string">&#x27;./path/to/vendor.js&#x27;</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>（2）通过<a target="_blank" rel="noopener" href="https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin">CommonsChunkPlugin</a>可以提取出多个代码块都依赖的代码形成一个单独的<code>chunk</code>。在应用有多个页面的场景下提取出所有页面公共的代码减少单个页面的代码，在不同页面之间切换时所有页面公共的代码之前被加载过而不必重新加载。所以<strong>通过<a target="_blank" rel="noopener" href="https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin">CommonsChunkPlugin</a>可以提取出多个代码块都依赖的代码形成一个单独的<code>chunk。</code></strong></p>
<p><strong>4、构建服务端渲染</strong></p>
<p>服务端渲染的代码要运行在nodejs环境，和浏览器不同的是，服务端渲染代码需要采用commonjs规范同时不应该包含除js之外的文件比如css。</p>
<p>webpack配置如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  target: <span class="hljs-string">&#x27;node&#x27;</span>,<br>  entry: &#123;<br>    <span class="hljs-string">&#x27;server_render&#x27;</span>: <span class="hljs-string">&#x27;./src/server_render&#x27;</span>,<br>  &#125;,<br>  output: &#123;<br>    filename: <span class="hljs-string">&#x27;./dist/server/[name].js&#x27;</span>,<br>    libraryTarget: <span class="hljs-string">&#x27;commonjs2&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>      &#125;,<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(scss|css|pdf)$/</span>,<br>        loader: <span class="hljs-string">&#x27;ignore-loader&#x27;</span>,<br>      &#125;,<br>    ]<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>分析一下：</p>
<p>（1）target: ‘node’指明构建出代码要运行在node环境中。</p>
<p>（2）libraryTarget: ‘commonjs2’ 指明输出的代码要是commonjs规范。</p>
<p>（3）{test: /.(scss|css|pdf)$/,loader: ‘ignore-loader’} 是为了防止不能在node里执行服务端渲染也用不上的文件被打包进去。</p>
<p><strong>5、fis3迁移到webpack</strong></p>
<p>fis3和webpack有很多相似地方也有不同的地方，相似地方：都采用commonjs规范，不同地方：导入css这些非js资源的方式。</p>
<p>fis3通过@require ‘./index.scss’，而webpack是通过require(‘./index.scss’)。</p>
<p>如果想把fis3平滑迁移到webpack，可以使用comment-require-loader。</p>
<p>比如：你想在webpack构建是使用采用了fis3方式的<code>imui</code>模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">loaders:[&#123;<br>     test: <span class="hljs-regexp">/\.js$/</span>,<br>     loaders: [<span class="hljs-string">&#x27;comment-require-loader&#x27;</span>],<br>     include: [path.resolve(__dirname, <span class="hljs-string">&#x27;node_modules/imui&#x27;</span>),]<br>&#125;]<br></code></pre></td></tr></table></figure>



<p><strong>四、自定义webpack扩展</strong></p>
<p>如果你在社区找不到你的应用场景的解决方案，那就需要自己动手了写loader或者plugin了。<br>在你编写自定义webpack扩展前你需要想明白到底是要做一个<code>loader</code>还是<code>plugin</code>呢？可以这样判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">如果你的扩展是想对一个个单独的文件进行转换那么就编写loader剩下的都是plugin。<br></code></pre></td></tr></table></figure>

<p>其中对文件进行转换可以是像：</p>
<p>1、babel-loader把es6转为es5；</p>
<p>2、file-loader把文件替换成对应的url；</p>
<p>3、raw-loader注入文本文件内容到代码中。</p>
<p><strong>1、编写webpack loader</strong></p>
<p>编写<code>loader</code>非常简单，以comment-require-loader为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">content</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> replace(content);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><code>loader</code>的入口需要导出一个函数，这个函数要干的事情就是转换一个文件的内容。<br>函数接收的参数<code>content</code>是一个文件在转换前的字符串形式内容，需要返回一个新的字符串形式内容作为转换后的结果，所有通过模块化倒入的文件都会经过<code>loader</code>。从这里可以看出<code>loader</code>只能处理一个个单独的文件而不能处理代码块。可以参考<a target="_blank" rel="noopener" href="https://webpack.js.org/concepts/loaders">官方文档</a></p>
<p><strong>2、编写webpack plugin</strong></p>
<p><code>plugin</code>应用场景广泛，所以稍微复杂点。以end-webpack-plugin为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EndWebpackPlugin</span> </span>&#123;<br><br>    <span class="hljs-keyword">constructor</span>(doneCallback, failCallback) &#123;<br>        <span class="hljs-built_in">this</span>.doneCallback = doneCallback;<br>        <span class="hljs-built_in">this</span>.failCallback = failCallback;<br>    &#125;<br><br>    apply(compiler) &#123;<br>        <span class="hljs-comment">// 监听webpack生命周期里的事件，做相应的处理</span><br>        compiler.plugin(<span class="hljs-string">&#x27;done&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stats</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">this</span>.doneCallback(stats);<br>        &#125;);<br>        compiler.plugin(<span class="hljs-string">&#x27;failed&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">this</span>.failCallback(err);<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = EndWebpackPlugin;<br></code></pre></td></tr></table></figure>

<p>loader的入口需要导出一个class，在new EndWebpackPlugin()的时候通过构造函数传入这个插件需要的参数，在webpack启动的时候会先实例化plugin，再调用plugin的apply方法，插件在apply函数里监听webpack生命周期里的事件，做相应的处理。</p>
<p>webpack plugin的两个核心概念：</p>
<p>（1）compiler：从webpack启动到退出只存在一个Compiler，compiler存放着webpack的配置。</p>
<p>（2）compilation：由于webpack的监听文件变化自动编译机制，compilation代表一次编译。</p>
<p><code>Compiler</code> 和 <code>Compilation</code> 都会广播一系列事件。webpack生命周期里有非常多的事件</p>
<p>以上只是一个最简单的demo，更复杂的可以查看 <a target="_blank" rel="noopener" href="https://github.com/webpack/docs/wiki/how-to-write-a-plugin">how to write a plugin</a>或参考<a target="_blank" rel="noopener" href="https://github.com/gwuhaolin/web-webpack-plugin">web-webpack-plugin</a>。</p>
<p><strong>五、总结</strong></p>
<p>webpack其实比较简单，用一句话概括本质：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">webpack是一个打包模块化js的工具，可以通过loader转换文件，通过plugin扩展功能。<br></code></pre></td></tr></table></figure>

<p>如果webpack让你感到复杂，一定是各种loader和plugin的原因。</p>
<p><strong>六、一些问题</strong></p>
<p><strong>1、webpack与grunt、gulp的不同？</strong></p>
<p>三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。</p>
<p>grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。</p>
<p>webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。</p>
<p>总结：（1）从构建思路来说：gulp和grunt需要开发者将整个前端构建过程拆分成多个<code>Task</code>，并合理控制所有<code>Task</code>的调用关系 webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工；</p>
<p>（2）对于知识背景：gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路。</p>
<p><strong>2、 与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？</strong></p>
<p>同样是基于入口的打包工具还有以下几个主流的：webpack，rollup，parcel。</p>
<p>从应用场景上来看：（1）webpack适合大型复杂的前端站点构建；（2）rollup适合基础库的打包，比如vue，react；（3）parcel适用于简单的实验室项目，但是打包出错很难调试。</p>
<p><strong>3、有哪些常见的Loader？他们是解决什么问题的？</strong></p>
<p>（1）babel-loader：把es6转成es5；</p>
<p>（2）css-loader：加载css，支持模块化，压缩，文件导入等特性；</p>
<p>（3）style-loader：把css代码注入到js中，通过dom操作去加载css；</p>
<p>（4）eslint-loader：通过Eslint检查js代码；</p>
<p>（5）image-loader：加载并且压缩图片晚间；</p>
<p>（6）file-loader：文件输出到一个文件夹中，在代码中通过相对url去引用输出的文件；</p>
<p>（7）url-loader：和file-loader类似，文件很小的时候可以base64方式吧文件内容注入到代码中。</p>
<p>（8）source-map-loader：加载额外的source map文件，方便调试。</p>
<p><strong>4、有哪些常见的Plugin？他们是解决什么问题的？</strong></p>
<p>（1）uglifyjs-webpack-plugin：通过UglifyJS去压缩js代码；</p>
<p>（2）commons-chunk-plugin：提取公共代码；</p>
<p>（3）define-plugin：定义环境变量。</p>
<p><strong>5、loader和plugin的不同</strong></p>
<p>作用不同：（1）loader让webpack有加载和解析非js的能力；（2）plugin可以扩展webpack功能，在webpack运行周期中会广播很多事件，Plugin可以监听一些事件，通过webpack的api改变结果。</p>
<p>用法不同：（1）loader在module.rule中配置。类型为数组，每一项都是Object；（2）plugin是单独配置的，类型为数组，每一项都是plugin实例，参数通过构造函数传入。</p>
<p><strong>6、webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全</strong></p>
<p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
<p>（1）初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</p>
<p>（2）开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</p>
<p>（3）确定入口：根据配置中的 entry 找出所有的入口文件；</p>
<p>（4）编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</p>
<p>（5）完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</p>
<p>（6）输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</p>
<p>（7）输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p>
<p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p>
<p><strong>7、是否写过Loader和Plugin？描述一下编写loader或plugin的思路？</strong></p>
<p>编写Loader时要遵循单一原则，每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。</p>
<p>Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>
<p><strong>8、webpack的热更新是如何做到的？说明其原理？</strong></p>
<p>webpack的热更新又称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到<strong>不用刷新浏览器而将新变更的模块替换掉旧的模块</strong>。</p>
<p>原理：</p>
<p><img   class="lazyload" data-original="https://www.mwcxs.top/static/upload/pics/2019/2/28FRQimjwzfPAJnjuwHaXYHTyO.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="img"></p>
<p>分析：</p>
<p>（1）第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</p>
<p>（2）第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。</p>
<p>（3）第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。</p>
<p>（4）第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在<strong>浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端</strong>，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。</p>
<p>（5）webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，<strong>webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新</strong>。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。</p>
<p>（6）HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。</p>
<p>（7）而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。</p>
<p>（8）最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。</p>
<p><strong>9、如何利用webpack来优化前端性能？（提高性能和体验）</strong></p>
<p>用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。</p>
<p>（1）压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css。使用webpack4，打包项目使用production模式，会自动开启代码压缩。</p>
<p>（2）利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径</p>
<p>（3）删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现或者使用<strong>es6模块开启删除死代码</strong>。</p>
<p>（4）优化图片，对于小图可以使用 base64 的方式写入文件中</p>
<p>（5）按照路由拆分代码，实现按需加载，提取公共代码。</p>
<p>（6）给打包出来的文件名添加哈希，实现浏览器缓存文件</p>
<p><strong>10、如何提高webpack的构建速度？</strong></p>
<p>（1）多入口的情况下，使用commonsChunkPlugin来提取公共代码；</p>
<p>（2）通过externals配置来提取常用库；</p>
<p>（3）使用happypack实现多线程加速编译；</p>
<p>（4）使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。原理上webpack-uglify-parallel采用多核并行压缩来提升压缩速度；</p>
<p>（5）使用tree-shaking和scope hoisting来剔除多余代码。</p>
<p><strong>11、怎么配置单页应用？怎么配置多页应用？</strong></p>
<p>单页应用可以理解为<strong>webpack的标准模式</strong>，直接在entry中指定单页应用的入口即可。</p>
<p>多页应用的话，可以使用webpack的 <strong>AutoWebPlugin来完成简单自动化的构建</strong>，但是前提是项目的目录结构必须遵守他预设的规范。</p>
<p><strong>12、npm打包时需要注意哪些？如何利用webpack来更好的构建？</strong></p>
<p>NPM模块需要注意以下问题：</p>
<p>（1）要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则</p>
<p>（2）Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以<strong>打包的最后结果应该是采用ES5编写的</strong>。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。</p>
<p>（3）Npm包大小应该是尽量小（有些仓库会限制包大小）</p>
<p>（4）<strong>发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装</strong>。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。</p>
<p>（5）UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。</p>
<p>基于以上需要注意的问题，我们可以对于webpack配置做以下扩展和优化：</p>
<p>（1）CommonJS模块化规范的解决方案： **设置output.libraryTarget=’commonjs2’**使输出的代码符合CommonJS2 模块化规范，以供给其它模块导入使用；</p>
<p>（2）输出ES5代码的解决方案：<strong>使用babel-loader把 ES6 代码转换成 ES5 的代码</strong>。再通过开启devtool: ‘source-map’输出SourceMap以发布调试。</p>
<p>（3）Npm包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是<strong>修改.babelrc文件，为其加入transform-runtime插件</strong></p>
<p>（4）不能将依赖模块打包到NPM模块中的解决方案：<strong>使用externals配置项来告诉webpack哪些模块不需要打包</strong>。</p>
<p>（5）对于依赖的资源文件打包的解决方案：通过css-loader和extract-text-webpack-plugin来实现，配置如下：</p>
<p><img   class="lazyload" data-original="https://www.mwcxs.top/static/upload/pics/2019/2/28IN5rUsvjZdD-j1y65yZ0zpOz.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="img"></p>
<p><strong>13、如何在vue项目中实现按需加载？</strong></p>
<p>经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。</p>
<p>不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，<strong>在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了</strong>。</p>
<p><img   class="lazyload" data-original="https://www.mwcxs.top/static/upload/pics/2019/2/28ay2qKVM8pK9YUkX9Ccm7GT8U.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="img"></p>
<p>单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。</p>

      </section>
      <section class="extra">
        
        <ul class="copyright">
  
  <li><strong>本文作者：</strong>lc</li>
  <li><strong>本文链接：</strong><a href="http://example.com/2021/03/18/%E6%B5%85%E6%9E%90webpack%E5%8E%9F%E7%90%86/index.html">http://example.com/2021/03/18/%E6%B5%85%E6%9E%90webpack%E5%8E%9F%E7%90%86/index.html</a></li>
  <li><strong>版权声明：</strong>本博客所有文章均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"
      rel="external nofollow" target="_blank"> BY-NC-SA </a>许可协议，转载请注明出处！</li>
  
</ul>
        
        
        <section class="donate">
  <div class="qrcode">
    <img   class="lazyload" data-original="https://pic.izhaoo.com/alipay.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%85%E6%9E%90webpack%E5%8E%9F%E7%90%86/" rel="tag">浅析webpack原理</a></li></ul>

        
<nav class="nav">
  
    <a href="/2021/03/18/vue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A31/"><i class="iconfont iconleft"></i>vue源码理解——变化侦测篇</a>
  
  
    <a href="/2021/03/18/recat/">React<i class="iconfont iconright"></i></a>
  
</nav>

      </section>
      
      <section class="comments">
  
  <div class="btn" id="comments-btn">查看评论</div>
  
  
</section>
      
    </section>
  </div>
</article>
  </div>
</main>
  <footer class="footer">
  <div class="footer-social">
    
    
    
    
    
    <a href="tencent://message/?Menu=yes&uin=2504971404 " target="_blank" onMouseOver="this.style.color= '#12B7F5'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconQQ "></i>
    </a>
    
    
    
    
    
    <a href="javascript:; " target="_blank" onMouseOver="this.style.color= '#09BB07'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconwechat-fill "></i>
    </a>
    
    
    
    
    
    <a href="https://www.instagram.com/izhaoo/ " target="_blank" onMouseOver="this.style.color= '#DA2E76'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconinstagram "></i>
    </a>
    
    
    
    
    
    <a href="https://github.com/izhaoo " target="_blank" onMouseOver="this.style.color= '#24292E'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  icongithub-fill "></i>
    </a>
    
    
    
    
    
    <a href="mailto:izhaoo@163.com " target="_blank" onMouseOver="this.style.color='#FFBE5B'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconmail"></i>
    </a>
    
  </div>
  <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  <div class="fab fab-daovoice">
    <i class="iconfont iconcomment"></i>
  </div>
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>


<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>






<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>






<script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>






<script src="/js/utils.js"></script>
<script src="/js/modules.js"></script>
<script src="/js/zui.js"></script>
<script src="/js/script.js"></script>





<script>
  (function (i, s, o, g, r, a, m) {
    i["DaoVoiceObject"] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o), m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    a.charset = "utf-8";
    m.parentNode.insertBefore(a, m)
  })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
    "//widget.daovoice.io/widget/0f81ff2f.js", "daovoice")
  daovoice('init', {
    app_id: "abcdefg"
  }, {
    launcher: {
      disableLauncherIcon: true,
    },
  });
  daovoice('update');
</script>



<script>
  (function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>


<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4c204d8bc027a0455b5fc642ac334ca8";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>










</html>