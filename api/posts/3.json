{"total":24,"pageSize":10,"pageCount":3,"data":[{"title":"Ts","slug":"typeScript","date":"2021-03-18T11:29:18.000Z","updated":"2021-04-30T08:04:12.659Z","comments":true,"top":null,"path":"api/articles/typeScript.json","excerpt":null,"keywords":null,"cover":"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==","content":"<h3 id=\"TypeScript开发\"><a href=\"#TypeScript开发\" class=\"headerlink\" title=\"TypeScript开发\"></a>TypeScript开发</h3><p>全局安装typescript，使用安装命令可以使用<code>npm</code>也可以使用<code>yarn</code>： </p>\n<p>命令：</p>\n<p>npm install typescript -g</p>\n<p>yarn global add typescript</p>\n<h5 id=\"demo-ts\"><a href=\"#demo-ts\" class=\"headerlink\" title=\"demo.ts\"></a>demo.ts</h5><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">jeskson</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br> <span class=\"hljs-keyword\">let</span> web: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&quot;hello world&quot;</span><br> <span class=\"hljs-built_in\">console</span>.log(web)<br>&#125;<br><br>jeskson()<br><br><span class=\"hljs-comment\">// tsc</span><br>tes demo.ts<br>node demo.js<br></code></pre></td></tr></table></figure>\n\n<p>npm install -g ts-node</p>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><ul>\n<li>TS的数据类型</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// ES6的数据类型：</span><br>基本数据类型：<span class=\"hljs-built_in\">Boolean</span>,<span class=\"hljs-built_in\">Number</span>,<span class=\"hljs-built_in\">String</span>,<span class=\"hljs-built_in\">Symbol</span>,<span class=\"hljs-literal\">undefined</span>,<span class=\"hljs-literal\">null</span><br><br>引用类型：<span class=\"hljs-built_in\">Array</span>,<span class=\"hljs-built_in\">Function</span>,<span class=\"hljs-built_in\">Object</span><br><br><span class=\"hljs-comment\">// TS的数据类型，增加</span><br><span class=\"hljs-built_in\">any</span>(任意类型)  <span class=\"hljs-built_in\">void</span>(空类型)  <span class=\"hljs-built_in\">enum</span>（枚举类型）Tuple（元祖类型）<br></code></pre></td></tr></table></figure>\n\n<p>类型注解：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> hello : <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&#x27;Hello TypeScript&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>原始类型</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> bl: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span><br><span class=\"hljs-keyword\">let</span> num: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">123</span><br><span class=\"hljs-keyword\">let</span> str: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&quot;123&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>数组泛型</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> arrType: <span class=\"hljs-built_in\">Array</span>&lt;<span class=\"hljs-built_in\">number</span>&gt; = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>];<br><span class=\"hljs-keyword\">let</span> arrType1: <span class=\"hljs-built_in\">Array</span>&lt;<span class=\"hljs-built_in\">string</span>&gt; = [<span class=\"hljs-string\">&#x27;0&#x27;</span>, <span class=\"hljs-string\">&#x27;1&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>, <span class=\"hljs-string\">&#x27;3&#x27;</span>, <span class=\"hljs-string\">&#x27;5&#x27;</span>];<br><span class=\"hljs-keyword\">let</span> arrType2: <span class=\"hljs-built_in\">Array</span>&lt;<span class=\"hljs-built_in\">any</span>&gt; = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;1&#x27;</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;s&#x27;</span>, <span class=\"hljs-literal\">true</span>];<br></code></pre></td></tr></table></figure>\n\n<p>用接口表示数组</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Person&#123;<br>  name: <span class=\"hljs-built_in\">string</span>;<br>  age: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><span class=\"hljs-keyword\">interface</span> NumberArray &#123;<br>       [index:<span class=\"hljs-built_in\">number</span>]: Person;         <br>&#125;<br><span class=\"hljs-keyword\">let</span> arrType3: NumberArray = [&#123;name:<span class=\"hljs-string\">&#x27;张三&#x27;</span>，age: <span class=\"hljs-number\">20</span>&#125;]<br><span class=\"hljs-keyword\">let</span> arrType4：<span class=\"hljs-built_in\">Array</span>&lt;Person&gt; = [&#123;name:<span class=\"hljs-string\">&#x27;张三&#x27;</span>，age: <span class=\"hljs-number\">20</span>&#125;]<br><span class=\"hljs-keyword\">let</span> arrType5：Person[] = [&#123;name:<span class=\"hljs-string\">&#x27;张三&#x27;</span>，age: <span class=\"hljs-number\">20</span>&#125;]<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>类数组</p>\n</blockquote>\n<p>类数组（Array-like Object）不是数组类型:</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">let</span> args: <span class=\"hljs-built_in\">number</span>[] = <span class=\"hljs-built_in\">arguments</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// index.ts(2,7): error TS2322: Type &#x27;IArguments&#x27; is not assignable to type &#x27;number[]&#x27;.</span><br><span class=\"hljs-comment\">//   Property &#x27;push&#x27; is missing in type &#x27;IArguments&#x27;.</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">let</span> args: IArguments = <span class=\"hljs-built_in\">arguments</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>元组类型</p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> tuple: [<span class=\"hljs-built_in\">number</span>, <span class=\"hljs-built_in\">string</span>] = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;1&#x27;</span>]<br><span class=\"hljs-comment\">// 此时,如果改变数组的元素类型或添加元素数量,编辑器都会报错</span><br><span class=\"hljs-comment\">// TS允许向元组中使用数组的push方法插入新元素(但不允许访问)</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>函数声明（Function Declaration）和函数表达式（Function Expression）</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 函数声明（Function Declaration）</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\">x, y</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> x + y;<br>&#125;<br><br><span class=\"hljs-comment\">// 函数表达式（Function Expression）</span><br><span class=\"hljs-keyword\">let</span> mySum = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> x + y;<br>&#125;;<br><span class=\"hljs-comment\">// 函数声明的类型定义</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span>(<span class=\"hljs-params\">x:<span class=\"hljs-built_in\">number</span>,y:<span class=\"hljs-built_in\">number</span></span>):<span class=\"hljs-title\">number</span></span>&#123;<br>       <span class=\"hljs-keyword\">return</span> x+y  <br>&#125;<br><span class=\"hljs-comment\">// 输入多余的或者少于要求的参数，是不被允许的</span><br><br><span class=\"hljs-comment\">// 函数表达式</span><br><span class=\"hljs-keyword\">let</span> mySun = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x:<span class=\"hljs-built_in\">number</span>,y:<span class=\"hljs-built_in\">number</span></span>):<span class=\"hljs-title\">number</span></span>&#123;<br>      <span class=\"hljs-keyword\">return</span> x + y  <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>用接口定义函数的形状</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> SearchFunc&#123;<br>       （source:<span class=\"hljs-built_in\">string</span>,subString:<span class=\"hljs-built_in\">string</span>）:<span class=\"hljs-built_in\">boolean</span><br>&#125;    <br><br><span class=\"hljs-keyword\">let</span> mySearch:SearchFunc;<br>mySearch = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">source: <span class=\"hljs-built_in\">string</span>,subString:<span class=\"hljs-built_in\">string</span></span>)</span>&#123;<br>     <span class=\"hljs-keyword\">return</span> source.search(subString) !== <span class=\"hljs-number\">-1</span>  <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">buildName</span>(<span class=\"hljs-params\">firstName: <span class=\"hljs-built_in\">string</span>, lastName?: <span class=\"hljs-built_in\">string</span></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (lastName) &#123;<br>        <span class=\"hljs-keyword\">return</span> firstName + <span class=\"hljs-string\">&#x27; &#x27;</span> + lastName;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> firstName;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">let</span> tomcat = buildName(<span class=\"hljs-string\">&#x27;dada&#x27;</span>, <span class=\"hljs-string\">&#x27;Cat&#x27;</span>);<br><span class=\"hljs-keyword\">let</span> tom = buildName(<span class=\"hljs-string\">&#x27;dada&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>参数默认值</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">buildName</span>(<span class=\"hljs-params\">firstName:<span class=\"hljs-built_in\">string</span>,lastName:<span class=\"hljs-built_in\">string</span>=&#x27;Cat&#x27;</span>)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> firstName + <span class=\"hljs-string\">&#x27; &#x27;</span> + lastName;<br>&#125;<br><span class=\"hljs-keyword\">let</span> tomcat = buildName(<span class=\"hljs-string\">&#x27;dada&#x27;</span>, <span class=\"hljs-string\">&#x27;Cat&#x27;</span>);<br><span class=\"hljs-keyword\">let</span> tom = buildName(<span class=\"hljs-string\">&#x27;dada&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>剩余参数</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 可以使用 ...rest 的方式获取函数中的剩余参数</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">push</span>(<span class=\"hljs-params\">array,...items</span>)</span>&#123;<br>     items.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">item</span>)</span>&#123;<br>        array.push(item)<br>  &#125;)  <br>&#125;<br><br><span class=\"hljs-keyword\">let</span> a = [];<br>push(a,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>)<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">push</span>(<span class=\"hljs-params\">array:<span class=\"hljs-built_in\">any</span>[],...items:<span class=\"hljs-built_in\">any</span>[]</span>)</span>&#123;<br>     items.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">item</span>)</span>&#123;<br>         array.push(item);<br>    &#125;)  <br>&#125;<br><br><span class=\"hljs-keyword\">let</span> a = []<br>push(a,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"重载\"><a href=\"#重载\" class=\"headerlink\" title=\"重载\"></a>重载</h3><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reverse</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">number</span> | <span class=\"hljs-title\">string</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">&#x27;number&#x27;</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Number</span>(x.toString().split(<span class=\"hljs-string\">&#x27;&#x27;</span>).reverse().join(<span class=\"hljs-string\">&#x27;&#x27;</span>));<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">&#x27;string&#x27;</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> x.split(<span class=\"hljs-string\">&#x27;&#x27;</span>).reverse().join(<span class=\"hljs-string\">&#x27;&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>使用重载定义多个 <code>reverse</code> 的函数类型：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reverse</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reverse</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">string</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reverse</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">number</span> | <span class=\"hljs-title\">string</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">&#x27;number&#x27;</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Number</span>(x.toString().split(<span class=\"hljs-string\">&#x27;&#x27;</span>).reverse().join(<span class=\"hljs-string\">&#x27;&#x27;</span>));<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">&#x27;string&#x27;</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> x.split(<span class=\"hljs-string\">&#x27;&#x27;</span>).reverse().join(<span class=\"hljs-string\">&#x27;&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"静态类型\"><a href=\"#静态类型\" class=\"headerlink\" title=\"静态类型\"></a>静态类型</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> count : <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">1</span>;<br><br><span class=\"hljs-keyword\">interface</span> dada &#123;<br> uname: <span class=\"hljs-built_in\">string</span>,<br> age: <span class=\"hljs-built_in\">number</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> jeskson :dada = &#123;<br> uname: <span class=\"hljs-string\">&#x27;jeskson&#x27;</span>,<br> age: <span class=\"hljs-number\">12</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>对象类型：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> gege: &#123;<br> name: <span class=\"hljs-built_in\">string</span>,<br> age: <span class=\"hljs-built_in\">number</span><br>&#125; = &#123;<br> name: <span class=\"hljs-string\">&#x27;jeskson&#x27;</span>,<br> age: <span class=\"hljs-number\">12</span><br>&#125;<br><span class=\"hljs-keyword\">const</span> person : <span class=\"hljs-built_in\">string</span> [] = [<span class=\"hljs-string\">&#x27;dada&#x27;</span>, <span class=\"hljs-string\">&#x27;jeskson&#x27;</span>, <span class=\"hljs-string\">&#x27;掘金魔王哪吒&#x27;</span>]<br><span class=\"hljs-keyword\">class</span> Person&#123;&#125;<br><span class=\"hljs-keyword\">const</span> dada : Person = <span class=\"hljs-keyword\">new</span> Person()<br><br><span class=\"hljs-keyword\">const</span> dada :<span class=\"hljs-function\">()=&gt;</span><span class=\"hljs-built_in\">string</span> = <span class=\"hljs-function\">()=&gt;</span>&#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;jeskson&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>静态类型：对象类型，数组类型，类类型，函数类型</p>\n<h3 id=\"类型注解与类型推断\"><a href=\"#类型注解与类型推断\" class=\"headerlink\" title=\"类型注解与类型推断\"></a>类型注解与类型推断</h3><p>局部变量：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> count : <span class=\"hljs-built_in\">number</span>;<br>count=<span class=\"hljs-number\">12</span>;<br></code></pre></td></tr></table></figure>\n\n<p>如果ts能够自动分析判断变量类型，就不需要，否则就需要使用类型注解。</p>\n<blockquote>\n<p>函数参数和函数的返回类型的注解</p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getNum</span>(<span class=\"hljs-params\">a : <span class=\"hljs-built_in\">number</span>, two : <span class=\"hljs-built_in\">number</span></span>) : <span class=\"hljs-title\">number</span> </span>&#123;<br> <span class=\"hljs-keyword\">return</span> a + b<br>&#125;<br><span class=\"hljs-keyword\">const</span> total = getNum(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>never</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tsx\">function errorFunction() : never &#123;<br> throw new Error()<br> console.log(&#39;hello world&#39;)<br>&#125;<br><br>function forNever() : never &#123;<br> while(true) &#123;&#125;<br> console.log(&#39;hello world&#39;)<br>&#125;<br><br>function add(&#123;one,two&#125; : &#123;one : number,two : number&#125;) &#123;<br> return one + two<br>&#125;<br>const total &#x3D; add(&#123;one:1,two:2&#125;)<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>数组类型注解</p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> numberArr : <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]<br><br><span class=\"hljs-keyword\">const</span> stringArr : <span class=\"hljs-built_in\">string</span>[] = [<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>]<br><br><span class=\"hljs-keyword\">const</span> undefinedArr : <span class=\"hljs-literal\">undefined</span>[] = [<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-literal\">undefined</span>]<br><br><span class=\"hljs-keyword\">const</span> arr : (<span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span>)[] = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;string&#x27;</span>,<span class=\"hljs-number\">2</span>]<br><br><span class=\"hljs-keyword\">const</span> dada : &#123;name:<span class=\"hljs-built_in\">string</span>,age:<span class=\"hljs-built_in\">number</span>&#125;[] = [<br> &#123;name:<span class=\"hljs-string\">&#x27;jeskson&#x27;</span>,age:<span class=\"hljs-number\">12</span>&#125;,<br> &#123;name:<span class=\"hljs-string\">&#x27;魔王哪吒&#x27;</span>,age:<span class=\"hljs-number\">12</span>&#125;,<br>]<br><br><span class=\"hljs-comment\">// 类别别名</span><br><span class=\"hljs-comment\">// type alias</span><br><span class=\"hljs-keyword\">type</span> typeMy = &#123;name:<span class=\"hljs-built_in\">string</span>,age:<span class=\"hljs-built_in\">number</span>&#125;<br><br><span class=\"hljs-keyword\">const</span> dada : typeMy[] = [&#123;name:<span class=\"hljs-string\">&#x27;jeskson&#x27;</span>,age:<span class=\"hljs-number\">12</span>&#125;]<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><p>加强版：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> dada : (<span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>)[] = [<span class=\"hljs-string\">&#x27;魔王哪吒&#x27;</span>,<span class=\"hljs-string\">&#x27;jeskson&#x27;</span>,<span class=\"hljs-number\">12</span>]<br><br><span class=\"hljs-comment\">// 不常用-元组</span><br><span class=\"hljs-keyword\">const</span> dada1 : [<span class=\"hljs-built_in\">string</span>,<span class=\"hljs-built_in\">string</span>,<span class=\"hljs-built_in\">number</span>] = [<span class=\"hljs-string\">&quot;jeskson&quot;</span>,<span class=\"hljs-number\">12</span>,<span class=\"hljs-string\">&quot;dadaqianduan&quot;</span>]<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> dada &#123;<br> name: <span class=\"hljs-string\">&#x27;jeskson&#x27;</span>;<br> age: <span class=\"hljs-number\">12</span>;<br> work ?: <span class=\"hljs-built_in\">string</span>;<br> say():<span class=\"hljs-built_in\">string</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> obj <span class=\"hljs-keyword\">implements</span> dada &#123;<br> name=<span class=\"hljs-string\">&quot;dada&quot;</span><br> age=<span class=\"hljs-number\">12</span><br> work=<span class=\"hljs-string\">&quot;it&quot;</span><br> say()&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;dadaqianduan&quot;</span><br> &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> selected = <span class=\"hljs-function\">(<span class=\"hljs-params\">person: dada</span>)=&gt;</span>&#123;<br>&#125;<br><br><span class=\"hljs-comment\">// obj.name &amp;&amp; console.log(obj.name)</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">class</span> Da &#123;<br> content = <span class=\"hljs-string\">&quot;掘金魔王哪吒&quot;</span><br> sayHello() &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.content<br> &#125;<br>&#125;<br><br>consot da = <span class=\"hljs-keyword\">new</span> Da()<br><span class=\"hljs-built_in\">console</span>.log(da.sayHello())<br><span class=\"hljs-keyword\">class</span> Person &#123;<br> name: <span class=\"hljs-built_in\">string</span>;<br>&#125;<br><span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-keyword\">new</span> Person()<br>person.name = <span class=\"hljs-string\">&quot;jeskson&quot;</span><br><span class=\"hljs-built_in\">console</span>.log(person.name)<br></code></pre></td></tr></table></figure>\n\n<p>类的构造函数</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">class</span> Person &#123;<br> <span class=\"hljs-keyword\">public</span> name : <span class=\"hljs-built_in\">string</span>;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">string</span></span>)&#123;<br>  <span class=\"hljs-built_in\">this</span>.name = name<br> &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 优化</span><br><span class=\"hljs-keyword\">class</span> Person &#123;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">public</span> name:<span class=\"hljs-built_in\">string</span></span>)&#123;&#125;<br>&#125;<br><span class=\"hljs-keyword\">class</span> Teacher <span class=\"hljs-keyword\">extends</span> Person&#123;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">public</span> age:<span class=\"hljs-built_in\">number</span></span>)&#123;<br>  <span class=\"hljs-built_in\">super</span>(<span class=\"hljs-string\">&#x27;jeskson&#x27;</span>)<br> &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">&#x27;jeskson&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> dada = <span class=\"hljs-keyword\">new</span> Teacher(<span class=\"hljs-number\">12</span>)<br><span class=\"hljs-built_in\">console</span>.log(dada.age)<br><span class=\"hljs-built_in\">console</span>.log(person.name)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Getter-Setter-static\"><a href=\"#Getter-Setter-static\" class=\"headerlink\" title=\"Getter,Setter,static\"></a>Getter,Setter,static</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">class</span> Da &#123;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> _age:<span class=\"hljs-built_in\">number</span></span>)&#123;&#125;<br> get age() &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>._age<br> &#125;<br> set age(age:<span class=\"hljs-built_in\">number</span>) &#123;<br>  <span class=\"hljs-built_in\">this</span>._age = age<br> &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> dada = <span class=\"hljs-keyword\">new</span> Da(<span class=\"hljs-number\">12</span>)<br><span class=\"hljs-keyword\">class</span> Da&#123;<br> <span class=\"hljs-keyword\">static</span> sayHello() &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;魔王哪吒&quot;</span><br> &#125;<br>&#125;<br><span class=\"hljs-built_in\">console</span>.log(Da.sayHello())<br></code></pre></td></tr></table></figure>\n\n<p>只读属性：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">class</span> Person&#123;<br> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">readonly</span> _name:<span class=\"hljs-built_in\">string</span><br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">string</span></span>) &#123;<br>  <span class=\"hljs-built_in\">this</span>._name = name<br> &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">&#x27;jeskson&#x27;</span>);<br><span class=\"hljs-built_in\">console</span>.log(person.name);<br></code></pre></td></tr></table></figure>\n\n<p>抽象类，使用继承抽象类：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> Da &#123;<br> <span class=\"hljs-keyword\">abstract</span> say()<br>&#125;<br><span class=\"hljs-keyword\">class</span> da <span class=\"hljs-keyword\">extends</span> Da &#123;<br> say() &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;jeskson&#x27;</span>)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>tsc -init</code>生成<code>tsconfig.json</code>文件：</p>\n<p><code>compilerOptions</code>配置项</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-string\">&quot;files&quot;</span>: []<br><br>removeComments 为 <span class=\"hljs-literal\">true</span>，去掉注释<br>strict为<span class=\"hljs-literal\">true</span>，书写规范<br><br><span class=\"hljs-comment\">// 允许你的注解类型any不用特意标明</span><br><span class=\"hljs-string\">&quot;noImplicitAny&quot;</span>: <span class=\"hljs-literal\">true</span><br><br><span class=\"hljs-comment\">// 不允许有null值出现</span><br><span class=\"hljs-string\">&quot;strictNullChecks&quot;</span>: <span class=\"hljs-literal\">true</span><br><br><span class=\"hljs-comment\">// 入口文件</span><br><span class=\"hljs-string\">&quot;rootDir&quot;</span>: <span class=\"hljs-string\">&quot;./src&quot;</span><br><span class=\"hljs-comment\">// 编译好的文件</span><br><span class=\"hljs-string\">&quot;outDir&quot;</span>: <span class=\"hljs-string\">&quot;./build&quot;</span><br><br><span class=\"hljs-comment\">// Generates corresponding &#x27;.map&#x27; file</span><br><span class=\"hljs-comment\">// 信息文件，存储位置信息</span><br><span class=\"hljs-string\">&quot;sourceMap&quot;</span>: <span class=\"hljs-literal\">true</span><br><br><span class=\"hljs-comment\">// Report errors on unused locals</span><br><span class=\"hljs-string\">&quot;noUnusedLocals&quot;</span>: <span class=\"hljs-literal\">true</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"联合类型和类型保护\"><a href=\"#联合类型和类型保护\" class=\"headerlink\" title=\"联合类型和类型保护\"></a>联合类型和类型保护</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Teacher&#123;<br> teacher: <span class=\"hljs-built_in\">boolean</span>;<br> say:<span class=\"hljs-function\">()=&gt;</span>&#123;&#125;<br>&#125;<br><span class=\"hljs-keyword\">interface</span> Student&#123;<br> teacher: <span class=\"hljs-built_in\">boolean</span>;<br> say:<span class=\"hljs-function\">()=&gt;</span>&#123;&#125;<br>&#125;<br><br><span class=\"hljs-comment\">//联合类型，类型保护，类型断言</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">da</span>(<span class=\"hljs-params\">study: Teacher | Student</span>) </span>&#123;<br> <span class=\"hljs-keyword\">if</span>(study.teacher) &#123;<br>  (study <span class=\"hljs-keyword\">as</span> Teacher).say();<br> &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>  (study <span class=\"hljs-keyword\">as</span> Student).say();<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">params: <span class=\"hljs-built_in\">Array</span>&lt;T&gt;</span>)</span>&#123;<br> <span class=\"hljs-keyword\">return</span> params;<br>&#125;<br>fn&lt;<span class=\"hljs-built_in\">string</span>&gt;([<span class=\"hljs-string\">&quot;12&quot;</span>,<span class=\"hljs-string\">&quot;123&quot;</span>]);<br></code></pre></td></tr></table></figure>\n\n<p>使用：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">class</span> Select &#123;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> da: <span class=\"hljs-built_in\">string</span>[]</span>) &#123;&#125;<br> getDa(index:<span class=\"hljs-built_in\">number</span>):<span class=\"hljs-built_in\">string</span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.da[index];<br> &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> dada = <span class=\"hljs-keyword\">new</span> Select([<span class=\"hljs-string\">&quot;1&quot;</span>,<span class=\"hljs-string\">&quot;2&quot;</span>,<span class=\"hljs-string\">&quot;3&quot;</span>]);<br>onsole.log(dada.getDa(<span class=\"hljs-number\">1</span>));<br><span class=\"hljs-keyword\">class</span> Select&lt;T&gt; &#123;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> da: T[]</span>)&#123;&#125;<br> getDa(index: <span class=\"hljs-built_in\">number</span>): T&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.da[index];<br> &#125;<br>&#125;<br><span class=\"hljs-keyword\">interface</span> Girl &#123;<br> name: <span class=\"hljs-built_in\">string</span>;<br>&#125;<br><span class=\"hljs-keyword\">class</span> SelectGirl&lt;T <span class=\"hljs-keyword\">extends</span> Girl&gt; &#123;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> girls: T[]</span>) &#123;&#125;<br> getGirl(index: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">string</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.girls[index].name;<br> &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> SelectGirl&lt;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span>&gt; &#123;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> girls: T[]</span>) &#123;&#125;<br> getGirl(index: <span class=\"hljs-built_in\">number</span>): T &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.girls[index];<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"NameSpace\"><a href=\"#NameSpace\" class=\"headerlink\" title=\"NameSpace\"></a>NameSpace</h3><p><code>npm init -y</code>生成<code>package.json</code>文件</p>\n<p><code>tsc -init</code>生成<code>tsconfig.json</code>文件</p>\n<blockquote>\n<p>安装VsCode编辑器：</p>\n</blockquote>\n<p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"图片\">image.png</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Person &#123;<br> name: <span class=\"hljs-built_in\">string</span><br>&#125;<br><span class=\"hljs-keyword\">const</span> teacher: Person = &#123;<br> name: <span class=\"hljs-string\">&#x27;jeskson&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>基础类型和对象类型</p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 基础类型 null, undefined, symbol, boolean, void</span><br><span class=\"hljs-keyword\">const</span> count:<span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">12</span>;<br><span class=\"hljs-keyword\">const</span> name:<span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&#x27;掘金魔王哪吒&#x27;</span>;<br><br><span class=\"hljs-comment\">// 对象类型</span><br><span class=\"hljs-keyword\">const</span> teacher: &#123;<br> name: <span class=\"hljs-built_in\">string</span>;<br> age: <span class=\"hljs-built_in\">number</span>;<br>&#125; = &#123;<br> name: <span class=\"hljs-string\">&#x27;jeskson&#x27;</span>,<br> age: <span class=\"hljs-number\">12</span><br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> nums:<span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]<br><br><span class=\"hljs-keyword\">const</span> goTotal: <span class=\"hljs-function\">()=&gt;</span><span class=\"hljs-built_in\">number</span> = <span class=\"hljs-function\">() =&gt;</span> &#123;<br> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">123</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>类型注解和类型推断</p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// type annotation 类型注解</span><br><br><span class=\"hljs-keyword\">let</span> count:<span class=\"hljs-built_in\">number</span>;<br>count=<span class=\"hljs-number\">123</span>;<br><br><span class=\"hljs-comment\">// type inference 类型推断，TS会自动的尝试分析变量的类型</span><br><span class=\"hljs-comment\">// 推动不出来，就自己加</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getTotal</span>(<span class=\"hljs-params\">firstNumber:<span class=\"hljs-built_in\">number</span>, secondNumber:<span class=\"hljs-built_in\">number</span></span>) </span>&#123;<br> <span class=\"hljs-keyword\">return</span> firstNumber + secondNumber;<br>&#125;<br><span class=\"hljs-keyword\">const</span> total = getTotal(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>函数相关类型t</p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 实战</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getTotal</span>(<span class=\"hljs-params\">firstNumber:<span class=\"hljs-built_in\">number</span>, secondNumber:<span class=\"hljs-built_in\">number</span></span>):<span class=\"hljs-title\">number</span> </span>&#123;<br> <span class=\"hljs-keyword\">return</span> firstNumber + secondNumber;<br>&#125;<br><span class=\"hljs-keyword\">const</span> total = getTotal(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>);<br><br><span class=\"hljs-comment\">// void这个函数不应该有返回值</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sayHello</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">void</span> </span>&#123;<br> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// never 表示这个函数永远不能执行完成</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">errorEmitter</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">never</span> </span>&#123;<br> <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>)&#123;&#125; <span class=\"hljs-comment\">// 或抛出异常</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\">&#123;first,second&#125;:&#123;first:<span class=\"hljs-built_in\">number</span>;second:<span class=\"hljs-built_in\">number</span>&#125;</span>):<span class=\"hljs-title\">number</span></span>&#123;<br> <span class=\"hljs-keyword\">return</span> first+second;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getNumber</span>(<span class=\"hljs-params\">&#123;first&#125;:&#123;first:<span class=\"hljs-built_in\">number</span>&#125;</span>)</span>&#123;<br> <span class=\"hljs-keyword\">return</span> first;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>小结：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 基础类型 boolean,number,string,void,undefined,symbol,null</span><br><br><span class=\"hljs-keyword\">let</span> count: <span class=\"hljs-built_in\">number</span>;<br>count = <span class=\"hljs-number\">12</span>;<br><br><span class=\"hljs-comment\">// 对象类型 &#123;&#125;,Class,function,[]</span><br><span class=\"hljs-keyword\">const</span> fun = <span class=\"hljs-function\">(<span class=\"hljs-params\">str:<span class=\"hljs-built_in\">string</span></span>) =&gt;</span> &#123;<br> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">parseInt</span>(str,<span class=\"hljs-number\">10</span>);<br>&#125;<br><span class=\"hljs-keyword\">const</span> fun1: <span class=\"hljs-function\">(<span class=\"hljs-params\">str:<span class=\"hljs-built_in\">string</span></span>)=&gt;</span><span class=\"hljs-built_in\">number</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">str</span>) =&gt;</span> &#123;<br> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">parseInt</span>(str,<span class=\"hljs-number\">10</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> date = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>();<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>数组和元组</p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> arr: (<span class=\"hljs-built_in\">number</span>|<span class=\"hljs-built_in\">string</span>)[] = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;2&#x27;</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">const</span> stringArr: <span class=\"hljs-built_in\">string</span>[] = [<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>];<br><span class=\"hljs-keyword\">const</span> undefinedArr:<span class=\"hljs-literal\">undefined</span>[] = [<span class=\"hljs-literal\">undefined</span>];<br><br><span class=\"hljs-keyword\">const</span> objectArr: &#123;name:<span class=\"hljs-built_in\">string</span>,age:<span class=\"hljs-built_in\">number</span>&#125;[] = [&#123;<br> name: <span class=\"hljs-string\">&#x27;掘金魔王哪吒&#x27;</span>,<br> age: <span class=\"hljs-number\">12</span><br>&#125;]<br><br><span class=\"hljs-comment\">// type alias 类型别名</span><br><span class=\"hljs-keyword\">type</span> User = &#123;name:<span class=\"hljs-built_in\">string</span>;age:<span class=\"hljs-built_in\">number</span>&#125;;<br><span class=\"hljs-keyword\">const</span> objectArr: User[] = [&#123;<br> name: <span class=\"hljs-string\">&#x27;掘金魔王哪吒&#x27;</span>,<br> age: <span class=\"hljs-number\">12</span><br>&#125;]<br><br><span class=\"hljs-keyword\">class</span> Teacher &#123;<br> name: <span class=\"hljs-built_in\">string</span>;<br> age: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><span class=\"hljs-keyword\">const</span> objectArr: Teacher[] = [<br> <span class=\"hljs-keyword\">new</span> Teacher();<br> &#123;<br>  name: <span class=\"hljs-string\">&#x27;jeskson&#x27;</span>,<br>  age: <span class=\"hljs-number\">12</span><br> &#125;<br>];<br></code></pre></td></tr></table></figure>\n\n<p>元组</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> teacherInfo: [<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-built_in\">string</span>, <span class=\"hljs-built_in\">number</span>] = [<span class=\"hljs-string\">&#x27;dadaqianduan&#x27;</span>,<span class=\"hljs-string\">&#x27;1024bibi.com&#x27;</span>,<span class=\"hljs-number\">12</span>];<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Interface接口</p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Person &#123;<br> <span class=\"hljs-comment\">// readonly name: string;</span><br> name: <span class=\"hljs-built_in\">string</span>;<br> age?: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><span class=\"hljs-keyword\">const</span> getPersonName = (person: Person): <span class=\"hljs-function\"><span class=\"hljs-params\">void</span> =&gt;</span> &#123;<br> <span class=\"hljs-built_in\">console</span>.log(person.name);<br>&#125;;<br><span class=\"hljs-keyword\">const</span> setPersonName = (person: Person, name: <span class=\"hljs-built_in\">string</span>): <span class=\"hljs-function\"><span class=\"hljs-params\">void</span>=&gt;</span>&#123;<br> persono.name = name;<br>&#125;;<br><span class=\"hljs-keyword\">const</span> person = &#123;<br> name: <span class=\"hljs-string\">&#x27;掘金魔王哪吒&#x27;</span>,<br> age: <span class=\"hljs-number\">12</span><br>&#125;;<br>getPersonName(person);<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>类的定义与继承</p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">class</span> Person &#123;<br> name=<span class=\"hljs-string\">&#x27;掘金魔王哪吒&#x27;</span>;<br> getName() &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.name;<br> &#125;<br>&#125;<br><span class=\"hljs-keyword\">class</span> Teacher textends Person &#123;<br> getTeacherName() &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;teacher&#x27;</span>;<br> &#125;<br> getName() &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;1024bibi.com&#x27;</span> + <span class=\"hljs-built_in\">super</span>.getName()<br> &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> teacher = <span class=\"hljs-keyword\">new</span> Teacher();<br><span class=\"hljs-comment\">// 重写，字类可以重写父类的东西</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>类中的访问类型和构造器</p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// private protected public </span><br><span class=\"hljs-keyword\">class</span> Person &#123;<br> <span class=\"hljs-keyword\">public</span> name: <span class=\"hljs-built_in\">string</span>;<br> sayHi() &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;1024bibi.com&#x27;</span>)<br> &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-keyword\">new</span> Person();<br>person.name = <span class=\"hljs-string\">&#x27;掘金魔王哪吒&#x27;</span><br><span class=\"hljs-built_in\">console</span>.log(person.name);<br><br><span class=\"hljs-comment\">// public 允许我在类的内外被调用</span><br><span class=\"hljs-comment\">// private 允许在类内被使用</span><br><span class=\"hljs-comment\">// protected 允许在类内以及继承的子类中是使用</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>constructor</code></li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">class</span> Person &#123;<br> <span class=\"hljs-keyword\">public</span> name: <span class=\"hljs-built_in\">string</span>;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">string</span></span>) &#123;<br>  <span class=\"hljs-built_in\">this</span>.name = name;<br> &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">&#x27;dadaqianduan&#x27;</span>);<br><span class=\"hljs-built_in\">console</span>.log(person.name);<br><span class=\"hljs-comment\">// 简化写法</span><br><span class=\"hljs-keyword\">class</span> Person &#123;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">public</span> name: <span class=\"hljs-built_in\">string</span></span>) &#123;&#125;<br>&#125;<br><span class=\"hljs-keyword\">class</span> Teacher <span class=\"hljs-keyword\">extends</span> Person &#123;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">public</span> age:<span class=\"hljs-built_in\">number</span></span>) &#123;<br>  <span class=\"hljs-built_in\">super</span>(<span class=\"hljs-string\">&#x27;dadaqianduan&#x27;</span>);<br> &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 如果父类没有构造器，也使用空的 super()</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>静态属性，Setter和Getter</p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">class</span> Person &#123;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> name: <span class=\"hljs-built_in\">string</span></span>) &#123;&#125;<br> get getName() &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.name;<br> &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">&#x27;dadaqianduan&#x27;</span>);<br><span class=\"hljs-built_in\">console</span>.log(person.getName);<br><span class=\"hljs-keyword\">class</span> Person &#123;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> _name: <span class=\"hljs-built_in\">string</span></span>) &#123;&#125;<br> get name() &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>._name;<br> &#125;<br> set name(name: <span class=\"hljs-built_in\">string</span>) &#123;<br>  <span class=\"hljs-built_in\">this</span>._name = name;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>设计模式：单例模式，一个类只允许通过这个类，获取一个单例实例</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">class</span> Demo &#123;<br> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> instance: Demo;<br> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">public</span> name:<span class=\"hljs-built_in\">string</span></span>) &#123;&#125;<br> <br> <span class=\"hljs-keyword\">static</span> getInstance(name: <span class=\"hljs-built_in\">string</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-built_in\">this</span>.instance) &#123;<br>   <span class=\"hljs-built_in\">this</span>.instance = <span class=\"hljs-keyword\">new</span> Demo(<span class=\"hljs-string\">&#x27;1024bibi.com&#x27;</span>);<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.instance;<br> &#125;<br>&#125;<br><br><span class=\"hljs-comment\">//const demo1 = new Demo();</span><br><span class=\"hljs-comment\">//const demo2 = new Demo();</span><br><br><span class=\"hljs-keyword\">const</span> demo1 = Demo.getInstance();<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>抽象类</p>\n</blockquote>\n<p>抽象类只能被继承，不能被实例化</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> Da &#123;<br> width: <span class=\"hljs-built_in\">number</span>;<br> getType() &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;dadaqianduan&#x27;</span>;<br> &#125;<br> <span class=\"hljs-keyword\">abstract</span> getAra(): <span class=\"hljs-built_in\">number</span>;<br>&#125;<br>npm init -y<br></code></pre></td></tr></table></figure>\n\n<p>生成<code>package.json</code>文件：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\">&#123;<br> <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;TypeScript&quot;</span>,<br> <span class=\"hljs-string\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;1.0.0&quot;</span>,<br> <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;&quot;</span>,<br> <span class=\"hljs-string\">&quot;main&quot;</span>: <span class=\"hljs-string\">&quot;index.js&quot;</span>,<br> <span class=\"hljs-string\">&quot;scripts&quot;</span>: &#123;<br>  <span class=\"hljs-string\">&quot;test: &quot;</span>echo \\<span class=\"hljs-string\">&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span><br> &#125;,<br> <span class=\"hljs-string\">&quot;keywords&quot;</span>: [],<br> <span class=\"hljs-string\">&quot;author&quot;</span>: <span class=\"hljs-string\">&quot;&quot;</span>,<br> <span class=\"hljs-string\">&quot;license&quot;</span>: <span class=\"hljs-string\">&quot;ISC&quot;</span><br>&#125;<br>tsc --init<br><span class=\"hljs-comment\">// Successfully created a tsconfig.json file</span><br><br><span class=\"hljs-comment\">// npm uninstall ts-node -g</span><br>npm install -D ts-node<br>npm install typescript -D<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"TypeScript中的配置文件\"><a href=\"#TypeScript中的配置文件\" class=\"headerlink\" title=\"TypeScript中的配置文件\"></a>TypeScript中的配置文件</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 编译配置文件</span><br><span class=\"hljs-comment\">// tsconfig.json</span><br>要编译的文件<br><span class=\"hljs-string\">&quot;include&quot;</span> [<span class=\"hljs-string\">&quot;./demo.ts&quot;</span>],<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"联合类型和类型保护-1\"><a href=\"#联合类型和类型保护-1\" class=\"headerlink\" title=\"联合类型和类型保护\"></a>联合类型和类型保护</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Bird &#123;<br> fly: <span class=\"hljs-built_in\">boolean</span>;<br> sing: <span class=\"hljs-function\">()=&gt;</span>&#123;&#125;;<br>&#125;<br><span class=\"hljs-keyword\">interface</span> Dog &#123;<br> fly: <span class=\"hljs-built_in\">boolean</span>;<br> bark: <span class=\"hljs-function\">()=&gt;</span>&#123;&#125;;<br>&#125;<br><span class=\"hljs-comment\">// 类型断言的方式</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">trainAnial</span>(<span class=\"hljs-params\">animal: Bird | Dog</span>) </span>&#123;<br> <span class=\"hljs-keyword\">if</span>(animal.fly) &#123;<br>  (animal <span class=\"hljs-keyword\">as</span> Bird).sing();<br> &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>  (animal <span class=\"hljs-keyword\">as</span> Dog).bark();<br> &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// in 语法来做类型保护</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">trainAnialSecond</span>(<span class=\"hljs-params\">animal: Bird | Dog</span>) </span>&#123;<br> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-string\">&#x27;sing&#x27;</span> <span class=\"hljs-keyword\">in</span> animal) &#123;<br>  animal.sing();<br> &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>  animal.bark();<br> &#125;<br>&#125;<br><span class=\"hljs-comment\">// typeof 语法来做类型保护</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\">first: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>, second: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span></span>) </span>&#123;<br> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">typeof</span> first === <span class=\"hljs-string\">&#x27;string&#x27;</span> || <span class=\"hljs-keyword\">typeof</span> second === <span class=\"hljs-string\">&#x27;string&#x27;</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;first&#125;</span><span class=\"hljs-subst\">$&#123;second&#125;</span>`</span>;<br> &#125;<br> <span class=\"hljs-keyword\">return</span> first + second;<br>&#125;<br><br><span class=\"hljs-comment\">// 使用instanceof语法来做类型保护</span><br><span class=\"hljs-keyword\">class</span> NumberObj &#123;<br> count: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addSecond</span>(<span class=\"hljs-params\">first: <span class=\"hljs-built_in\">object</span> | NumberObj, second: <span class=\"hljs-built_in\">object</span> | NumberObj</span>) </span>&#123;<br> <span class=\"hljs-keyword\">if</span>(first <span class=\"hljs-keyword\">instanceof</span> NumberObj &amp;&amp; second <span class=\"hljs-keyword\">instanceof</span> NumberObj) &#123;<br>  <span class=\"hljs-keyword\">return</span> first.count + second.count;<br> &#125;<br> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Enum枚举类型\"><a href=\"#Enum枚举类型\" class=\"headerlink\" title=\"Enum枚举类型\"></a>Enum枚举类型</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> Status = &#123;<br> OFFLINE: <span class=\"hljs-number\">0</span>,<br> ONLINE: <span class=\"hljs-number\">1</span>,<br> DELETED: <span class=\"hljs-number\">2</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getResult</span>(<span class=\"hljs-params\">status</span>) </span>&#123;<br> <span class=\"hljs-keyword\">if</span>(status === Status.OFFLINE)&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;offline&#x27;</span>;<br> &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(status === Status.ONLINE) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;online&#x27;</span>;<br> &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(status === Status.DELETED) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;deleted&#x27;</span>;<br> &#125;<br> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;error&#x27;</span>;<br>&#125;<br><span class=\"hljs-built_in\">enum</span> Status &#123;<br> OFFLINE,<br> ONLINE,<br> DELETED2<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getResult</span>(<span class=\"hljs-params\">status</span>) </span>&#123;<br> <span class=\"hljs-keyword\">if</span>(status === Status.OFFLINE)&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;offline&#x27;</span>;<br> &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(status === Status.ONLINE) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;online&#x27;</span>;<br> &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(status === Status.DELETED) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;deleted&#x27;</span>;<br> &#125;<br> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;error&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"函数泛型\"><a href=\"#函数泛型\" class=\"headerlink\" title=\"函数泛型\"></a>函数泛型</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 泛型generic泛指的 类型</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">join</span>&lt;<span class=\"hljs-title\">T</span>,<span class=\"hljs-title\">P</span>&gt;(<span class=\"hljs-params\">first: T, second: P</span>) </span>&#123;<br> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;first&#125;</span><span class=\"hljs-subst\">$&#123;second&#125;</span>`</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">anotherJoin</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">first: T,second: T</span>): <span class=\"hljs-title\">T</span> </span>&#123;<br> <span class=\"hljs-keyword\">return</span> first;<br>&#125;<br><br><span class=\"hljs-comment\">// T[]</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">map</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">params: <span class=\"hljs-built_in\">Array</span>&lt;T&gt;</span>) </span>&#123;<br> <span class=\"hljs-keyword\">return</span> params;<br>&#125;<br><span class=\"hljs-comment\">// join&lt;number,string&gt;(1,&#x27;1&#x27;);</span><br><span class=\"hljs-comment\">// map&lt;string&gt;([&#x27;123&#x27;]);</span><br>join(<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;1&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"类中如何使用泛型\"><a href=\"#类中如何使用泛型\" class=\"headerlink\" title=\"类中如何使用泛型\"></a>类中如何使用泛型</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Item &#123;<br> name: <span class=\"hljs-built_in\">string</span>;<br>&#125;<br><span class=\"hljs-keyword\">class</span> DataManager&lt;T <span class=\"hljs-keyword\">extends</span> Item&gt; &#123;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> data: T[]</span>) &#123;&#125;<br> getItem(index: <span class=\"hljs-built_in\">number</span>):<span class=\"hljs-built_in\">string</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.data[index].name;<br> &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">new</span> DataManager(&#123;<br> &#123;<br>  name: <span class=\"hljs-string\">&#x27;jeskson&#x27;</span><br> &#125;<br>]&#125;;<br><br><span class=\"hljs-comment\">// 用泛型可以声明一些类型：</span><br><span class=\"hljs-comment\">// 如何使用泛型作为一个具体的类型注解</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">hello</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">params: T</span>) </span>&#123;<br> <span class=\"hljs-keyword\">return</span> params;<br>&#125;<br><span class=\"hljs-keyword\">const</span> func: &lt;T&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\">param: T</span>) =&gt;</span> T = hello;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tsx\">&quot;use strict&quot;<br>var Header &#x3D; (function() &#123;<br> function Header() &#123;<br>  var elem &#x3D; document.createElement(&#39;div&#39;);<br>  elem.innerText &#x3D; &#39;This is Header&#39;;<br>  document.body.appendChild(elem);<br> &#125;<br> return Header;<br>&#125;());<br><br>var Content &#x3D; (function()&#x3D;&gt;&#123;<br> function Content() &#123;<br>  var elem &#x3D; document.createElement(&#39;div&#39;);<br>  elem.innerText &#x3D; &#39;This is Content&#39;;<br>  document.body.appendChild(elem);<br> &#125;<br> return Content<br>&#125;());<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用Parcel打包TS代码\"><a href=\"#使用Parcel打包TS代码\" class=\"headerlink\" title=\"使用Parcel打包TS代码\"></a>使用Parcel打包TS代码</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\">yarn add --dev parcel<span class=\"hljs-meta\">@next</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"泛型中keyof语法的使用\"><a href=\"#泛型中keyof语法的使用\" class=\"headerlink\" title=\"泛型中keyof语法的使用\"></a>泛型中keyof语法的使用</h3><blockquote>\n<p>某一数据类型的key的数组集合，既适用于数组，也适用于对象</p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> testInter &#123;<br>    name: <span class=\"hljs-built_in\">string</span>,<br>    age: <span class=\"hljs-built_in\">number</span><br>&#125;<br><span class=\"hljs-keyword\">let</span> testArr: <span class=\"hljs-built_in\">string</span>[] = [<span class=\"hljs-string\">&#x27;dada&#x27;</span>, <span class=\"hljs-string\">&#x27;dada1&#x27;</span>];<br><span class=\"hljs-keyword\">let</span> testObj: testInter = &#123;name: <span class=\"hljs-string\">&#x27;tate&#x27;</span>, age: <span class=\"hljs-number\">26</span>&#125;<br><br><span class=\"hljs-comment\">// 数组</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showKey</span>&lt;<span class=\"hljs-title\">K</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">keyof</span> <span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">T</span>&gt; (<span class=\"hljs-params\">key: K, obj: <span class=\"hljs-built_in\">Array</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> key;<br>&#125;<br>showKey&lt;<span class=\"hljs-built_in\">number</span>, <span class=\"hljs-built_in\">Array</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;&gt;(<span class=\"hljs-number\">1</span>, testArr);<br><br><span class=\"hljs-comment\">// 对象</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showKey</span>&lt;<span class=\"hljs-title\">K</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">keyof</span> <span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">T</span>&gt; (<span class=\"hljs-params\">keyItem: K, obj: T</span>): <span class=\"hljs-title\">K</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> keyItem;<br>&#125;<br><span class=\"hljs-keyword\">let</span> val = showKey(<span class=\"hljs-string\">&#x27;name&#x27;</span>, testObj)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showKey</span>&lt;<span class=\"hljs-title\">K</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">keyof</span> <span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">T</span>&gt; (<span class=\"hljs-params\">items: K[], obj: T</span>): <span class=\"hljs-title\">T</span>[<span class=\"hljs-title\">K</span>][] </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> items.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> obj[item])<br>&#125;<br><span class=\"hljs-keyword\">interface</span> Person &#123;<br> name: <span class=\"hljs-built_in\">string</span>;<br> age: <span class=\"hljs-built_in\">number</span>;<br> gender: <span class=\"hljs-built_in\">string</span>;<br>&#125;<br><span class=\"hljs-keyword\">class</span> Teacher &#123;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> info: Person</span>) &#123;&#125;<br> getInfo(key: <span class=\"hljs-built_in\">string</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span>(key===<span class=\"hljs-string\">&#x27;name&#x27;</span> || key===<span class=\"hljs-string\">&#x27;age&#x27;</span> || key===<span class=\"hljs-string\">&#x27;gender&#x27;</span>) &#123;<br>   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.info[key];<br>  &#125;<br> &#125;<br>&#125;<br> <br><span class=\"hljs-keyword\">const</span> teacher = <span class=\"hljs-keyword\">new</span> Teacher(&#123;<br> name: <span class=\"hljs-string\">&#x27;jeskson&#x27;</span>,<br> age: <span class=\"hljs-number\">12</span>,<br> gender: <span class=\"hljs-string\">&#x27;male&#x27;</span><br>&#125;);<br><span class=\"hljs-keyword\">const</span> test = teacher.genInfo(<span class=\"hljs-string\">&#x27;name&#x27;</span>);<br><span class=\"hljs-keyword\">class</span> Teacher &#123;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> info: Person</span>) &#123;&#125;<br> <span class=\"hljs-comment\">// getInfo&lt;T extends keyof Person&gt;(key:string) &#123;</span><br> getInfo&lt;T <span class=\"hljs-keyword\">extends</span> keyof Person&gt;(key: T):Person[T]&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.info[key];<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 类的装饰器</span><br><span class=\"hljs-comment\">// 装饰器本身是一个函数</span><br><span class=\"hljs-comment\">// 装饰器通过@符号来使用</span><br><span class=\"hljs-comment\">// 普通方法，target对应的是类的prototype</span><br><span class=\"hljs-comment\">// 静态方法，target对应的是类的构造函数</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getNameDecorator</span>(<span class=\"hljs-params\">target:<span class=\"hljs-built_in\">any</span>,key:<span class=\"hljs-built_in\">string</span></span>)</span>&#123;<br> <span class=\"hljs-built_in\">console</span>.log(target,key);<br>&#125;<br><span class=\"hljs-keyword\">class</span> Test &#123;<br> name: <span class=\"hljs-built_in\">string</span>;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">string</span></span>)&#123;<br>  <span class=\"hljs-built_in\">this</span>.name = name;<br> &#125;<br> <span class=\"hljs-meta\">@getNameDecorator</span><br> <span class=\"hljs-keyword\">static</span> getName() &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;123&#x27;</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"接口Interface\"><a href=\"#接口Interface\" class=\"headerlink\" title=\"接口Interface\"></a>接口Interface</h3><p>有时候我们传入的参数可能会包含很多的属性，但编译器只会检查那些必须的属性是否存在，以及类型是否匹配，而接口就是用来描述这样的结构。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\">config: &#123;name:<span class=\"hljs-built_in\">string</span>,age:<span class=\"hljs-built_in\">number</span>&#125;</span>) </span>&#123;<br> <span class=\"hljs-built_in\">console</span>.log(config.name+config.age);<br>&#125;<br><span class=\"hljs-built_in\">console</span>.log(Person(&#123;name:<span class=\"hljs-string\">&#x27;魔王哪吒&#x27;</span>,age:<span class=\"hljs-number\">12</span>&#125;));<br><span class=\"hljs-comment\">// 重构</span><br><span class=\"hljs-keyword\">interface</span> Config &#123;<br> name: <span class=\"hljs-built_in\">string</span>;<br> age: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\">config: Config</span>) </span>&#123;<br> <span class=\"hljs-built_in\">console</span>.log(config.name+config.age);<br>&#125;<br><span class=\"hljs-comment\">// 接口类型检查会检测属性有没有在Config接口中而进行限制</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可选属性</p>\n</blockquote>\n<p>接口中的属性有时候是不必须的，有的用得到，有的用不到的情况下，是可选属性，这样对可能存在的属性进行预先定义。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Config &#123;<br> name: <span class=\"hljs-built_in\">string</span>;<br> age?: <span class=\"hljs-built_in\">number</span>;<br> <span class=\"hljs-comment\">// [propName: string]: any 转字符串索引签名</span><br>&#125;<br><span class=\"hljs-comment\">// [propName: string]: any</span><br><span class=\"hljs-comment\">// 这个索引签名是为了你能够预见某个对象可能有某些特殊的用途而准备的</span><br><span class=\"hljs-comment\">// 属性名写错，可以通过索引签名的方式进行屏蔽错误</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>只读属性</p>\n</blockquote>\n<p>对于一些对象属性只能在对象刚刚创建的时候修改其值，在属性前用readonly来指定只读属性：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Point &#123;<br>  <span class=\"hljs-keyword\">readonly</span> x: <span class=\"hljs-built_in\">number</span>;<br>  <span class=\"hljs-keyword\">readonly</span> y: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><span class=\"hljs-keyword\">let</span> p:Point = &#123; x: <span class=\"hljs-number\">12</span>, y: <span class=\"hljs-number\">14</span> &#125;<br>p.x = <span class=\"hljs-number\">15</span> <span class=\"hljs-comment\">// 错误</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>函数类型</p>\n</blockquote>\n<p>接口能够描述JavaScript中对象拥有的各种各样的外形</p>\n<p>函数类型接口：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Fun &#123;<br> (source: <span class=\"hljs-built_in\">string</span>, subString: <span class=\"hljs-built_in\">string</span>): <span class=\"hljs-built_in\">Boolean</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>接口继承</p>\n</blockquote>\n<p>接口是可以相互继承的，能够从一个接口里复制成员到另一个接口里。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Animal &#123;<br> name: <span class=\"hljs-built_in\">string</span>;<br> say(): <span class=\"hljs-built_in\">void</span>;<br>&#125;<br><span class=\"hljs-keyword\">interface</span> Person <span class=\"hljs-keyword\">extends</span> Animal &#123;<br> work(): <span class=\"hljs-built_in\">void</span>;<br> closer: <span class=\"hljs-built_in\">string</span>;<br>&#125;<br><span class=\"hljs-keyword\">class</span> Pro <span class=\"hljs-keyword\">implements</span> Person &#123;<br> closer: <span class=\"hljs-built_in\">string</span>;<br> name: <span class=\"hljs-built_in\">string</span>;<br> say(): <span class=\"hljs-built_in\">void</span> &#123;<br> <br> &#125;<br> work(): <span class=\"hljs-built_in\">void</span> &#123;<br> <br> &#125;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">string</span>, closer:<span class=\"hljs-built_in\">string</span></span>) &#123;<br>  <span class=\"hljs-built_in\">this</span>.name = name;<br>  <span class=\"hljs-built_in\">this</span>.closer = closer;<br> &#125;<br>&#125;<br><span class=\"hljs-keyword\">let</span> g:Person = <span class=\"hljs-keyword\">new</span> Pro(<span class=\"hljs-string\">&quot;jeskson&quot;</span>,<span class=\"hljs-string\">&quot;it&quot;</span>);<br>g.say();<br>g.work();<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>对象类型接口</li>\n<li>函数类型接口</li>\n</ul>\n<p>接口的定义方式：使用interface关键字</p>\n<p>接口中可定义：</p>\n<ul>\n<li>确定属性</li>\n<li>可选属性</li>\n<li>任意属性</li>\n<li>只读属性</li>\n</ul>\n<ol>\n<li>确定属性</li>\n</ol>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> UserInfo &#123;<br> name: <span class=\"hljs-built_in\">string</span>;<br> age: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> myInfo: UserInfo = &#123;<br> name: <span class=\"hljs-string\">&#x27;魔王哪吒&#x27;</span>,<br> age: <span class=\"hljs-number\">12</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>接口中约束好的确定属性，定义对象变量的时候，不能少，也不能多🙅‍</p>\n</blockquote>\n<ol>\n<li>可选属性</li>\n</ol>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> UserInfo &#123;<br> name: <span class=\"hljs-built_in\">string</span>;<br> age: <span class=\"hljs-built_in\">number</span>;<br> sex?: <span class=\"hljs-built_in\">string</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> myInfo: UserInfo = &#123;<br> name: <span class=\"hljs-string\">&#x27;魔王哪吒&#x27;</span>,<br> age: <span class=\"hljs-number\">12</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>接口中的可选属性，是表示在对象变量中可以不存在</p>\n</blockquote>\n<ol>\n<li>任意属性</li>\n</ol>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> UserInfo &#123;<br> name: <span class=\"hljs-built_in\">string</span>;<br> age: <span class=\"hljs-built_in\">number</span>;<br> sex?: <span class=\"hljs-built_in\">string</span>;<br> [proName: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> myInfo: UserInfo = &#123;<br>  name: <span class=\"hljs-string\">&quot;dadaqianduan&quot;</span>,<br>  age: <span class=\"hljs-number\">12</span>,<br>  test1: <span class=\"hljs-string\">&#x27;123&#x27;</span>,<br>  test2: <span class=\"hljs-string\">&#x27;abc&#x27;</span>,<br>  test3: <span class=\"hljs-number\">123</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是任意属性类型的子类，定义了任意属性后，对象变量中的属性个数才可以出现比接口的属性数量多的情况。</p>\n</blockquote>\n<ol>\n<li>只读属性</li>\n</ol>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> UserInfo &#123;<br>  <span class=\"hljs-keyword\">readonly</span> id: <span class=\"hljs-built_in\">number</span>;<br>  name: <span class=\"hljs-built_in\">string</span>;<br>  age: <span class=\"hljs-built_in\">number</span>;<br>  sex?: <span class=\"hljs-built_in\">string</span>;<br>  [propName: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span>;<br>&#125;<br><span class=\"hljs-keyword\">const</span> myInfo: UserInfo = &#123;<br>  id: <span class=\"hljs-number\">1</span>,<br>  name: <span class=\"hljs-string\">&quot;dada&quot;</span>,<br>  age: <span class=\"hljs-number\">12</span>,<br>  test1: <span class=\"hljs-string\">&quot;123&quot;</span>,<br>  test2: <span class=\"hljs-string\">&quot;abc&quot;</span>,<br>  test3: <span class=\"hljs-number\">123</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>只读属性，也是确定属性，在对象变量定义的时候必须有值，后面不能修改</p>\n</blockquote>\n<ul>\n<li>对象接口，以查询商品列表接口API示例：</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> ResponseData &#123;<br>    resCode: <span class=\"hljs-built_in\">number</span>;<br>    resData: ResultData[];<br>    message: <span class=\"hljs-built_in\">string</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">interface</span> ResultData &#123;<br>    productId: <span class=\"hljs-built_in\">number</span>;<br>    productName: <span class=\"hljs-built_in\">string</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> resultData = &#123;<br>    resCode: <span class=\"hljs-number\">0</span>,<br>    resData: [<br>        &#123; productId: <span class=\"hljs-number\">1</span>, productName:<span class=\"hljs-string\">&quot;TypeScipt实战&quot;</span> &#125;,<br>        &#123; productId: <span class=\"hljs-number\">2</span>, productName:<span class=\"hljs-string\">&quot;TypeScipt从入门到精通&quot;</span> &#125;,<br>    ],<br>    message: <span class=\"hljs-string\">&quot;success&quot;</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">render</span>(<span class=\"hljs-params\">res: ResponseData</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(res.resCode, res.message)<br>    res.resData.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">obj</span>) =&gt;</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(obj.productId, obj.productName)<br>    &#125;)<br>&#125;<br><br>render(resultData);<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>只要传入的对象满足接口的必要条件就可以被允许,即使传入多余的字段也可以通过类型检查</p>\n</blockquote>\n<ul>\n<li>绕过检查的方法有3种:</li>\n</ul>\n<ol>\n<li>将对象字面量赋值给一个变量</li>\n</ol>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> result = &#123;<br>    resCode: <span class=\"hljs-number\">0</span>,<br>    resData: [<br>        &#123; productId: <span class=\"hljs-number\">1</span>, productName:<span class=\"hljs-string\">&quot;TypeScipt实战&quot;</span>, remark: <span class=\"hljs-string\">&quot;备注&quot;</span>&#125;,<br>        &#123; productId: <span class=\"hljs-number\">2</span>, productName:<span class=\"hljs-string\">&quot;TypeScipt从入门到精通&quot;</span> &#125;,<br>    ],<br>    message: <span class=\"hljs-string\">&quot;success&quot;</span><br>&#125;<br>render(result)<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>使用类型断言</li>\n</ol>\n<blockquote>\n<p>使用类型断言方式,明确告诉编译器类型是什么,编译器就会绕过类型检查</p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\">render(&#123;<br>    resCode: <span class=\"hljs-number\">0</span>,<br>    resData: [<br>        &#123; productId: <span class=\"hljs-number\">1</span>, productName:<span class=\"hljs-string\">&quot;TypeScipt实战&quot;</span>, remark:<span class=\"hljs-string\">&quot;&quot;</span>&#125;,<br>        &#123; productId: <span class=\"hljs-number\">2</span>, productName:<span class=\"hljs-string\">&quot;TypeScipt从入门到精通&quot;</span> &#125;,<br>    ],<br>    message: <span class=\"hljs-string\">&quot;success&quot;</span><br>&#125; <span class=\"hljs-keyword\">as</span> ResponseData)<br><br>render(&lt;ResponseData&gt;&#123;<br>    resCode: <span class=\"hljs-number\">0</span>,<br>    resData: [<br>        &#123; productId: <span class=\"hljs-number\">1</span>, productName:<span class=\"hljs-string\">&quot;TypeScipt实战&quot;</span>, remark: <span class=\"hljs-string\">&quot;备注&quot;</span>&#125;,<br>        &#123; productId: <span class=\"hljs-number\">2</span>, productName:<span class=\"hljs-string\">&quot;TypeScipt从入门到精通&quot;</span> &#125;,<br>    ],<br>    message: <span class=\"hljs-string\">&quot;success&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>使用字符串索引签名</li>\n</ol>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> ResultData &#123;<br>    productId: <span class=\"hljs-built_in\">number</span>;<br>    productName: <span class=\"hljs-built_in\">string</span>;<br>    [remark: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span>;  <span class=\"hljs-comment\">// 字符串索引签名</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>函数接口</p>\n</blockquote>\n<ul>\n<li>函数定义方式：</li>\n</ul>\n<ol>\n<li>在TS中，使用一个变量直接定义函数</li>\n</ol>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> add: <span class=\"hljs-function\">(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span><br>= (x, y)&#123;<br>  <span class=\"hljs-keyword\">return</span> x+y;<br>&#125;;<br>add(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>使用接口定义函数</li>\n</ol>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Add &#123;<br>    (x: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">number</span><br>&#125;<br><span class=\"hljs-keyword\">let</span> myFunc: Add = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x, y</span>)</span>&#123;<br>  <span class=\"hljs-keyword\">return</span> x+y;<br>&#125;;<br>myFunc(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>使用类型别名来定义函数</li>\n</ol>\n<p>类型别名使用type关键字</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Add = <span class=\"hljs-function\">(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可索引类型的接口</p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 数字索引接口</span><br><span class=\"hljs-keyword\">interface</span> numberIndex &#123;<br>    [x: <span class=\"hljs-built_in\">number</span>]: <span class=\"hljs-built_in\">string</span><br>&#125;<br><span class=\"hljs-comment\">// 相当于声明了一个字符串类型的数组</span><br><span class=\"hljs-keyword\">let</span> chars: numberIndex = [<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>]<br><span class=\"hljs-comment\">// 声明一个字符串索引类型的接口</span><br><span class=\"hljs-keyword\">interface</span> stringIndex &#123;<br>    [x: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">string</span><br>&#125;<br><span class=\"hljs-comment\">// 两种索引签名混用</span><br><span class=\"hljs-keyword\">interface</span> stringIndex &#123;<br>    [x: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">string</span><br>    [z: <span class=\"hljs-built_in\">number</span>]: <span class=\"hljs-built_in\">number</span>    <span class=\"hljs-comment\">// // Numeric index type &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.</span><br>&#125;<br><br><span class=\"hljs-keyword\">interface</span> stringIndex &#123;<br>    [x: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span><br>    [z: <span class=\"hljs-built_in\">number</span>]: <span class=\"hljs-built_in\">number</span> <span class=\"hljs-comment\">// Numeric index type &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"上手TypeScipt\"><a href=\"#上手TypeScipt\" class=\"headerlink\" title=\"上手TypeScipt\"></a>上手TypeScipt</h3><p>对于npm的用户</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\">npm install -g typescript<br></code></pre></td></tr></table></figure>\n\n<p>构建第一个TypeScript文件，dada.ts 文件：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dada</span>(<span class=\"hljs-params\">person</span>) </span>&#123;<br> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;hello&quot;</span> + person;<br>&#125;<br><span class=\"hljs-keyword\">let</span> user = <span class=\"hljs-string\">&quot;jeskson&quot;</span>;<br><span class=\"hljs-built_in\">document</span>.body.innerHTML = dada(uer);<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>编译代码</p>\n</blockquote>\n<p>在命令行上，运行TypeScript编译器：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\">tsc dada.ts<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>添加类型注解<code>: string</code></p>\n</blockquote>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dada</span>(<span class=\"hljs-params\">person: <span class=\"hljs-built_in\">string</span></span>) </span>&#123;<br> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;jeskson&quot;</span>+person;<br>&#125;<br><span class=\"hljs-keyword\">let</span> user = <span class=\"hljs-string\">&quot;jeskson&quot;</span>;<br><span class=\"hljs-built_in\">document</span>.body.innerHTML = dada(user);<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>类型注解</p>\n</blockquote>\n<p>TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式。</p>\n<p>接口</p>\n<p>允许我们在实现接口的时候只要保证包含了接口要求的结构就可以</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// implements语句</span><br><span class=\"hljs-keyword\">interface</span> Person &#123;<br> firstName: <span class=\"hljs-built_in\">string</span>;<br> lastName: <span class=\"hljs-built_in\">string</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span>(<span class=\"hljs-params\">peson: Person</span>) </span>&#123;<br> <span class=\"hljs-keyword\">return</span> person.firstName + person.lastName;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> user = &#123; firstName: <span class=\"hljs-string\">&quot;jeskson&quot;</span>, lastName: <span class=\"hljs-string\">&quot;User&quot;</span> &#125;;<br><br><span class=\"hljs-built_in\">document</span>.body.innerHTML = func(user);<br></code></pre></td></tr></table></figure>\n\n<p>类，支持基于类的面向对象编程</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">class</span> Student &#123;<br> fullName: <span class=\"hljs-built_in\">string</span>;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">public</span> firstName: <span class=\"hljs-built_in\">string</span>, <span class=\"hljs-keyword\">public</span> lastName: <span class=\"hljs-built_in\">string</span></span>) &#123;<br>  <span class=\"hljs-built_in\">this</span>.fullName = firstName + lastName;<br> &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">interface</span> Person &#123;<br> firstName: <span class=\"hljs-built_in\">string</span>;<br> lastName: <span class=\"hljs-built_in\">string</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dada</span>(<span class=\"hljs-params\">person: Person</span>) </span>&#123;<br> <span class=\"hljs-keyword\">return</span> person.firstName+person.lastName;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> user = <span class=\"hljs-keyword\">new</span> Student(<span class=\"hljs-string\">&quot;jeskson&quot;</span>,<span class=\"hljs-string\">&quot;魔王哪吒&quot;</span>);<br><span class=\"hljs-built_in\">document</span>.body.innerHTML = dada(user);<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>运行TypeScript Web应用</p>\n</blockquote>\n<p>在<code>index.html</code>里输入内容:</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>    &lt;head&gt;&lt;title&gt;TypeScript dada&lt;<span class=\"hljs-regexp\">/title&gt;&lt;/</span>head&gt;<br>    &lt;body&gt;<br>        &lt;script src=<span class=\"hljs-string\">&quot;dada.js&quot;</span>&gt;&lt;/script&gt;<br>    &lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>在JS中,可以任意修改对象属性,TS中不允许</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 这是因为,仅声明了对象obj的类型注解是object</span><br><span class=\"hljs-keyword\">let</span> obj: <span class=\"hljs-built_in\">object</span> = &#123;x: <span class=\"hljs-string\">&#x27;a&#x27;</span>, y: <span class=\"hljs-string\">&#x27;b&#x27;</span>&#125;<br>obj.x = <span class=\"hljs-number\">3</span>    <span class=\"hljs-comment\">// Property &#x27;x&#x27; does not exist on type &#x27;object&#x27;.</span><br><span class=\"hljs-keyword\">let</span> obj: &#123;x: <span class=\"hljs-built_in\">string</span>, y: <span class=\"hljs-built_in\">string</span>&#125; = &#123;x: <span class=\"hljs-string\">&#x27;a&#x27;</span>, y: <span class=\"hljs-string\">&#x27;b&#x27;</span>&#125;<br>obj.x = <span class=\"hljs-string\">&#x27;c&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><p>具有唯一的值,可以显式声明,也可直接创建</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> symbol1: <span class=\"hljs-built_in\">Symbol</span> = <span class=\"hljs-built_in\">Symbol</span>()  <span class=\"hljs-comment\">// 显示声明</span><br><span class=\"hljs-keyword\">let</span> symbol2 = <span class=\"hljs-built_in\">Symbol</span>()  <span class=\"hljs-comment\">// 直接创建</span><br><br><span class=\"hljs-comment\">// 验证:是否是同一个对象</span><br><span class=\"hljs-built_in\">console</span>.log(symbol1 === symbol2)    <span class=\"hljs-comment\">// fasle</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"undefined-和-null\"><a href=\"#undefined-和-null\" class=\"headerlink\" title=\"undefined 和 null\"></a>undefined 和 null</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 一旦声明了undefined,就不能再被赋值为任何其他的数据类型了</span><br><span class=\"hljs-keyword\">let</span> udf: <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-literal\">undefined</span><br><span class=\"hljs-keyword\">let</span> nu: <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span><br><br><span class=\"hljs-keyword\">let</span> undf: <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-number\">1</span> <br><span class=\"hljs-comment\">// Type &#x27;1&#x27; is not assignable to type &#x27;undefined&#x27;.</span><br><br><span class=\"hljs-comment\">// 默认情况下,undefined和null也不能被赋值给任何其他类型</span><br><br><span class=\"hljs-keyword\">let</span> num1: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-literal\">undefined</span>    <br><span class=\"hljs-comment\">// Type &#x27;undefined&#x27; is not assignable to type &#x27;number&#x27;.</span><br><br><span class=\"hljs-keyword\">let</span> num2: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-literal\">null</span> <br><span class=\"hljs-comment\">// Type &#x27;null&#x27; is not assignable to type &#x27;number&#x27;.</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>在TS中,<code>undefined和null</code>是任何类型的子类型,所以可以被赋值给其他类型</li>\n<li>设置允许被赋值为其他类型</li>\n</ul>\n<blockquote>\n<p>打开<code>tsconfig.js,将strictNullChecks = false(默认true)</code></p>\n</blockquote>\n<h3 id=\"void-any-never\"><a href=\"#void-any-never\" class=\"headerlink\" title=\"void,any,never\"></a><code>void,any,never</code></h3><ul>\n<li>在<code>js</code>中,<code>void</code>操作符可以使任何一个表达式返回<code>undefined</code></li>\n<li><code>void 0 // 将返回undefined</code></li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// void</span><br><span class=\"hljs-keyword\">let</span> voidFunc = <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>any</code>:如果不指定<code>TS</code>的变量类型,默认为<code>any</code>类型,可以赋值为任何类型</li>\n<li><code>never</code>:永远不会有返回值的类型</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 函数抛出异常,永远不会有返回值,类型为never</span><br><span class=\"hljs-keyword\">let</span> error = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;error&#x27;</span>)<br>&#125;<br><br><span class=\"hljs-comment\">// 死循环函数永远没有返回值,类型为never</span><br><span class=\"hljs-keyword\">let</span> endless = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"对数组中的对象按对象的值进行去重\"><a href=\"#对数组中的对象按对象的值进行去重\" class=\"headerlink\" title=\"对数组中的对象按对象的值进行去重\"></a>对数组中的对象按对象的值进行去重</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> listData = [<br>  &#123; firstName: <span class=\"hljs-string\">&quot;dada&quot;</span>, lastName: <span class=\"hljs-string\">&quot;abc&quot;</span>, size: <span class=\"hljs-number\">18</span> &#125;<br>&#125;<br><span class=\"hljs-comment\">//js</span><br><span class=\"hljs-keyword\">let</span> obj = &#123;&#125;;<br>listData = listData.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">item, next</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (!obj[next.lastName]) &#123;<br>    item.push(next);<br>    obj[next.lastName] = <span class=\"hljs-literal\">true</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> item;<br>&#125;, []);<br><span class=\"hljs-comment\">//ts</span><br><span class=\"hljs-keyword\">const</span> obj: &#123;[key: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">boolean</span>;&#125; = &#123;&#125;;<br>listData = listData.reduce&lt;ListDataItem[]&gt;(<span class=\"hljs-function\">(<span class=\"hljs-params\">item, next</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (!obj[next.lastName]) &#123;<br>    item.push(next);<br>    obj[next.lastName] = <span class=\"hljs-literal\">true</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> item;<br>&#125;,[]);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"在微信小程序开发中使用Typescript\"><a href=\"#在微信小程序开发中使用Typescript\" class=\"headerlink\" title=\"在微信小程序开发中使用Typescript\"></a>在微信小程序开发中使用<code>Typescript</code></h3><p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"图片\">image.png</p>\n<p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"图片\">image.png</p>\n<p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"图片\">image.png</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/3aPj0GhFQDC6bQkW63sHHticGmYfWw117KQ67xjc6cNxaby0fKic4yFcbADXHpMu1RpWoCo8TSu6KCTVAgR6DZicw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\">image.png</p>\n<h3 id=\"模块的概念\"><a href=\"#模块的概念\" class=\"headerlink\" title=\"模块的概念\"></a>模块的概念</h3><p>“内部模块”现在称为“命令空间”，“外部模块”现在简称为“模块”，模块字其自身的作用域里执行，而不是在全局作用域里。</p>\n<p>这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用export形式之一导出它们。</p>\n<p>相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用 <code>import</code> 形式之一。</p>\n<p>模块的概念：</p>\n<p>我们可以把一些公共的功能单独抽离成一个文件作为一个模块，模块里面的变量，函数，类等默认是私有的，如果我们要在外部访问模块里面的数据，我们需要通过<code>export</code>暴露模块里面的数据。暴露后使用<code>import</code>引入模块就可以使用模块里面暴露的数据。</p>\n<h3 id=\"命名空间-1\"><a href=\"#命名空间-1\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h3><p>命名空间和模块的区别</p>\n<ul>\n<li>命名空间：内部模块，主要用于组织代码，避免命名冲突</li>\n<li>模块：ts的外部模块的简称</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">namespace</span> A &#123;<br><span class=\"hljs-keyword\">interface</span> Animal &#123;<br> name: <span class=\"hljs-built_in\">string</span>;<br> eat(): <span class=\"hljs-built_in\">void</span>;<br>&#125;<br><span class=\"hljs-keyword\">class</span> Dog <span class=\"hljs-keyword\">implements</span> Animal &#123;<br> name: <span class=\"hljs-built_in\">string</span>;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">theName: <span class=\"hljs-built_in\">string</span></span>) &#123;<br>  <span class=\"hljs-built_in\">this</span>.name = theName;<br> &#125;<br> eat() &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;dog&#x27;</span>);<br> &#125;<br>&#125;<br><span class=\"hljs-keyword\">class</span> Cat <span class=\"hljs-keyword\">implements</span> Animal &#123;<br> name: <span class=\"hljs-built_in\">string</span>;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">theName: <span class=\"hljs-built_in\">string</span></span>) &#123;<br>  <span class=\"hljs-built_in\">this</span>.name = theName;<br> &#125;<br> eat() &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;cat&#x27;</span>);<br> &#125;<br>&#125;<br><span class=\"hljs-keyword\">let</span> dog = <span class=\"hljs-keyword\">new</span> Dog(<span class=\"hljs-string\">&#x27;dogdog&#x27;</span>);<br>dog.eat();<br>&#125;<br><span class=\"hljs-keyword\">import</span> &#123;A,B&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./modules/animal&#x27;</span>;<br><br><span class=\"hljs-keyword\">var</span> dog = <span class=\"hljs-keyword\">new</span> A.Dog(<span class=\"hljs-string\">&#x27;hei&#x27;</span>);<br>dog.eat();<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"装饰器-1\"><a href=\"#装饰器-1\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。</p>\n<p>通俗的讲装饰器就是一个方法，可以注入到类，方法，属性参数上扩展类，属性，方法，参数的功能。</p>\n<p>常见的装饰器有：<strong>类装饰器，属性装饰器，方法装饰器，参数装饰器</strong></p>\n<p>装饰器的写法：</p>\n<ul>\n<li>普通装饰器（无法传参）</li>\n<li>装饰器工厂（可传参）</li>\n</ul>\n<blockquote>\n<p>方法参数装饰器：</p>\n</blockquote>\n<p>参数装饰器表达式会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元素数据，传入下列3个参数：    </p>\n<ul>\n<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>\n<li>方法的名字</li>\n<li>参数在函数参数列表中的索引</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logParams</span>(<span class=\"hljs-params\">params:<span class=\"hljs-built_in\">any</span></span>)</span>&#123;<br> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target:<span class=\"hljs-built_in\">any</span>,methodName:<span class=\"hljs-built_in\">any</span>,paramsIndex:<span class=\"hljs-built_in\">any</span></span>)</span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(params);<br>  <span class=\"hljs-built_in\">console</span>.log(target);<br>  <span class=\"hljs-built_in\">console</span>.log(methodName);<br>  <span class=\"hljs-built_in\">console</span>.log(paramsIndex);<br> &#125;<br>&#125;<br><span class=\"hljs-keyword\">class</span> HttpClient&#123;<br> <span class=\"hljs-keyword\">public</span> url:<span class=\"hljs-built_in\">any</span>|<span class=\"hljs-literal\">undefined</span>;<br> <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"></span>)&#123;&#125;<br> getDate(<span class=\"hljs-meta\">@logParams</span>(<span class=\"hljs-string\">&#x27;xxx&#x27;</span>) uuid:<span class=\"hljs-built_in\">any</span>)&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(uuid);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"keyof\"><a href=\"#keyof\" class=\"headerlink\" title=\"keyof\"></a>keyof</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\">keyof与<span class=\"hljs-built_in\">Object</span>.keys相似，keyof取<span class=\"hljs-keyword\">interface</span>的键<br><span class=\"hljs-keyword\">interface</span> Point &#123;<br> x: <span class=\"hljs-built_in\">number</span>;<br> y: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><span class=\"hljs-comment\">// type keys = &quot;x&quot; | &quot;y&quot;</span><br><span class=\"hljs-keyword\">type</span> keys = keyof Point;<br><span class=\"hljs-comment\">// 无法确认返回类型</span><br><span class=\"hljs-comment\">// 无法对 key 做约束</span><br><span class=\"hljs-keyword\">const</span> data = &#123;<br> a: <span class=\"hljs-number\">1</span>,<br> b: <span class=\"hljs-number\">2</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">get</span>(<span class=\"hljs-params\">o: <span class=\"hljs-built_in\">object</span>, name: <span class=\"hljs-built_in\">string</span></span>) </span>&#123;<br> <span class=\"hljs-keyword\">return</span> o[name]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>使用keyof：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">get</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">object</span>, <span class=\"hljs-title\">K</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">keyof</span> <span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">o: T, name: K</span>): <span class=\"hljs-title\">T</span>[<span class=\"hljs-title\">K</span>] </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> o[name]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"`?: 运算符\"></a>`?: 运算符</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\">T <span class=\"hljs-keyword\">extends</span> U ? X : Y<br><br><span class=\"hljs-keyword\">type</span> isTrue&lt;T&gt; = T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-literal\">true</span> ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"tsconfig-json\"><a href=\"#tsconfig-json\" class=\"headerlink\" title=\"tsconfig.json\"></a><code>tsconfig.json</code></h3><p><code>tsconfig.json</code>文件中指定了用来编译这个项目的根文件和编译选项</p>\n<p><code>tsconfig.json</code>示例文件:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//&quot;compilerOptions&quot;可以被忽略，这时编译器会使用默认值。</span><br><span class=\"hljs-comment\">//使用&quot;files&quot;属性</span><br><span class=\"hljs-comment\">//&quot;files&quot;指定一个包含相对或绝对文件路径的列表。</span><br>&#123;<br>    <span class=\"hljs-string\">&quot;compilerOptions&quot;</span>: &#123;<br>        <span class=\"hljs-string\">&quot;module&quot;</span>: <span class=\"hljs-string\">&quot;commonjs&quot;</span>,<br>        <span class=\"hljs-string\">&quot;noImplicitAny&quot;</span>: <span class=\"hljs-literal\">true</span>,<br>        <span class=\"hljs-string\">&quot;removeComments&quot;</span>: <span class=\"hljs-literal\">true</span>,<br>        <span class=\"hljs-string\">&quot;preserveConstEnums&quot;</span>: <span class=\"hljs-literal\">true</span>,<br>        <span class=\"hljs-string\">&quot;sourceMap&quot;</span>: <span class=\"hljs-literal\">true</span><br>    &#125;,<br>    <span class=\"hljs-string\">&quot;files&quot;</span>: [<br>        <span class=\"hljs-string\">&quot;core.ts&quot;</span>,<br>        <span class=\"hljs-string\">&quot;sys.ts&quot;</span>,<br>        <span class=\"hljs-string\">&quot;types.ts&quot;</span>,<br>        <span class=\"hljs-string\">&quot;scanner.ts&quot;</span>,<br>        <span class=\"hljs-string\">&quot;parser.ts&quot;</span>,<br>        <span class=\"hljs-string\">&quot;utilities.ts&quot;</span>,<br>        <span class=\"hljs-string\">&quot;binder.ts&quot;</span>,<br>        <span class=\"hljs-string\">&quot;checker.ts&quot;</span>,<br>        <span class=\"hljs-string\">&quot;emitter.ts&quot;</span>,<br>        <span class=\"hljs-string\">&quot;program.ts&quot;</span>,<br>        <span class=\"hljs-string\">&quot;commandLineParser.ts&quot;</span>,<br>        <span class=\"hljs-string\">&quot;tsc.ts&quot;</span>,<br>        <span class=\"hljs-string\">&quot;diagnosticInformationMap.generated.ts&quot;</span><br>    ]<br>&#125;<br><span class=\"hljs-comment\">//使用&quot;include&quot;和&quot;exclude&quot;属性</span><br><span class=\"hljs-comment\">//如果&quot;files&quot;和&quot;include&quot;都没有被指定，编译器默认包含当前目录和子目录下所有的TypeScript文件</span><br><span class=\"hljs-comment\">//排除在&quot;exclude&quot;里指定的文件</span><br>&#123;<br>    <span class=\"hljs-string\">&quot;compilerOptions&quot;</span>: &#123;<br>        <span class=\"hljs-string\">&quot;module&quot;</span>: <span class=\"hljs-string\">&quot;system&quot;</span>,<br>        <span class=\"hljs-string\">&quot;noImplicitAny&quot;</span>: <span class=\"hljs-literal\">true</span>,<br>        <span class=\"hljs-string\">&quot;removeComments&quot;</span>: <span class=\"hljs-literal\">true</span>,<br>        <span class=\"hljs-string\">&quot;preserveConstEnums&quot;</span>: <span class=\"hljs-literal\">true</span>,<br>        <span class=\"hljs-string\">&quot;outFile&quot;</span>: <span class=\"hljs-string\">&quot;../../built/local/tsc.js&quot;</span>,<br>        <span class=\"hljs-string\">&quot;sourceMap&quot;</span>: <span class=\"hljs-literal\">true</span><br>    &#125;,<br>    <span class=\"hljs-string\">&quot;include&quot;</span>: [<br>        <span class=\"hljs-string\">&quot;src/**/*&quot;</span><br>    ],<br>    <span class=\"hljs-string\">&quot;exclude&quot;</span>: [<br>        <span class=\"hljs-string\">&quot;node_modules&quot;</span>,<br>        <span class=\"hljs-string\">&quot;**/*.spec.ts&quot;</span><br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>","raw":null,"categories":[],"tags":[{"name":"Ts","path":"api/tags/Ts.json"}]},{"title":"vue源码理解——模板编译篇","slug":"vue源码理解3","date":"2021-03-18T11:29:18.000Z","updated":"2021-04-29T03:51:41.252Z","comments":true,"top":null,"path":"api/articles/vue源码理解3.json","excerpt":null,"keywords":null,"cover":"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425144813349.png","content":"<h4 id=\"模板编译：\"><a href=\"#模板编译：\" class=\"headerlink\" title=\"模板编译：\"></a>模板编译：</h4><p>在前几篇文章中，我们介绍了<code>Vue</code>中的虚拟<code>DOM</code>以及虚拟<code>DOM</code>的<code>patch</code>(DOM-Diff)过程，而虚拟<code>DOM</code>存在的必要条件是得先有<code>VNode</code>，那么<code>VNode</code>又是从哪儿来的呢？这就是接下来几篇文章要说的模板编译。你可以这么理解：把用户写的模板进行编译，就会产生<code>VNode</code>。</p>\n<h5 id=\"什么是模板编译\"><a href=\"#什么是模板编译\" class=\"headerlink\" title=\"什么是模板编译\"></a>什么是模板编译</h5><p>我们知道，在日常开发中，我们把写在<code>&lt;template&gt;&lt;/template&gt;</code>标签中的类似于原生<code>HTML</code>的内容称之为模板。这时你可能会问了，为什么说是“类似于原生<code>HTML</code>的内容”而不是“就是<code>HTML</code>的内容”？因为我们在开发中，在<code>&lt;template&gt;&lt;/template&gt;</code>标签中除了写一些原生<code>HTML</code>的标签，我们还会写一些变量插值，如，或者写一些<code>Vue</code>指令，如<code>v-on</code>、<code>v-if</code>等。而这些东西都是在原生<code>HTML</code>语法中不存在的，不被接受的。但是事实上我们确实这么写了，也被正确识别了，页面也正常显示了，这又是为什么呢？</p>\n<p>这就归功于<code>Vue</code>的模板编译了，<code>Vue</code>会把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生<code>HTML</code>的内容进行编译，把原生<code>HTML</code>的内容找出来，再把非原生<code>HTML</code>找出来，经过一系列的逻辑处理生成渲染函数，也就是<code>render</code>函数，而<code>render</code>函数会将模板内容生成对应的<code>VNode</code>，而<code>VNode</code>再经过前几篇文章介绍的<code>patch</code>过程从而得到将要渲染的视图中的<code>VNode</code>，最后根据<code>VNode</code>创建真实的<code>DOM</code>节点并插入到视图中， 最终完成视图的渲染更新。</p>\n<p>而把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生<code>HTML</code>的内容进行编译，把原生<code>HTML</code>的内容找出来，再把非原生<code>HTML</code>找出来，经过一系列的逻辑处理生成渲染函数，也就是<code>render</code>函数的这一段过程称之为模板编译过程。</p>\n<h6 id=\"整体渲染流程\"><a href=\"#整体渲染流程\" class=\"headerlink\" title=\"整体渲染流程\"></a>整体渲染流程</h6><p>所谓渲染流程，就是把用户写的类似于原生<code>HTML</code>的模板经过一系列处理最终反应到视图中称之为整个渲染流程。这个流程在上文中其实已经说到了，下面我们以流程图的形式宏观的了解一下，流程图如下：</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425144813349.png\" alt=\"image-20210425144813349\"></p>\n<p>从图中我们也可以看到，模板编译过程就是把用户写的模板经过一系列处理最终生成<code>render</code>函数的过程。</p>\n<h6 id=\"模板编译内部流程\"><a href=\"#模板编译内部流程\" class=\"headerlink\" title=\"模板编译内部流程\"></a>模板编译内部流程</h6><p>那么模板编译内部是怎么把用户写的模板经过处理最终生成<code>render</code>函数的呢？这内部的过程是怎样的呢？</p>\n<h6 id=\"抽象语法树AST\"><a href=\"#抽象语法树AST\" class=\"headerlink\" title=\"抽象语法树AST\"></a>抽象语法树AST</h6><p>我们知道，用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的模板对<code>Vue</code>来说就是一堆字符串，那么如何解析这一堆字符串并且从中提取出元素的标签、属性、变量插值等有效信息呢？这就需要借助一个叫做抽象语法树的东西。</p>\n<p>所谓抽象语法树，在计算机科学中，<strong>抽象语法树</strong>（<strong>A</strong>bstract<strong>S</strong>yntax<strong>T</strong>ree，AST），或简称<strong>语法树</strong>（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于if-condition-then这样的条件跳转语句，可以使用带有两个分支的节点来表示。——来自百度百科</p>\n<p>我就知道，这段话贴出来也是白贴，因为看了也看不懂，哈哈。那么我们就以最直观的例子来理解什么是抽象语法树。请看下图：</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425144910621.png\" alt=\"image-20210425144910621\"></p>\n<p>从图中我们可以看到，一个简单的<code>HTML</code>标签的代码被转换成了一个<code>JS</code>对象，而这个对象中的属性代表了这个标签中一些关键有效信息。如图中标识。 有兴趣的同学可以在这个网站在线转换试试：<a href=\"https://astexplorer.net/\">https://astexplorer.net/</a></p>\n<h6 id=\"具体流程\"><a href=\"#具体流程\" class=\"headerlink\" title=\"具体流程:\"></a>具体流程:</h6><p>将一堆字符串模板解析成抽象语法树<code>AST</code>后，我们就可以对其进行各种操作处理了，处理完后用处理后的<code>AST</code>来生成<code>render</code>函数。其具体流程可大致分为三个阶段：</p>\n<ol>\n<li>模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树<code>AST</code>；</li>\n<li>优化阶段：遍历<code>AST</code>，找出其中的静态节点，并打上标记；</li>\n<li>代码生成阶段：将<code>AST</code>转换成渲染函数；</li>\n</ol>\n<p>这三个阶段在源码中分别对应三个模块，下面给出三个模块的源代码在源码中的路径：</p>\n<ol>\n<li>模板解析阶段——解析器——源码路径：<code>src/compiler/parser/index.js</code>;</li>\n<li>优化阶段——优化器——源码路径：<code>src/compiler/optimizer.js</code>;</li>\n<li>代码生成阶段——代码生成器——源码路径：<code>src/compiler/codegen/index.js</code>; 其对应的源码如下：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 源码位置: /src/complier/index.js</span><br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> createCompiler = createCompilerCreator(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">baseCompile</span> (<span class=\"hljs-params\"></span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">  template: string,</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\">  options: CompilerOptions</span></span><br><span class=\"hljs-function\"><span class=\"hljs-params\"></span>): <span class=\"hljs-title\">CompiledResult</span> </span>&#123;<br>  <span class=\"hljs-comment\">// 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST</span><br>  <span class=\"hljs-keyword\">const</span> ast = parse(template.trim(), options)<br>  <span class=\"hljs-keyword\">if</span> (options.optimize !== <span class=\"hljs-literal\">false</span>) &#123;<br>    <span class=\"hljs-comment\">// 优化阶段：遍历AST，找出其中的静态节点，并打上标记；</span><br>    optimize(ast, options)<br>  &#125;<br>  <span class=\"hljs-comment\">// 代码生成阶段：将AST转换成渲染函数；</span><br>  <span class=\"hljs-keyword\">const</span> code = generate(ast, options)<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    ast,<br>    render: code.render,<br>    staticRenderFns: code.staticRenderFns<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>可以看到 <code>baseCompile</code> 的代码非常的简短主要核心代码。</p>\n<ul>\n<li><strong>const ast =parse(template.trim(), options)</strong>:<code>parse</code> 会用正则等方式解析 <code>template</code> 模板中的指令、<code>class</code>、<code>style</code>等数据，形成<code>AST</code>。</li>\n<li><strong>optimize(ast, options)</strong>: <code>optimize</code> 的主要作用是标记静态节点，这是 <code>Vue</code> 在编译过程中的一处优化，挡在进行<code>patch</code> 的过程中， <code>DOM-Diff</code> 算法会直接跳过静态节点，从而减少了比较的过程，优化了 <code>patch</code> 的性能。</li>\n<li><strong>const code =generate(ast, options)</strong>: 将 <code>AST</code> 转化成 <code>render</code>函数字符串的过程，得到结果是 <code>render</code>函数 的字符串以及 <code>staticRenderFns</code> 字符串。</li>\n</ul>\n<p>最终 <code>baseCompile</code> 的返回值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&#123;<br> \tast: ast,<br> \trender: code.render,<br> \tstaticRenderFns: code.staticRenderFns<br> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>最终返回了抽象语法树( ast )，渲染函数( render )，静态渲染函数( staticRenderFns )，且<code>render</code> 的值为<code>code.render</code>，<code>staticRenderFns</code> 的值为<code>code.staticRenderFns</code>，也就是说通过 <code>generate</code>处理 <code>ast</code>之后得到的返回值 <code>code</code> 是一个对象。</p>\n<p>下面再给出模板编译内部具体流程图，便于理解。流程图如下： <img src=\"https://vue-js.com/learn-vue/assets/img/3.15d9566b.png\" alt=\"img\"></p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>本篇文章首先引出了为什么会有模板编译，因为有了模板编译，才有了虚拟<code>DOM</code>，才有了后续的视图更新。接着介绍了什么是模板编译，以及介绍了把用户所写的模板经过层层处理直到最终渲染的视图中这个整体的渲染流程；最后介绍了模板编译过程中所需要使用的抽象语法树的概念以及分析了模板编译的具体实施流程，其流程大致分为三个阶段，分别是模板解析阶段、优化阶段和代码生成阶段。那么接下来的几篇文章将会把这三个阶段逐一进行分析介绍。</p>\n<h5 id=\"1-整体流程\"><a href=\"#1-整体流程\" class=\"headerlink\" title=\"1. 整体流程\"></a>1. 整体流程</h5><p>上篇文章中我们说了，在模板解析阶段主要做的工作是把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签内写的模板使用正则等方式解析成抽象语法树（<code>AST</code>）。而这一阶段在源码中对应解析器（<code>parser</code>）模块。</p>\n<p>解析器，顾名思义，就是把用户所写的模板根据一定的解析规则解析出有效的信息，最后用这些信息形成<code>AST</code>。我们知道在<code>&lt;template&gt;&lt;/template&gt;</code>模板内，除了有常规的<code>HTML</code>标签外，用户还会一些文本信息以及在文本信息中包含过滤器。而这些不同的内容在解析起来肯定需要不同的解析规则，所以解析器不可能只有一个，它应该除了有解析常规<code>HTML</code>的HTML解析器，还应该有解析文本的文本解析器以及解析文本中如果包含过滤器的过滤器解析器。</p>\n<p>另外，文本信息和标签属性信息却又是存在于HTML标签之内的，所以在解析整个模板的时候它的流程应该是这样子的：HTML解析器是主线，先用HTML解析器进行解析整个模板，在解析过程中如果碰到文本内容，那就调用文本解析器来解析文本，如果碰到文本中包含过滤器那就调用过滤器解析器来解析。如下图所示：</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210428165451685.png\" alt=\"image-20210428165451685\"></p>\n<h5 id=\"2-回到源码\"><a href=\"#2-回到源码\" class=\"headerlink\" title=\"2. 回到源码\"></a>2. 回到源码</h5><p>解析器的源码位于<code>/src/complier/parser</code>文件夹下，其主线代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 代码位置：/src/complier/parser/index.js</span><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Convert HTML string to AST.</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">parse</span>(<span class=\"hljs-params\">template, options</span>) </span>&#123;<br>   <span class=\"hljs-comment\">// ...</span><br>  parseHTML(template, &#123;<br>    warn,<br>    expectHTML: options.expectHTML,<br>    isUnaryTag: options.isUnaryTag,<br>    canBeLeftOpenTag: options.canBeLeftOpenTag,<br>    shouldDecodeNewlines: options.shouldDecodeNewlines,<br>    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,<br>    shouldKeepComment: options.comments,<br>    start (tag, attrs, unary) &#123;<br><br>    &#125;,<br>    end () &#123;<br><br>    &#125;,<br>    chars (text: string) &#123;<br><br>    &#125;,<br>    comment (text: string) &#123;<br><br>    &#125;<br>  &#125;)<br>  <span class=\"hljs-keyword\">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从上面代码中可以看到，<code>parse</code> 函数就是解析器的主函数，在<code>parse</code> 函数内调用了<code>parseHTML</code> 函数对模板字符串进行解析，在<code>parseHTML</code> 函数解析模板字符串的过程中，如果遇到文本信息，就会调用文本解析器<code>parseText</code>函数进行文本解析；如果遇到文本中包含过滤器，就会调用过滤器解析器<code>parseFilters</code>函数进行解析。</p>\n<h5 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h5><p>本篇文章主要梳理了模板解析的整体运行流程，模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为HTML解析器，文本解析器和过滤器解析器。而文本信息与过滤器信息又存在于HTML标签中，所以在解析器主线函数<code>parse</code>中先调用HTML解析器<code>parseHTML</code> 函数对模板字符串进行解析，如果在解析过程中遇到文本或过滤器信息则再调用相应的解析器进行解析，最终完成对整个模板字符串的解析。</p>\n<p>了解了模板解析阶段的整体运行流程后，接下来，我们就对流程中所涉及到的三种解析器分别深入分析，逐个击破。</p>\n<p>上篇文章中我们说到，在模板解析阶段主线函数<code>parse</code>中，根据要解析的内容不同会调用不同的解析器，</p>\n<p>而在三个不同的解析器中最主要的当属<code>HTML</code>解析器，为什么这么说呢？因为<code>HTML</code>解析器主要负责解析出模板字符串中有哪些内容，然后根据不同的内容才能调用其他的解析器以及做相应的处理。那么本篇文章就来介绍一下<code>HTML</code>解析器是如何解析出模板字符串中包含的不同的内容的。</p>\n<h5 id=\"解析器内部运行流程\"><a href=\"#解析器内部运行流程\" class=\"headerlink\" title=\"解析器内部运行流程\"></a>解析器内部运行流程</h5><h5 id=\"2-HTML解析器内部运行流程\"><a href=\"#2-HTML解析器内部运行流程\" class=\"headerlink\" title=\"2. HTML解析器内部运行流程\"></a>2. HTML解析器内部运行流程</h5><p>在源码中，<code>HTML</code>解析器就是<code>parseHTML</code>函数，在模板解析主线函数<code>parse</code>中调用了该函数，并传入两个参数，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 代码位置：/src/complier/parser/index.js</span><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Convert HTML string to AST.</span><br><span class=\"hljs-comment\"> * 将HTML模板字符串转化为AST</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">parse</span>(<span class=\"hljs-params\">template, options</span>) </span>&#123;<br>   <span class=\"hljs-comment\">// ...</span><br>  parseHTML(template, &#123;<br>    warn,<br>    expectHTML: options.expectHTML,<br>    isUnaryTag: options.isUnaryTag,<br>    canBeLeftOpenTag: options.canBeLeftOpenTag,<br>    shouldDecodeNewlines: options.shouldDecodeNewlines,<br>    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,<br>    shouldKeepComment: options.comments,<br>    <span class=\"hljs-comment\">// 当解析到开始标签时，调用该函数</span><br>    start (tag, attrs, unary) &#123;<br><br>    &#125;,<br>    <span class=\"hljs-comment\">// 当解析到结束标签时，调用该函数</span><br>    end () &#123;<br><br>    &#125;,<br>    <span class=\"hljs-comment\">// 当解析到文本时，调用该函数</span><br>    chars (text) &#123;<br><br>    &#125;,<br>    <span class=\"hljs-comment\">// 当解析到注释时，调用该函数</span><br>    comment (text) &#123;<br><br>    &#125;<br>  &#125;)<br>  <span class=\"hljs-keyword\">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从代码中我们可以看到，调用<code>parseHTML</code>函数时为其传入的两个参数分别是：</p>\n<ul>\n<li>template:待转换的模板字符串；</li>\n<li>options:转换时所需的选项；</li>\n</ul>\n<p>第一个参数是待转换的模板字符串，无需多言；重点看第二个参数，第二个参数提供了一些解析<code>HTML</code>模板时的一些参数，同时还定义了4个钩子函数。这4个钩子函数有什么作用呢？我们说了模板编译阶段主线函数<code>parse</code>会将<code>HTML</code>模板字符串转化成<code>AST</code>，而<code>parseHTML</code>是用来解析模板字符串的，把模板字符串中不同的内容出来之后，那么谁来把提取出来的内容生成对应的<code>AST</code>呢？答案就是这4个钩子函数。</p>\n<p>把这4个钩子函数作为参数传给解析器<code>parseHTML</code>，当解析器解析出不同的内容时调用不同的钩子函数从而生成不同的<code>AST</code>。</p>\n<p>当解析到开始标签时调用<code>start</code>函数生成元素类型的<code>AST</code>节点，代码如下；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 当解析到标签的开始位置时，触发start</span><br>start (tag, attrs, unary) &#123;<br>\t<span class=\"hljs-keyword\">let</span> element = createASTElement(tag, attrs, currentParent)<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createASTElement</span> (<span class=\"hljs-params\">tag,attrs,parent</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    type: <span class=\"hljs-number\">1</span>,<br>    tag,<br>    attrsList: attrs,<br>    attrsMap: makeAttrsMap(attrs),<br>    parent,<br>    children: []<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>从上面代码中我们可以看到，<code>start</code>函数接收三个参数，分别是标签名<code>tag</code>、标签属性<code>attrs</code>、标签是否自闭合<code>unary</code>。当调用该钩子函数时，内部会调用<code>createASTElement</code>函数来创建元素类型的<code>AST</code>节点</li>\n<li>当解析到结束标签时调用<code>end</code>函数；</li>\n<li>当解析到文本时调用<code>chars</code>函数生成文本类型的<code>AST</code>节点；</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 当解析到标签的文本时，触发chars</span><br>chars (text) &#123;<br>\t<span class=\"hljs-keyword\">if</span>(text是带变量的动态文本)&#123;<br>    <span class=\"hljs-keyword\">let</span> element = &#123;<br>      type: <span class=\"hljs-number\">2</span>,<br>      expression: res.expression,<br>      tokens: res.tokens,<br>      text<br>    &#125;<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> element = &#123;<br>      type: <span class=\"hljs-number\">3</span>,<br>      text<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>当解析到标签的文本时，触发<code>chars</code>钩子函数，在该钩子函数内部，首先会判断文本是不是一个带变量的动态文本，如“hello ”。如果是动态文本，则创建动态文本类型的<code>AST</code>节点；如果不是动态文本，则创建纯静态文本类型的<code>AST</code>节点。</li>\n<li>当解析到注释时调用<code>comment</code>函数生成注释类型的<code>AST</code>节点；</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/ 当解析到标签的注释时，触发comment<br>comment (text: string) &#123;<br>  <span class=\"hljs-keyword\">let</span> element = &#123;<br>    type: <span class=\"hljs-number\">3</span>,<br>    text,<br>    isComment: <span class=\"hljs-literal\">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>当解析到标签的注释时，触发<code>comment</code>钩子函数，该钩子函数会创建一个注释类型的<code>AST</code>节点。</li>\n</ul>\n<p>一边解析不同的内容一边调用对应的钩子函数生成对应的<code>AST</code>节点，最终完成将整个模板字符串转化成<code>AST</code>,这就是<code>HTML</code>解析器所要做的工作。</p>\n<h5 id=\"3-如何解析不同的内容\"><a href=\"#3-如何解析不同的内容\" class=\"headerlink\" title=\"3. 如何解析不同的内容\"></a>3. 如何解析不同的内容</h5><p>要从模板字符串中解析出不同的内容，那首先要知道模板字符串中都会包含哪些内容。那么通常我们所写的模板字符串中都会包含哪些内容呢？经过整理，通常模板内会包含如下内容：</p>\n<ul>\n<li>文本，例如“难凉热血”</li>\n<li>HTML注释，例如<!-- 我是注释 --></li>\n<li>条件注释，例如<!-- [if !IE]> -->我是注释<!--< ![endif] --></li>\n<li>DOCTYPE，例如<!DOCTYPE html></li>\n<li>开始标签，例如<div></li>\n<li>结束标签，例如</div></li>\n</ul>\n<p>这几种内容都有其各自独有的特点，也就是说我们要根据不同内容所具有的不同的的特点通过编写不同的正则表达式将这些内容从模板字符串中一一解析出来，然后再把不同的内容做不同的处理。</p>\n<p>下面，我们就来分别看一下<code>HTML</code>解析器是如何从模板字符串中将以上不同种类的内容进行解析出来。</p>\n<h5 id=\"3-1-解析HTML注释\"><a href=\"#3-1-解析HTML注释\" class=\"headerlink\" title=\"3.1 解析HTML注释\"></a>3.1 解析HTML注释</h5><p>解析注释比较简单，我们知道<code>HTML</code>注释是以<code>&lt;!--</code>开头，以<code>--&gt;</code>结尾，这两者中间的内容就是注释内容，那么我们只需用正则判断待解析的模板字符串<code>html</code>是否以<code>&lt;!--</code>开头，若是，那就继续向后寻找<code>--&gt;</code>，如果找到了，OK，注释就被解析出来了。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> comment = <span class=\"hljs-regexp\">/^&lt;!\\--/</span><br><span class=\"hljs-keyword\">if</span> (comment.test(html)) &#123;<br>  <span class=\"hljs-comment\">// 若为注释，则继续查找是否存在&#x27;--&gt;&#x27;</span><br>  <span class=\"hljs-keyword\">const</span> commentEnd = html.indexOf(<span class=\"hljs-string\">&#x27;--&gt;&#x27;</span>)<br><br>  <span class=\"hljs-keyword\">if</span> (commentEnd &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>    <span class=\"hljs-comment\">// 若存在 &#x27;--&gt;&#x27;,继续判断options中是否保留注释</span><br>    <span class=\"hljs-keyword\">if</span> (options.shouldKeepComment) &#123;<br>      <span class=\"hljs-comment\">// 若保留注释，则把注释截取出来传给options.comment，创建注释类型的AST节点</span><br>      options.comment(html.substring(<span class=\"hljs-number\">4</span>, commentEnd))<br>    &#125;<br>    <span class=\"hljs-comment\">// 若不保留注释，则将游标移动到&#x27;--&gt;&#x27;之后，继续向后解析</span><br>    advance(commentEnd + <span class=\"hljs-number\">3</span>)<br>    <span class=\"hljs-keyword\">continue</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面代码中，如果模板字符串<code>html</code>符合注释开始的正则，那么就继续向后查找是否存在<code>--&gt;</code>，若存在，则把<code>html</code>从第4位（”<!--\"长度为4）开始截取，直到`--><code>处，截取得到的内容就是注释的真实内容，然后调用4个钩子函数中的</code>comment<code>函数，将真实的注释内容传进去，创建注释类型的</code>AST`节点。</p>\n<p>上面代码中有一处值得注意的地方，那就是我们平常在模板中可以在<code>&lt;template&gt;&lt;/template&gt;</code>标签上配置<code>comments</code>选项来决定在渲染模板时是否保留注释，对应到上面代码中就是<code>options.shouldKeepComment</code>,如果用户配置了<code>comments</code>选项为<code>true</code>，则<code>shouldKeepComment</code>为<code>true</code>，则创建注释类型的<code>AST</code>节点，如不保留注释，则将游标移动到’–&gt;’之后，继续向后解析。</p>\n<p><code>advance</code>函数是用来移动解析游标的，解析完一部分就把游标向后移动一部分，确保不会重复解析，其代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">advance</span> (<span class=\"hljs-params\">n</span>) </span>&#123;<br>  index += n   <span class=\"hljs-comment\">// index为解析游标</span><br>  html = html.substring(n)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210428171551449.png\" alt=\"image-20210428171551449\"></p>\n<p>调用 <code>advance</code> 函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">advance(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210428171638566.png\" alt=\"image-20210428171638566\"></p>\n<p>从图中可以看到，解析游标<code>index</code>最开始在模板字符串的位置0处，当调用了<code>advance(3)</code>之后，解析游标到了位置3处，每次解析完一段内容就将游标向后移动一段，接着再从解析游标往后解析，这样就保证了解析过的内容不会被重复解析。</p>\n<h5 id=\"3-2-解析条件注释\"><a href=\"#3-2-解析条件注释\" class=\"headerlink\" title=\"3.2 解析条件注释\"></a>3.2 解析条件注释</h5><p>解析条件注释也比较简单，其原理跟解析注释相同，都是先用正则判断是否是以条件注释特有的开头标识开始，然后寻找其特有的结束标识，若找到，则说明是条件注释，将其截取出来即可，由于条件注释不存在于真正的<code>DOM</code>树中，所以不需要调用钩子函数创建<code>AST</code>节点。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 解析是否是条件注释</span><br><span class=\"hljs-keyword\">const</span> conditionalComment = <span class=\"hljs-regexp\">/^&lt;!\\[/</span><br><span class=\"hljs-keyword\">if</span> (conditionalComment.test(html)) &#123;<br>  <span class=\"hljs-comment\">// 若为条件注释，则继续查找是否存在&#x27;]&gt;&#x27;</span><br>  <span class=\"hljs-keyword\">const</span> conditionalEnd = html.indexOf(<span class=\"hljs-string\">&#x27;]&gt;&#x27;</span>)<br><br>  <span class=\"hljs-keyword\">if</span> (conditionalEnd &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>    <span class=\"hljs-comment\">// 若存在 &#x27;]&gt;&#x27;,则从原本的html字符串中把条件注释截掉，</span><br>    <span class=\"hljs-comment\">// 把剩下的内容重新赋给html，继续向后匹配</span><br>    advance(conditionalEnd + <span class=\"hljs-number\">2</span>)<br>    <span class=\"hljs-keyword\">continue</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"3-3-解析DOCTYPE\"><a href=\"#3-3-解析DOCTYPE\" class=\"headerlink\" title=\"3.3 解析DOCTYPE\"></a>3.3 解析DOCTYPE</h5><p>解析<code>DOCTYPE</code>的原理同解析条件注释完全相同，此处不再赘述，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> doctype = <span class=\"hljs-regexp\">/^&lt;!DOCTYPE [^&gt;]+&gt;/i</span><br><span class=\"hljs-comment\">// 解析是否是DOCTYPE</span><br><span class=\"hljs-keyword\">const</span> doctypeMatch = html.match(doctype)<br><span class=\"hljs-keyword\">if</span> (doctypeMatch) &#123;<br>  advance(doctypeMatch[<span class=\"hljs-number\">0</span>].length)<br>  <span class=\"hljs-keyword\">continue</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"3-4-解析开始标签\"><a href=\"#3-4-解析开始标签\" class=\"headerlink\" title=\"3.4 解析开始标签\"></a>3.4 解析开始标签</h5><p>相较于前三种内容的解析，解析开始标签会稍微复杂一点，但是万变不离其宗，它的原理还是相通的，都是使用正则去匹配提取。</p>\n<p>首先使用开始标签的正则去匹配模板字符串，看模板字符串是否具有开始标签的特征，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 匹配开始标签的正则</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">const</span> ncname = <span class=\"hljs-string\">&#x27;[a-zA-Z_][\\\\w\\\\-\\\\.]*&#x27;</span><br><span class=\"hljs-keyword\">const</span> qnameCapture = <span class=\"hljs-string\">`((?:<span class=\"hljs-subst\">$&#123;ncname&#125;</span>\\\\:)?<span class=\"hljs-subst\">$&#123;ncname&#125;</span>)`</span><br><span class=\"hljs-keyword\">const</span> startTagOpen = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">RegExp</span>(<span class=\"hljs-string\">`^&lt;<span class=\"hljs-subst\">$&#123;qnameCapture&#125;</span>`</span>)<br><br><span class=\"hljs-keyword\">const</span> start = html.match(startTagOpen)<br><span class=\"hljs-keyword\">if</span> (start) &#123;<br>  <span class=\"hljs-keyword\">const</span> match = &#123;<br>    tagName: start[<span class=\"hljs-number\">1</span>],<br>    attrs: [],<br>    start: index<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 以开始标签开始的模板：</span><br><span class=\"hljs-string\">&#x27;&lt;div&gt;&lt;/div&gt;&#x27;</span>.match(startTagOpen)  =&gt; [<span class=\"hljs-string\">&#x27;&lt;div&#x27;</span>,<span class=\"hljs-string\">&#x27;div&#x27;</span>,<span class=\"hljs-attr\">index</span>:<span class=\"hljs-number\">0</span>,<span class=\"hljs-attr\">input</span>:<span class=\"hljs-string\">&#x27;&lt;div&gt;&lt;/div&gt;&#x27;</span>]<br><span class=\"hljs-comment\">// 以结束标签开始的模板：</span><br><span class=\"hljs-string\">&#x27;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&#x27;</span>.match(startTagOpen) =&gt; <span class=\"hljs-literal\">null</span><br><span class=\"hljs-comment\">// 以文本开始的模板：</span><br><span class=\"hljs-string\">&#x27;我是文本&lt;/p&gt;&#x27;</span>.match(startTagOpen) =&gt; <span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n\n<p>在上面代码中，我们用不同类型的内容去匹配开始标签的正则，发现只有<code>&lt;div&gt;&lt;/div&gt;</code>的字符串可以正确匹配，并且返回一个数组。</p>\n<p>在前文中我们说到，当解析到开始标签时，会调用4个钩子函数中的<code>start</code>函数，而<code>start</code>函数需要传递3个参数，分别是标签名<code>tag</code>、标签属性<code>attrs</code>、标签是否自闭合<code>unary</code>。标签名通过正则匹配的结果就可以拿到，即上面代码中的<code>start[1]</code>，而标签属性<code>attrs</code>以及标签是否自闭合<code>unary</code>需要进一步解析。</p>\n<p>解析标签属性</p>\n<p>我们知道，标签属性一般是写在开始标签的标签名之后的，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;a&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;b&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>另外，我们在上面匹配是否是开始标签的正则中已经可以拿到开始标签的标签名，即上面代码中的<code>start[0]</code>，那么我们可以将这一部分先从模板字符串中截掉，则剩下的部分如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">class=&quot;a&quot; id=&quot;b&quot;&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>那么我们只需用剩下的这部分去匹配标签属性的正则，就可以将标签属性提取出来了，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> ncname = <span class=\"hljs-string\">&#x27;[a-zA-Z_][\\\\w\\\\-\\\\.]*&#x27;</span><br><span class=\"hljs-keyword\">const</span> qnameCapture = <span class=\"hljs-string\">`((?:<span class=\"hljs-subst\">$&#123;ncname&#125;</span>\\\\:)?<span class=\"hljs-subst\">$&#123;ncname&#125;</span>)`</span><br><span class=\"hljs-keyword\">const</span> endTag = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">RegExp</span>(<span class=\"hljs-string\">`^&lt;\\\\/<span class=\"hljs-subst\">$&#123;qnameCapture&#125;</span>[^&gt;]*&gt;`</span>)<br><span class=\"hljs-keyword\">const</span> endTagMatch = html.match(endTag)<br><br><span class=\"hljs-string\">&#x27;&lt;/div&gt;&#x27;</span>.match(endTag)  <span class=\"hljs-comment\">// [&quot;&lt;/div&gt;&quot;, &quot;div&quot;, index: 0, input: &quot;&lt;/div&gt;&quot;, groups: undefined]</span><br><span class=\"hljs-string\">&#x27;&lt;div&gt;&#x27;</span>.match(endTag)  <span class=\"hljs-comment\">// null</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，如果模板字符串符合结束标签的特征，则会获得匹配结果数组；如果不合符，则得到null。</p>\n<p>接着再调用<code>end</code>钩子函数，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">if</span> (endTagMatch) &#123;<br>    <span class=\"hljs-keyword\">const</span> curIndex = index<br>    advance(endTagMatch[<span class=\"hljs-number\">0</span>].length)<br>    parseEndTag(endTagMatch[<span class=\"hljs-number\">1</span>], curIndex, index)<br>    <span class=\"hljs-keyword\">continue</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面代码中，没有直接去调用<code>end</code>函数，而是调用了<code>parseEndTag</code>函数，关于<code>parseEndTag</code>函数内部的作用我们后面会介绍到，在这里你暂时可以理解为该函数内部就是去调用了<code>end</code>钩子函数。</p>\n<h5 id=\"3-6-解析文本\"><a href=\"#3-6-解析文本\" class=\"headerlink\" title=\"3.6 解析文本\"></a>3.6 解析文本</h5><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">终于到了解析最后一种文本类型的内容了，为什么要把解析文本类型放在最后一个介绍呢？我们仔细想一下，前面五种类型都是以`&lt;`开头的，只有文本类型的内容不是以`&lt;`开头的，所以我们在解析模板字符串的时候可以先判断一下字符串是不是以`&lt;`开头的，如果是则继续判断是以上五种类型的具体哪一种，而如果不是的话，那它肯定就是文本了。<br></code></pre></td></tr></table></figure>\n\n<p>解析文本也比较容易，在解析模板字符串之前，我们先查找一下第一个<code>&lt;</code>出现在什么位置，如果第一个<code>&lt;</code>在第一个位置，那么说明模板字符串是以其它5种类型开始的；如果第一个<code>&lt;</code>不在第一个位置而在模板字符串中间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个<code>&lt;</code>出现的位置就都是文本内容了；如果在整个模板字符串里没有找到<code>&lt;</code>，那说明整个模板字符串都是文本。这就是解析思路，接下来我们对照源码来了解一下实际的解析过程，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> textEnd = html.indexOf(<span class=\"hljs-string\">&#x27;&lt;&#x27;</span>)<br><span class=\"hljs-comment\">// &#x27;&lt;&#x27; 在第一个位置，为其余5种类型</span><br><span class=\"hljs-keyword\">if</span> (textEnd === <span class=\"hljs-number\">0</span>) &#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br><span class=\"hljs-comment\">// &#x27;&lt;&#x27; 不在第一个位置，文本开头</span><br><span class=\"hljs-keyword\">if</span> (textEnd &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>    <span class=\"hljs-comment\">// 如果html字符串不是以&#x27;&lt;&#x27;开头,说明&#x27;&lt;&#x27;前面的都是纯文本，无需处理</span><br>    <span class=\"hljs-comment\">// 那就把&#x27;&lt;&#x27;以后的内容拿出来赋给rest</span><br>    rest = html.slice(textEnd)<br>    <span class=\"hljs-keyword\">while</span> (<br>        !endTag.test(rest) &amp;&amp;<br>        !startTagOpen.test(rest) &amp;&amp;<br>        !comment.test(rest) &amp;&amp;<br>        !conditionalComment.test(rest)<br>    ) &#123;<br>        <span class=\"hljs-comment\">// &lt; in plain text, be forgiving and treat it as text</span><br>        <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">           * 用&#x27;&lt;&#x27;以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment</span><br><span class=\"hljs-comment\">           * 如果都匹配不上，表示&#x27;&lt;&#x27;是属于文本本身的内容</span><br><span class=\"hljs-comment\">           */</span><br>        <span class=\"hljs-comment\">// 在&#x27;&lt;&#x27;之后查找是否还有&#x27;&lt;&#x27;</span><br>        next = rest.indexOf(<span class=\"hljs-string\">&#x27;&lt;&#x27;</span>, <span class=\"hljs-number\">1</span>)<br>        <span class=\"hljs-comment\">// 如果没有了，表示&#x27;&lt;&#x27;后面也是文本</span><br>        <span class=\"hljs-keyword\">if</span> (next &lt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">break</span><br>        <span class=\"hljs-comment\">// 如果还有，表示&#x27;&lt;&#x27;是文本中的一个字符</span><br>        textEnd += next<br>        <span class=\"hljs-comment\">// 那就把next之后的内容截出来继续下一轮循环匹配</span><br>        rest = html.slice(textEnd)<br>    &#125;<br>    <span class=\"hljs-comment\">// &#x27;&lt;&#x27;是结束标签的开始 ,说明从开始到&#x27;&lt;&#x27;都是文本，截取出来</span><br>    text = html.substring(<span class=\"hljs-number\">0</span>, textEnd)<br>    advance(textEnd)<br>&#125;<br><span class=\"hljs-comment\">// 整个模板字符串里没有找到`&lt;`,说明整个模板字符串都是文本</span><br><span class=\"hljs-keyword\">if</span> (textEnd &lt; <span class=\"hljs-number\">0</span>) &#123;<br>    text = html<br>    html = <span class=\"hljs-string\">&#x27;&#x27;</span><br>&#125;<br><span class=\"hljs-comment\">// 把截取出来的text转化成textAST</span><br><span class=\"hljs-keyword\">if</span> (options.chars &amp;&amp; text) &#123;<br>    options.chars(text)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>源码的逻辑很清晰，根据<code>&lt;</code>在不在第一个位置以及整个模板字符串里没有<code>&lt;</code>都分别进行了处理。</p>\n<p>值得深究的是如果<code>&lt;</code>不在第一个位置而在模板字符串中间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个<code>&lt;</code>出现的位置就都是文本内容了，接着我们还要从第一个<code>&lt;</code>的位置继续向后判断，因为还存在这样一种情况，那就是如果文本里面本来就包含一个<code>&lt;</code>，例如<code>1&lt;2&lt;/div&gt;</code>。为了处理这种情况，我们把从第一个<code>&lt;</code>的位置直到模板字符串结束都截取出来记作<code>rest</code>，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> rest = html.slice(textEnd)<br></code></pre></td></tr></table></figure>\n\n<p>接着用<code>rest</code>去匹配以上5种类型的正则，如果都匹配不上，则表明这个<code>&lt;</code>是属于文本本身的内容，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">while</span> (<br>    !endTag.test(rest) &amp;&amp;<br>    !startTagOpen.test(rest) &amp;&amp;<br>    !comment.test(rest) &amp;&amp;<br>    !conditionalComment.test(rest)<br>) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果都匹配不上，则表明这个<code>&lt;</code>是属于文本本身的内容，接着以这个<code>&lt;</code>的位置继续向后查找，看是否还有<code>&lt;</code>，如果没有了，则表示后面的都是文本；如果后面还有下一个<code>&lt;</code>，那表明至少在这个<code>&lt;</code>到下一个<code>&lt;</code>中间的内容都是文本，至于下一个<code>&lt;</code>以后的内容是什么，则还需要重复以上的逻辑继续判断。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">while</span> (<br>    !endTag.test(rest) &amp;&amp;<br>    !startTagOpen.test(rest) &amp;&amp;<br>    !comment.test(rest) &amp;&amp;<br>    !conditionalComment.test(rest)<br>) &#123;<br>    <span class=\"hljs-comment\">// &lt; in plain text, be forgiving and treat it as text</span><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">    * 用&#x27;&lt;&#x27;以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment</span><br><span class=\"hljs-comment\">    * 如果都匹配不上，表示&#x27;&lt;&#x27;是属于文本本身的内容</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-comment\">// 在&#x27;&lt;&#x27;之后查找是否还有&#x27;&lt;&#x27;</span><br>    next = rest.indexOf(<span class=\"hljs-string\">&#x27;&lt;&#x27;</span>, <span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-comment\">// 如果没有了，表示&#x27;&lt;&#x27;后面也是文本</span><br>    <span class=\"hljs-keyword\">if</span> (next &lt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">break</span><br>    <span class=\"hljs-comment\">// 如果还有，表示&#x27;&lt;&#x27;是文本中的一个字符</span><br>    textEnd += next<br>    <span class=\"hljs-comment\">// 那就把next之后的内容截出来继续下一轮循环匹配</span><br>    rest = html.slice(textEnd)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>最后截取文本内容<code>text</code>并调用4个钩子函数中的<code>chars</code>函数创建文本型的<code>AST</code>节点。</p>\n<h5 id=\"4-如何保证AST节点层级关系\"><a href=\"#4-如何保证AST节点层级关系\" class=\"headerlink\" title=\"4. 如何保证AST节点层级关系\"></a>4. 如何保证AST节点层级关系</h5><p>上一章节我们介绍了<code>HTML</code>解析器是如何解析各种不同类型的内容并且调用钩子函数创建不同类型的<code>AST</code>节点。此时你可能会有个疑问，我们上面创建的<code>AST</code>节点都是单独创建且分散的，而真正的<code>DOM</code>节点都是有层级关系的，那如何来保证<code>AST</code>节点的层级关系与真正的<code>DOM</code>节点相同呢？</p>\n<p>关于这个问题，<code>Vue</code>也注意到了。<code>Vue</code>在<code>HTML</code>解析器的开头定义了一个栈<code>stack</code>，这个栈的作用就是用来维护<code>AST</code>节点层级的，那么它是怎么维护的呢？通过前文我们知道，<code>HTML</code>解析器在从前向后解析模板字符串时，每当遇到开始标签时就会调用<code>start</code>钩子函数，那么在<code>start</code>钩子函数内部我们可以将解析得到的开始标签推入栈中，而每当遇到结束标签时就会调用<code>end</code>钩子函数，那么我们也可以在<code>end</code>钩子函数内部将解析得到的结束标签所对应的开始标签从栈中弹出。请看如下例子：</p>\n<p>假如有如下模板字符串：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>当解析到开始标签<code>&lt;div&gt;</code>时，就把<code>div</code>推入栈中，然后继续解析，当解析到<code>&lt;p&gt;</code>时，再把<code>p</code>推入栈中，同理，再把<code>span</code>推入栈中，当解析到结束标签<code>&lt;/span&gt;</code>时，此时栈顶的标签刚好是<code>span</code>的开始标签，那么就用<code>span</code>的开始标签和结束标签构建<code>AST</code>节点，并且从栈中把<code>span</code>的开始标签弹出，那么此时栈中的栈顶标签<code>p</code>就是构建好的<code>span</code>的<code>AST</code>节点的父节点，如下图：</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210428173344529.png\" alt=\"image-20210428173344529\"></p>\n<p>这样我们就找到了当前被构建节点的父节点。这只是栈的一个用途，它还有另外一个用途，我们再看如下模板字符串：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>按照上面的流程解析这个模板字符串时，当解析到结束标签<code>&lt;/p&gt;</code>时，此时栈顶的标签应该是<code>p</code>才对，而现在是<code>span</code>，那么就说明<code>span</code>标签没有被正确闭合，此时控制台就会抛出警告：‘tag has no matching end tag.’相信这个警告你一定不会陌生。这就是栈的第二个用途： 检测模板字符串中是否有未正确闭合的标签。</p>\n<p>OK，有了这个栈的概念之后，我们再回看上一章<code>HTML</code>解析器解析不同内容的代码。</p>\n<h5 id=\"5-回归源码\"><a href=\"#5-回归源码\" class=\"headerlink\" title=\"5. 回归源码\"></a>5. 回归源码</h5><h6 id=\"5-1-HTML解析器源码\"><a href=\"#5-1-HTML解析器源码\" class=\"headerlink\" title=\"5.1 HTML解析器源码\"></a>5.1 HTML解析器源码</h6><p>以上内容都了解了之后，我们回归源码，逐句分析<code>HTML</code>解析器<code>parseHTML</code>函数，函数定义如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">parseHTML</span>(<span class=\"hljs-params\">html, options</span>) </span>&#123;<br>\t<span class=\"hljs-keyword\">var</span> stack = [];<br>\t<span class=\"hljs-keyword\">var</span> expectHTML = options.expectHTML;<br>\t<span class=\"hljs-keyword\">var</span> isUnaryTag$$<span class=\"hljs-number\">1</span> = options.isUnaryTag || no;<br>\t<span class=\"hljs-keyword\">var</span> canBeLeftOpenTag$$<span class=\"hljs-number\">1</span> = options.canBeLeftOpenTag || no;<br>\t<span class=\"hljs-keyword\">var</span> index = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">var</span> last, lastTag;<br><br>\t<span class=\"hljs-comment\">// 开启一个 while 循环，循环结束的条件是 html 为空，即 html 被 parse 完毕</span><br>\t<span class=\"hljs-keyword\">while</span> (html) &#123;<br>\t\tlast = html;<br>\t\t<span class=\"hljs-comment\">// 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)</span><br>\t\t<span class=\"hljs-keyword\">if</span> (!lastTag || !isPlainTextElement(lastTag)) &#123;<br>\t\t   <span class=\"hljs-keyword\">let</span> textEnd = html.indexOf(<span class=\"hljs-string\">&#x27;&lt;&#x27;</span>)<br>              <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">               * 如果html字符串是以&#x27;&lt;&#x27;开头,则有以下几种可能</span><br><span class=\"hljs-comment\">               * 开始标签:&lt;div&gt;</span><br><span class=\"hljs-comment\">               * 结束标签:&lt;/div&gt;</span><br><span class=\"hljs-comment\">               * 注释:&lt;!-- 我是注释 --&gt;</span><br><span class=\"hljs-comment\">               * 条件注释:&lt;!-- [if !IE] --&gt; &lt;!-- [endif] --&gt;</span><br><span class=\"hljs-comment\">               * DOCTYPE:&lt;!DOCTYPE html&gt;</span><br><span class=\"hljs-comment\">               * 需要一一去匹配尝试</span><br><span class=\"hljs-comment\">               */</span><br>            <span class=\"hljs-keyword\">if</span> (textEnd === <span class=\"hljs-number\">0</span>) &#123;<br>                <span class=\"hljs-comment\">// 解析是否是注释</span><br>        \t\t<span class=\"hljs-keyword\">if</span> (comment.test(html)) &#123;<br><br>                &#125;<br>                <span class=\"hljs-comment\">// 解析是否是条件注释</span><br>                <span class=\"hljs-keyword\">if</span> (conditionalComment.test(html)) &#123;<br><br>                &#125;<br>                <span class=\"hljs-comment\">// 解析是否是DOCTYPE</span><br>                <span class=\"hljs-keyword\">const</span> doctypeMatch = html.match(doctype)<br>                <span class=\"hljs-keyword\">if</span> (doctypeMatch) &#123;<br><br>                &#125;<br>                <span class=\"hljs-comment\">// 解析是否是结束标签</span><br>                <span class=\"hljs-keyword\">const</span> endTagMatch = html.match(endTag)<br>                <span class=\"hljs-keyword\">if</span> (endTagMatch) &#123;<br><br>                &#125;<br>                <span class=\"hljs-comment\">// 匹配是否是开始标签</span><br>                <span class=\"hljs-keyword\">const</span> startTagMatch = parseStartTag()<br>                <span class=\"hljs-keyword\">if</span> (startTagMatch) &#123;<br><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-comment\">// 如果html字符串不是以&#x27;&lt;&#x27;开头,则解析文本类型</span><br>            <span class=\"hljs-keyword\">let</span> text, rest, next<br>            <span class=\"hljs-keyword\">if</span> (textEnd &gt;= <span class=\"hljs-number\">0</span>) &#123;<br><br>            &#125;<br>            <span class=\"hljs-comment\">// 如果在html字符串中没有找到&#x27;&lt;&#x27;，表示这一段html字符串都是纯文本</span><br>            <span class=\"hljs-keyword\">if</span> (textEnd &lt; <span class=\"hljs-number\">0</span>) &#123;<br>                text = html<br>                html = <span class=\"hljs-string\">&#x27;&#x27;</span><br>            &#125;<br>            <span class=\"hljs-comment\">// 把截取出来的text转化成textAST</span><br>            <span class=\"hljs-keyword\">if</span> (options.chars &amp;&amp; text) &#123;<br>                options.chars(text)<br>            &#125;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t<span class=\"hljs-comment\">// 父元素为script、style、textarea时，其内部的内容全部当做纯文本处理</span><br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">//将整个字符串作为文本对待</span><br>\t\t<span class=\"hljs-keyword\">if</span> (html === last) &#123;<br>\t\t\toptions.chars &amp;&amp; options.chars(html);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (!stack.length &amp;&amp; options.warn) &#123;<br>\t\t\t\toptions.warn((<span class=\"hljs-string\">&quot;Mal-formatted tag at end of template: \\&quot;&quot;</span> + html + <span class=\"hljs-string\">&quot;\\&quot;&quot;</span>));<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// Clean up any remaining tags</span><br>\tparseEndTag();<br>\t<span class=\"hljs-comment\">//parse 开始标签</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">parseStartTag</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br><br>\t&#125;<br>\t<span class=\"hljs-comment\">//处理 parseStartTag 的结果</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handleStartTag</span>(<span class=\"hljs-params\">match</span>) </span>&#123;<br><br>\t&#125;<br>\t<span class=\"hljs-comment\">//parse 结束标签</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">parseEndTag</span>(<span class=\"hljs-params\">tagName, start, end</span>) </span>&#123;<br><br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>​    上述代码中大致可分为三部分：</p>\n<ul>\n<li>定义的一些常量和变量</li>\n<li>while 循环</li>\n<li>解析过程中用到的辅助函数</li>\n</ul>\n<p>我们一一来分析：</p>\n<p>首先定义了几个常量，如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> stack = []       <span class=\"hljs-comment\">// 维护AST节点层级的栈</span><br><span class=\"hljs-keyword\">const</span> expectHTML = options.expectHTML<br><span class=\"hljs-keyword\">const</span> isUnaryTag = options.isUnaryTag || no<br><span class=\"hljs-keyword\">const</span> canBeLeftOpenTag = options.canBeLeftOpenTag || no   <span class=\"hljs-comment\">//用来检测一个标签是否是可以省略闭合标签的非自闭合标签</span><br><span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>   <span class=\"hljs-comment\">//解析游标，标识当前从何处开始解析模板字符串</span><br><span class=\"hljs-keyword\">let</span> last,   <span class=\"hljs-comment\">// 存储剩余还未解析的模板字符串</span><br>    lastTag  <span class=\"hljs-comment\">// 存储着位于 stack 栈顶的元素</span><br></code></pre></td></tr></table></figure>\n\n<p>接着开启<code>while</code> 循环，循环的终止条件是 模板字符串<code>html</code>为空，即模板字符串被全部编译完毕。在每次<code>while</code>循环中， 先把 <code>html</code>的值赋给变量 <code>last</code>，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">last = html<br></code></pre></td></tr></table></figure>\n\n<p>这样做的目的是，如果经过上述所有处理逻辑处理过后，<code>html</code>字符串没有任何变化，即表示<code>html</code>字符串没有匹配上任何一条规则，那么就把<code>html</code>字符串当作纯文本对待，创建文本类型的<code>AST</code>节点并且如果抛出异常：模板字符串中标签格式有误。如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//将整个字符串作为文本对待</span><br><span class=\"hljs-keyword\">if</span> (html === last) &#123;<br>    options.chars &amp;&amp; options.chars(html);<br>    <span class=\"hljs-keyword\">if</span> (!stack.length &amp;&amp; options.warn) &#123;<br>        options.warn((<span class=\"hljs-string\">&quot;Mal-formatted tag at end of template: \\&quot;&quot;</span> + html + <span class=\"hljs-string\">&quot;\\&quot;&quot;</span>));<br>    &#125;<br>    <span class=\"hljs-keyword\">break</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>接着，我们继续看<code>while</code>循环体内的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">while</span> (html) &#123;<br>  <span class=\"hljs-comment\">// 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)</span><br>  <span class=\"hljs-keyword\">if</span> (!lastTag || !isPlainTextElement(lastTag)) &#123;<br><br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">// parse 的内容是在纯文本标签里 (script,style,textarea)</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在循环体内，首先判断了待解析的<code>html</code>字符串是否在纯文本标签里，如<code>script</code>,<code>style</code>,<code>textarea</code>，因为在这三个标签里的内容肯定不会有<code>HTML</code>标签，所以我们可直接当作文本处理，判断条件如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">!lastTag || !isPlainTextElement(lastTag)<br></code></pre></td></tr></table></figure>\n\n<p>前面我们说了，<code>lastTag</code>为栈顶元素，<code>!lastTag</code>即表示当前<code>html</code>字符串没有父节点，而<code>isPlainTextElement(lastTag)</code> 是检测 <code>lastTag</code> 是否为是那三个纯文本标签之一，是的话返回<code>true</code>，不是返回<code>fasle</code>。</p>\n<p>也就是说当前<code>html</code>字符串要么没有父节点要么父节点不是纯文本标签，则接下来就可以依次解析那6种类型的内容了，关于6种类型内容的处理方式前文已经逐个介绍过，此处不再重复。</p>\n<h5 id=\"5-2-parseEndTag函数源码\"><a href=\"#5-2-parseEndTag函数源码\" class=\"headerlink\" title=\"5.2 parseEndTag函数源码\"></a>5.2 parseEndTag函数源码</h5><p>接下来我们看一下之前在解析结束标签时遗留的<code>parseEndTag</code>函数，该函数定义如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">parseEndTag</span> (<span class=\"hljs-params\">tagName, start, end</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">let</span> pos, lowerCasedTagName<br>    <span class=\"hljs-keyword\">if</span> (start == <span class=\"hljs-literal\">null</span>) start = index<br>    <span class=\"hljs-keyword\">if</span> (end == <span class=\"hljs-literal\">null</span>) end = index<br><br>    <span class=\"hljs-keyword\">if</span> (tagName) &#123;<br>      lowerCasedTagName = tagName.toLowerCase()<br>    &#125;<br><br>    <span class=\"hljs-comment\">// Find the closest opened tag of the same type</span><br>    <span class=\"hljs-keyword\">if</span> (tagName) &#123;<br>      <span class=\"hljs-keyword\">for</span> (pos = stack.length - <span class=\"hljs-number\">1</span>; pos &gt;= <span class=\"hljs-number\">0</span>; pos--) &#123;<br>        <span class=\"hljs-keyword\">if</span> (stack[pos].lowerCasedTag === lowerCasedTagName) &#123;<br>          <span class=\"hljs-keyword\">break</span><br>        &#125;<br>      &#125;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-comment\">// If no tag name is provided, clean shop</span><br>      pos = <span class=\"hljs-number\">0</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (pos &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>      <span class=\"hljs-comment\">// Close all the open elements, up the stack</span><br>      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = stack.length - <span class=\"hljs-number\">1</span>; i &gt;= pos; i--) &#123;<br>        <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">&#x27;production&#x27;</span> &amp;&amp;<br>          (i &gt; pos || !tagName) &amp;&amp;<br>          options.warn<br>        ) &#123;<br>          options.warn(<br>            <span class=\"hljs-string\">`tag &lt;<span class=\"hljs-subst\">$&#123;stack[i].tag&#125;</span>&gt; has no matching end tag.`</span><br>          )<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (options.end) &#123;<br>          options.end(stack[i].tag, start, end)<br>        &#125;<br>      &#125;<br><br>      <span class=\"hljs-comment\">// Remove the open elements from the stack</span><br>      stack.length = pos<br>      lastTag = pos &amp;&amp; stack[pos - <span class=\"hljs-number\">1</span>].tag<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (lowerCasedTagName === <span class=\"hljs-string\">&#x27;br&#x27;</span>) &#123;<br>      <span class=\"hljs-keyword\">if</span> (options.start) &#123;<br>        options.start(tagName, [], <span class=\"hljs-literal\">true</span>, start, end)<br>      &#125;<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (lowerCasedTagName === <span class=\"hljs-string\">&#x27;p&#x27;</span>) &#123;<br>      <span class=\"hljs-keyword\">if</span> (options.start) &#123;<br>        options.start(tagName, [], <span class=\"hljs-literal\">false</span>, start, end)<br>      &#125;<br>      <span class=\"hljs-keyword\">if</span> (options.end) &#123;<br>        options.end(tagName, start, end)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该函数接收三个参数，分别是结束标签名<code>tagName</code>、结束标签在<code>html</code>字符串中的起始和结束位置<code>start</code>和<code>end</code>。</p>\n<p>这三个参数其实都是可选的，根据传参的不同其功能也不同。</p>\n<ul>\n<li>第一种是三个参数都传递，用于处理普通的结束标签</li>\n<li>第二种是只传递<code>tagName</code></li>\n<li>第三种是三个参数都不传递，用于处理栈中剩余未处理的标签</li>\n</ul>\n<p>如果<code>tagName</code>存在，那么就从后往前遍历栈，在栈中寻找与<code>tagName</code>相同的标签并记录其所在的位置<code>pos</code>，如果<code>tagName</code>不存在，则将<code>pos</code>置为0。如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">if</span> (tagName) &#123;<br>    <span class=\"hljs-keyword\">for</span> (pos = stack.length - <span class=\"hljs-number\">1</span>; pos &gt;= <span class=\"hljs-number\">0</span>; pos--) &#123;<br>        <span class=\"hljs-keyword\">if</span> (stack[pos].lowerCasedTag === lowerCasedTagName) &#123;<br>            <span class=\"hljs-keyword\">break</span><br>        &#125;<br>    &#125;<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">// If no tag name is provided, clean shop</span><br>    pos = <span class=\"hljs-number\">0</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>接着当<code>pos&gt;=0</code>时，开启一个<code>for</code>循环，从栈顶位置从后向前遍历直到<code>pos</code>处，如果发现<code>stack</code>栈中存在索引大于<code>pos</code>的元素，那么该元素一定是缺少闭合标签的。这是因为在正常情况下，<code>stack</code>栈的栈顶元素应该和当前的结束标签<code>tagName</code> 匹配，也就是说正常的<code>pos</code>应该是栈顶位置，后面不应该再有元素，如果后面还有元素，那么后面的元素就都缺少闭合标签 那么这个时候如果是在非生产环境会抛出警告，告诉你缺少闭合标签。除此之外，还会调用 <code>options.end(stack[i].tag, start, end)</code>立即将其闭合，这是为了保证解析结果的正确性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">if</span> (pos &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>\t<span class=\"hljs-comment\">// Close all the open elements, up the stack</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = stack.length - <span class=\"hljs-number\">1</span>; i &gt;= pos; i--) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (i &gt; pos || !tagName ) &#123;<br>\t\t\toptions.warn(<br>\t\t\t\t(<span class=\"hljs-string\">&quot;tag &lt;&quot;</span> + (stack[i].tag) + <span class=\"hljs-string\">&quot;&gt; has no matching end tag.&quot;</span>)<br>\t\t\t);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> (options.end) &#123;<br>\t\t\toptions.end(stack[i].tag, start, end);<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// Remove the open elements from the stack</span><br>\tstack.length = pos;<br>\tlastTag = pos &amp;&amp; stack[pos - <span class=\"hljs-number\">1</span>].tag;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>最后把<code>pos</code>位置以后的元素都从<code>stack</code>栈中弹出，以及把<code>lastTag</code>更新为栈顶元素:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">stack.length = pos;<br>lastTag = pos &amp;&amp; stack[pos - <span class=\"hljs-number\">1</span>].tag;<br></code></pre></td></tr></table></figure>\n\n<p>接着，如果<code>pos</code>没有大于等于0，即当 <code>tagName</code> 没有在 <code>stack</code> 栈中找到对应的开始标签时，<code>pos</code> 为 -1 。那么此时再判断 <code>tagName</code> 是否为<code>br</code> 或<code>p</code>标签，为什么要单独判断这两个标签呢？这是因为在浏览器中如果我们写了如下<code>HTML</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">br</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>​    浏览器会自动把<code>&lt;/br&gt;</code>标签解析为正常的 <br>标签，而对于<code>&lt;/p&gt;</code>浏览器则自动将其补全为<code>&lt;p&gt;&lt;/p&gt;</code>，所以<code>Vue</code>为了与浏览器对这两个标签的行为保持一致，故对这两个便签单独判断处理，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">f (lowerCasedTagName === <span class=\"hljs-string\">&#x27;br&#x27;</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (options.start) &#123;<br>        options.start(tagName, [], <span class=\"hljs-literal\">true</span>, start, end)  <span class=\"hljs-comment\">// 创建&lt;br&gt;AST节点</span><br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">// 补全p标签并创建AST节点</span><br><span class=\"hljs-keyword\">if</span> (lowerCasedTagName === <span class=\"hljs-string\">&#x27;p&#x27;</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (options.start) &#123;<br>        options.start(tagName, [], <span class=\"hljs-literal\">false</span>, start, end)<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (options.end) &#123;<br>        options.end(tagName, start, end)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>以上就是对结束标签的解析与处理。</p>\n<p>另外，在<code>while</code>循环后面还有一行代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">parseEndTag()<br></code></pre></td></tr></table></figure>\n\n<p>这行代码执行的时机是<code>html === last</code>，即<code>html</code>字符串中的标签格式有误时会跳出<code>while</code>循环，此时就会执行这行代码，这行代码是调用<code>parseEndTag</code>函数并不传递任何参数，前面我们说过如果<code>parseEndTag</code>函数不传递任何参数是用于处理栈中剩余未处理的标签。这是因为如果不传递任何函数，此时<code>parseEndTag</code>函数里的<code>pos</code>就为0，那么<code>pos&gt;=0</code>就会恒成立，那么就会逐个警告缺少闭合标签，并调用 <code>options.end</code>将其闭合。</p>\n<h5 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>本篇文章主要介绍了<code>HTML</code>解析器的工作流程以及工作原理，文章比较长，但是逻辑并不复杂。</p>\n<p>首先介绍了<code>HTML</code>解析器的工作流程，一句话概括就是：一边解析不同的内容一边调用对应的钩子函数生成对应的<code>AST</code>节点，最终完成将整个模板字符串转化成<code>AST</code>。</p>\n<p>接着介绍了<code>HTML</code>解析器是如何解析用户所写的模板字符串中各种类型的内容的，把各种类型的解析方式都分别进行了介绍。</p>\n<p>其次，介绍了在解析器内维护了一个栈，用来保证构建的<code>AST</code>节点层级与真正<code>DOM</code>层级一致。</p>\n<p>了解了思想之后，最后回归源码，学习了源码中一些处理细节的地方。</p>\n<h5 id=\"文本解析器\"><a href=\"#文本解析器\" class=\"headerlink\" title=\"文本解析器\"></a>文本解析器</h5><p>在上篇文章中我们说了，当<code>HTML</code>解析器解析到文本内容时会调用4个钩子函数中的<code>chars</code>函数来创建文本型的<code>AST</code>节点，并且也说了在<code>chars</code>函数中会根据文本内容是否包含变量再细分为创建含有变量的<code>AST</code>节点和不包含变量的<code>AST</code>节点，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 当解析到标签的文本时，触发chars</span><br>chars (text) &#123;<br>  <span class=\"hljs-keyword\">if</span>(res = parseText(text))&#123;<br>       <span class=\"hljs-keyword\">let</span> element = &#123;<br>           type: <span class=\"hljs-number\">2</span>,<br>           expression: res.expression,<br>           tokens: res.tokens,<br>           text<br>       &#125;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>       <span class=\"hljs-keyword\">let</span> element = &#123;<br>           type: <span class=\"hljs-number\">3</span>,<br>           text<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从上面代码中可以看到，创建含有变量的<code>AST</code>节点时节点的<code>type</code>属性为2，并且相较于不包含变量的<code>AST</code>节点多了两个属性：<code>expression</code>和<code>tokens</code>。那么如何来判断文本里面是否包含变量以及多的那两个属性是什么呢？这就涉及到文本解析器了，当<code>Vue</code>用<code>HTML</code>解析器解析出文本时，再将解析出来的文本内容传给文本解析器，最后由文本解析器解析该段文本里面是否包含变量以及如果包含变量时再解析<code>expression</code>和<code>tokens</code>。那么接下来，本篇文章就来分析一下文本解析器都干了些什么。</p>\n<p>撸码一时爽，一直撸码一直爽！！！</p>\n","raw":null,"categories":[],"tags":[{"name":"vue源码理解——模板编译篇","path":"api/tags/vue源码理解——模板编译篇.json"}]},{"title":"vue源码理解——虚拟DOM篇","slug":"vue源码理解2","date":"2021-03-18T11:29:18.000Z","updated":"2021-04-25T06:23:24.373Z","comments":true,"top":null,"path":"api/articles/vue源码理解2.json","excerpt":null,"keywords":null,"cover":"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210422112653087.png","content":"<p>虚拟DOM，这个名词作为当下的前端开发人员你一定不会陌生，至少会略有耳闻，但不会闻所未闻吧。这也是现在求职面试考察中非常高频的一个考点了。因为在当下的前端三大框架中关于虚拟DOM或多或少都有所涉及，那么接下来，我们就从源码角度出发，看看<code>Vue</code>中的虚拟DOM时怎样的。</p>\n<h4 id=\"虚拟DOM简介\"><a href=\"#虚拟DOM简介\" class=\"headerlink\" title=\"虚拟DOM简介\"></a>虚拟DOM简介</h4><p>由于本系列文章是针对<code>Vue</code>源码深入学习的，所以着重分析在<code>Vue</code>中对虚拟DOM是如何实现的，而对于虚拟DOM本身这个概念不做大篇幅的展开讨论，仅从以下几个问题简单介绍：</p>\n<p>1.什么是虚拟DOM？</p>\n<p>所谓虚拟DOM，就是用一个<code>JS</code>对象来描述一个<code>DOM</code>节点，像如下示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;div <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">&quot;a&quot;</span> id=<span class=\"hljs-string\">&quot;b&quot;</span>&gt;我是内容&lt;/div&gt;<br><br>&#123;<br>  tag:<span class=\"hljs-string\">&#x27;div&#x27;</span>,        <span class=\"hljs-comment\">// 元素标签</span><br>  attrs:&#123;           <span class=\"hljs-comment\">// 属性</span><br>    class:&#x27;a&#x27;,<br>    id:<span class=\"hljs-string\">&#x27;b&#x27;</span><br>  &#125;,<br>  text:<span class=\"hljs-string\">&#x27;我是内容&#x27;</span>,  <span class=\"hljs-comment\">// 文本内容</span><br>  children:[]       <span class=\"hljs-comment\">// 子元素</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们把组成一个<code>DOM</code>节点的必要东西通过一个<code>JS</code>对象表示出来，那么这个<code>JS</code>对象就可以用来描述这个<code>DOM</code>节点，我们把这个<code>JS</code>对象就称为是这个真实<code>DOM</code>节点的虚拟<code>DOM</code>节点</p>\n<p>2.为什么要有虚拟DOM？</p>\n<p>我们知道，<code>Vue</code>是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作<code>DOM</code>,而操作真实<code>DOM</code>又是非常耗费性能的，这是因为浏览器的标准就把 <code>DOM</code> 设计的非常复杂，所以一个真正的 <code>DOM</code> 元素是非常庞大的，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> div = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">&#x27;div&#x27;</span>)<br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;&#x27;</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">in</span> div) &#123;<br>  str += key + <span class=\"hljs-string\">&#x27;&#x27;</span><br>&#125;<br><span class=\"hljs-built_in\">console</span>.log(str)<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210422112653087.png\" alt=\"image-20210422112653087\"></p>\n<p>上图中我们打印一个简单的空<code>div</code>标签，就打印出这么多东西，更不用说复杂的、深嵌套的<code>DOM</code>节点了。由此可见，直接操作真实<code>DOM</code>是非常消耗性能的。</p>\n<p>那么有没有什么解决方案呢？当然是有的。我们可以用<code>JS</code>的计算性能来换取操作<code>DOM</code>所消耗的性能。</p>\n<p>既然我们逃不掉操作<code>DOM</code>这道坎,但是我们可以尽可能少的操作<code>DOM</code>。那如何在更新视图的时候尽可能少的操作<code>DOM</code>呢？最直观的思路就是我们不要盲目的去更新视图，而是通过对比数据变化前后的状态，计算出视图中哪些地方需要更新，只更新需要更新的地方，而不需要更新的地方则不需关心，这样我们就可以尽可能少的操作<code>DOM</code>了。这也就是上面所说的用<code>JS</code>的计算性能来换取操作<code>DOM</code>的性能。</p>\n<p>我们可以用<code>JS</code>模拟出一个<code>DOM</code>节点，称之为虚拟<code>DOM</code>节点。当数据发生变化时，我们对比变化前后的虚拟<code>DOM</code>节点，通过<code>DOM-Diff</code>算法计算出需要更新的地方，然后去更新需要更新的视图。</p>\n<p>这就是虚拟<code>DOM</code>产生的原因以及最大的用途。</p>\n<h5 id=\"Vue中的虚拟DOM\"><a href=\"#Vue中的虚拟DOM\" class=\"headerlink\" title=\"Vue中的虚拟DOM\"></a>Vue中的虚拟DOM</h5><p>前文我们介绍了虚拟<code>DOM</code>的概念以及为什么要有虚拟<code>DOM</code>，那么在<code>Vue</code>中虚拟<code>DOM</code>是怎么实现的呢？接下来，我们从源码出发，深入学习一下。</p>\n<h6 id=\"VNode类\"><a href=\"#VNode类\" class=\"headerlink\" title=\"VNode类\"></a>VNode类</h6><p>我们说了，虚拟<code>DOM</code>就是用<code>JS</code>来描述一个真实的<code>DOM</code>节点。而在<code>Vue</code>中就存在了一个<code>VNode</code>类，通过这个类，我们就可以实例化出不同类型的虚拟<code>DOM</code>节点，源码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">VNode</span> </span>&#123;<br>  <span class=\"hljs-keyword\">constructor</span> (<br>    tag?: string,<br>    data?: VNodeData,<br>    children?: ?Array&lt;VNode&gt;,<br>    text?: string,<br>    elm?: Node,<br>    context?: Component,<br>    componentOptions?: VNodeComponentOptions,<br>    asyncFactory?: Function<br>  ) &#123;<br>    <span class=\"hljs-built_in\">this</span>.tag = tag                                <span class=\"hljs-comment\">/*当前节点的标签名*/</span><br>    <span class=\"hljs-built_in\">this</span>.data = data        <span class=\"hljs-comment\">/*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/</span><br>    <span class=\"hljs-built_in\">this</span>.children = children  <span class=\"hljs-comment\">/*当前节点的子节点，是一个数组*/</span><br>    <span class=\"hljs-built_in\">this</span>.text = text     <span class=\"hljs-comment\">/*当前节点的文本*/</span><br>    <span class=\"hljs-built_in\">this</span>.elm = elm       <span class=\"hljs-comment\">/*当前虚拟节点对应的真实dom节点*/</span><br>    <span class=\"hljs-built_in\">this</span>.ns = <span class=\"hljs-literal\">undefined</span>            <span class=\"hljs-comment\">/*当前节点的名字空间*/</span><br>    <span class=\"hljs-built_in\">this</span>.context = context          <span class=\"hljs-comment\">/*当前组件节点对应的Vue实例*/</span><br>    <span class=\"hljs-built_in\">this</span>.fnContext = <span class=\"hljs-literal\">undefined</span>       <span class=\"hljs-comment\">/*函数式组件对应的Vue实例*/</span><br>    <span class=\"hljs-built_in\">this</span>.fnOptions = <span class=\"hljs-literal\">undefined</span><br>    <span class=\"hljs-built_in\">this</span>.fnScopeId = <span class=\"hljs-literal\">undefined</span><br>    <span class=\"hljs-built_in\">this</span>.key = data &amp;&amp; data.key           <span class=\"hljs-comment\">/*节点的key属性，被当作节点的标志，用以优化*/</span><br>    <span class=\"hljs-built_in\">this</span>.componentOptions = componentOptions   <span class=\"hljs-comment\">/*组件的option选项*/</span><br>    <span class=\"hljs-built_in\">this</span>.componentInstance = <span class=\"hljs-literal\">undefined</span>       <span class=\"hljs-comment\">/*当前节点对应的组件的实例*/</span><br>    <span class=\"hljs-built_in\">this</span>.parent = <span class=\"hljs-literal\">undefined</span>           <span class=\"hljs-comment\">/*当前节点的父节点*/</span><br>    <span class=\"hljs-built_in\">this</span>.raw = <span class=\"hljs-literal\">false</span>         <span class=\"hljs-comment\">/*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/</span><br>    <span class=\"hljs-built_in\">this</span>.isStatic = <span class=\"hljs-literal\">false</span>         <span class=\"hljs-comment\">/*静态节点标志*/</span><br>    <span class=\"hljs-built_in\">this</span>.isRootInsert = <span class=\"hljs-literal\">true</span>      <span class=\"hljs-comment\">/*是否作为跟节点插入*/</span><br>    <span class=\"hljs-built_in\">this</span>.isComment = <span class=\"hljs-literal\">false</span>             <span class=\"hljs-comment\">/*是否为注释节点*/</span><br>    <span class=\"hljs-built_in\">this</span>.isCloned = <span class=\"hljs-literal\">false</span>           <span class=\"hljs-comment\">/*是否为克隆节点*/</span><br>    <span class=\"hljs-built_in\">this</span>.isOnce = <span class=\"hljs-literal\">false</span>                <span class=\"hljs-comment\">/*是否有v-once指令*/</span><br>    <span class=\"hljs-built_in\">this</span>.asyncFactory = asyncFactory<br>    <span class=\"hljs-built_in\">this</span>.asyncMeta = <span class=\"hljs-literal\">undefined</span><br>    <span class=\"hljs-built_in\">this</span>.isAsyncPlaceholder = <span class=\"hljs-literal\">false</span><br>  &#125;<br><br>  get child (): Component | <span class=\"hljs-keyword\">void</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.componentInstance<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从上面的代码中可以看出：<code>VNode</code>类中包含了描述一个真实<code>DOM</code>节点所需要的一系列属性，如<code>tag</code>表示节点的标签名，<code>text</code>表示节点中包含的文本，<code>children</code>表示该节点包含的子节点等。通过属性之间不同的搭配，就可以描述出各种类型的真实<code>DOM</code>节点。</p>\n<h5 id=\"VNode的类型\"><a href=\"#VNode的类型\" class=\"headerlink\" title=\"VNode的类型\"></a>VNode的类型</h5><p>上一小节最后我们说了，通过属性之间不同的搭配，<code>VNode</code>类可以描述出各种类型的真实<code>DOM</code>节点。那么它都可以描述出哪些类型的节点呢？通过阅读源码，可以发现通过不同属性的搭配，可以描述出以下几种类型的节点。</p>\n<ul>\n<li>注释节点</li>\n<li>文本节点</li>\n<li>元素节点</li>\n<li>组件节点</li>\n<li>函数式组件节点</li>\n<li>克隆节点</li>\n</ul>\n<p>1.注释节点</p>\n<p>描述起来相对就非常简单了，它只需两个属性就够了，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 创建注释节点</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> createEmptyVNode = <span class=\"hljs-function\">(<span class=\"hljs-params\">text: string = <span class=\"hljs-string\">&#x27;&#x27;</span></span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> node = <span class=\"hljs-keyword\">new</span> VNode()<br>  node.text = text<br>  node.isComment = <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-keyword\">return</span> node<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从上面代码中可以看到，描述一个注释节点只需两个属性，分别是：<code>text</code>和<code>isComment</code>。其中<code>text</code>属性表示具体的注释信息，<code>isComment</code>是一个标志，用来标识一个节点是否是注释节点。</p>\n<p>2.文本节点</p>\n<p>文本节点描述起来比注释节点更简单，因为它只需要一个属性，那就是<code>text</code>属性，用来表示具体的文本信息。源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 创建文本节点</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createTextVNode</span> (<span class=\"hljs-params\">val: string | number</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> VNode(<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-built_in\">String</span>(val))<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>3.克隆节点</p>\n<p>克隆节点就是把一个已经存在的节点复制一份出来，它主要是为了做模板编译优化时使用，这个后面我们会说到。关于克隆节点的描述，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 创建克隆节点</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">cloneVNode</span> (<span class=\"hljs-params\">vnode: VNode</span>): <span class=\"hljs-title\">VNode</span> </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> cloned = <span class=\"hljs-keyword\">new</span> VNode(<br>    vnode.tag,<br>    vnode.data,<br>    vnode.children,<br>    vnode.text,<br>    vnode.elm,<br>    vnode.context,<br>    vnode.componentOptions,<br>    vnode.asyncFactory<br>  )<br>  cloned.ns = vnode.ns<br>  cloned.isStatic = vnode.isStatic<br>  cloned.key = vnode.key<br>  cloned.isComment = vnode.isComment<br>  cloned.fnContext = vnode.fnContext<br>  cloned.fnOptions = vnode.fnOptions<br>  cloned.fnScopeId = vnode.fnScopeId<br>  cloned.asyncMeta = vnode.asyncMeta<br>  cloned.isCloned = <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-keyword\">return</span> cloned<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从上面代码中可以看到，克隆节点就是把已有节点的属性全部复制到新节点中，而现有节点和新克隆得到的节点之间唯一的不同就是克隆得到的节点<code>isCloned</code>为<code>true</code></p>\n<p>4.元素节点</p>\n<p>相比之下，元素节点更贴近于我们通常看到的真实<code>DOM</code>节点，它有描述节点标签名词的<code>tag</code>属性，描述节点属性如<code>class</code>、<code>attributes</code>等的<code>data</code>属性，有描述包含的子节点信息的<code>children</code>属性等。由于元素节点所包含的情况相比而言比较复杂，源码中没有像前三种节点一样直接写死（当然也不可能写死），那就举个简单例子说明一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 真实DOM节点</span><br>&lt;div id=<span class=\"hljs-string\">&#x27;a&#x27;</span>&gt;<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>难凉热血<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>&lt;/div&gt;<br><br><span class=\"hljs-comment\">// VNode节点</span><br>&#123;<br>  tag:<span class=\"hljs-string\">&#x27;div&#x27;</span>,<br>  data:&#123;&#125;,<br>  children:[<br>    &#123;<br>      tag:<span class=\"hljs-string\">&#x27;span&#x27;</span>,<br>      text:<span class=\"hljs-string\">&#x27;难凉热血&#x27;</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们可以看到，真实<code>DOM</code>节点中:<code>div</code>标签里面包含了一个<code>span</code>标签，而<code>span</code>标签里面有一段文本。反应到<code>VNode</code>节点上就如上所示:<code>tag</code>表示标签名，<code>data</code>表示标签的属性<code>id</code>等，<code>children</code>表示子节点数组。</p>\n<p>5.组件节点</p>\n<p>组件节点除了有元素节点具有的属性之外，它还有两个特有的属性：</p>\n<ul>\n<li>componentOptions :组件的option选项，如组件的<code>props</code>等</li>\n<li>componentInstance :当前组件节点对应的<code>Vue</code>实例</li>\n</ul>\n<p>6.函数式组件节点</p>\n<p>函数式组件节点相较于组件节点，它又有两个特有的属性：</p>\n<ul>\n<li>fnContext:函数式组件对应的Vue实例</li>\n<li>fnOptions: 组件的option选项</li>\n</ul>\n<p>以上就是<code>VNode</code>可以描述的多种节点类型，它们本质上都是<code>VNode</code>类的实例，只是在实例化的时候传入的属性参数不同而已。</p>\n<h6 id=\"VNode的作用\"><a href=\"#VNode的作用\" class=\"headerlink\" title=\"VNode的作用:\"></a>VNode的作用:</h6><p>说了这么多，那么<code>VNode</code>在<code>Vue</code>的整个虚拟<code>DOM</code>过程起了什么作用呢？</p>\n<p>其实<code>VNode</code>的作用是相当大的。我们在视图渲染之前，把写好的<code>template</code>模板先编译成<code>VNode</code>并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的<code>VNode</code>与前一次缓存下来的<code>VNode</code>进行对比，找出差异，然后有差异的<code>VNode</code>对应的真实<code>DOM</code>节点就是需要重新渲染的节点，最后根据有差异的<code>VNode</code>创建出真实的<code>DOM</code>节点再插入到视图中，最终完成一次视图更新。</p>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><p>本章首先介绍了虚拟<code>DOM</code>的一些基本概念和为什么要有虚拟<code>DOM</code>，其实说白了就是以<code>JS</code>的计算性能来换取操作真实<code>DOM</code>所消耗的性能。接着从源码角度我们知道了在<code>Vue</code>中是通过<code>VNode</code>类来实例化出不同类型的虚拟<code>DOM</code>节点，并且学习了不同类型节点生成的属性的不同，所谓不同类型的节点其本质还是一样的，都是<code>VNode</code>类的实例，只是在实例化时传入的属性参数不同罢了。最后探究了<code>VNode</code>的作用，有了数据变化前后的<code>VNode</code>，我们才能进行后续的<code>DOM-Diff</code>找出差异，最终做到只更新有差异的视图，从而达到尽可能少的操作真实<code>DOM</code>的目的，以节省性能。</p>\n<h5 id=\"vue虚拟dom的diff\"><a href=\"#vue虚拟dom的diff\" class=\"headerlink\" title=\"vue虚拟dom的diff\"></a>vue虚拟dom的diff</h5><p>在上一篇文章介绍<code>VNode</code>的时候我们说了，<code>VNode</code>最大的用途就是在数据变化前后生成真实<code>DOM</code>对应的虚拟<code>DOM</code>节点，然后就可以对比新旧两份<code>VNode</code>，找出差异所在，然后更新有差异的<code>DOM</code>节点，最终达到以最少操作真实<code>DOM</code>更新视图的目的。而对比新旧两份<code>VNode</code>并找出差异的过程就是所谓的<code>DOM-Diff</code>过程。<code>DOM-Diff</code>算法是整个虚拟<code>DOM</code>的核心所在，那么接下来，我们就以源码出发，深入研究一下<code>Vue</code>中的<code>DOM-Diff</code>过程是怎样的。</p>\n<p>在<code>Vue</code>中，把 <code>DOM-Diff</code>过程叫做<code>patch</code>过程。patch,意为“补丁”，即指对旧的<code>VNode</code>修补，打补丁从而得到新的<code>VNode</code>，非常形象哈。那不管叫什么，其本质都是把对比新旧两份<code>VNode</code>的过程。我们在下面研究<code>patch</code>过程的时候，一定把握住这样一个思想：所谓旧的<code>VNode</code>(即<code>oldVNode</code>)就是数据变化之前视图所对应的虚拟<code>DOM</code>节点，而新的<code>VNode</code>是数据变化之后将要渲染的新的视图所对应的虚拟<code>DOM</code>节点，所以我们要以生成的新的<code>VNode</code>为基准，对比旧的<code>oldVNode</code>，如果新的<code>VNode</code>上有的节点而旧的<code>oldVNode</code>上没有，那么就在旧的<code>oldVNode</code>上加上去；如果新的<code>VNode</code>上没有的节点而旧的<code>oldVNode</code>上有，那么就在旧的<code>oldVNode</code>上去掉；如果某些节点在新的<code>VNode</code>和旧的<code>oldVNode</code>上都有，那么就以新的<code>VNode</code>为准，更新旧的<code>oldVNode</code>，从而让新旧<code>VNode</code>相同。</p>\n<p>总之一句话：<strong>以新的VNode为基准，改造旧的oldVNode使之成为跟新的VNode一样，这就是patch过程要干的事</strong>。</p>\n<p>说了这么多，听起来感觉好像很复杂的样子，其实不然，我们仔细想想，整个<code>patch</code>无非就是干三件事：</p>\n<ul>\n<li>创建节点：新的<code>VNode</code>中有而旧的<code>oldVNode</code>中没有，就在旧的<code>oldVNode</code>中创建。</li>\n<li>删除节点：新的<code>VNode</code>中没有而旧的<code>oldVNode</code>中有，就从旧的<code>oldVNode</code>中删除。</li>\n<li>更新节点：新的<code>VNode</code>和旧的<code>oldVNode</code>中都有，就以新的<code>VNode</code>为准，更新旧的<code>oldVNode</code>。</li>\n</ul>\n<p>OK，到这里，你就对<code>Vue</code>中的<code>patch</code>过程理解了一半了，接下来，我们就逐个分析，看<code>Vue</code>对于以上三件事都是怎么做的。</p>\n<h6 id=\"创建节点\"><a href=\"#创建节点\" class=\"headerlink\" title=\"创建节点\"></a>创建节点</h6><p>上篇文章中我们分析了，<code>VNode</code>类可以描述6种类型的节点，而实际上只有3种类型的节点能够被创建并插入到<code>DOM</code>中，它们分别是：元素节点、文本节点、注释节点。所以<code>Vue</code>在创建节点的时候会判断在新的<code>VNode</code>中有而旧的<code>oldVNode</code>中没有的这个节点是属于哪种类型的节点，从而调用不同的方法创建并插入到<code>DOM</code>中。</p>\n<p>其实判断起来也不难，因为这三种类型的节点其特点非常明显，在源码中是怎么判断的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 源码位置: /src/core/vdom/patch.js</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createElm</span> (<span class=\"hljs-params\">vnode, parentElm, refElm</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">const</span> data = vnode.data<br>    <span class=\"hljs-keyword\">const</span> children = vnode.children<br>    <span class=\"hljs-keyword\">const</span> tag = vnode.tag<br>    <span class=\"hljs-keyword\">if</span> (isDef(tag)) &#123;<br>      \tvnode.elm = nodeOps.createElement(tag, vnode)   <span class=\"hljs-comment\">// 创建元素节点</span><br>        createChildren(vnode, children, insertedVnodeQueue) <span class=\"hljs-comment\">// 创建元素节点的子节点</span><br>        insert(parentElm, vnode.elm, refElm)       <span class=\"hljs-comment\">// 插入到DOM中</span><br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isTrue(vnode.isComment)) &#123;<br>      vnode.elm = nodeOps.createComment(vnode.text)  <span class=\"hljs-comment\">// 创建注释节点</span><br>      insert(parentElm, vnode.elm, refElm)           <span class=\"hljs-comment\">// 插入到DOM中</span><br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      vnode.elm = nodeOps.createTextNode(vnode.text)  <span class=\"hljs-comment\">// 创建文本节点</span><br>      insert(parentElm, vnode.elm, refElm)           <span class=\"hljs-comment\">// 插入到DOM中</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>从上面代码中，我们可以看出：</p>\n<ul>\n<li>判断是否为元素节点只需判断该<code>VNode</code>节点是否有<code>tag</code>标签即可。如果有<code>tag</code>属性即认为是元素节点，则调用<code>createElement</code>方法创建元素节点，通常元素节点还会有子节点，那就递归遍历创建所有子节点，将所有子节点创建好之后<code>insert</code>插入到当前元素节点里面，最后把当前元素节点插入到<code>DOM</code>中。</li>\n<li>判断是否为注释节点，只需判断<code>VNode</code>的<code>isComment</code>属性是否为<code>true</code>即可，若为<code>true</code>则为注释节点，则调用<code>createComment</code>方法创建注释节点，再插入到<code>DOM</code>中。</li>\n<li>如果既不是元素节点，也不是注释节点，那就认为是文本节点，则调用<code>createTextNode</code>方法创建文本节点，再插入到<code>DOM</code>中。</li>\n</ul>\n<blockquote>\n<p>代码中的<code>nodeOps</code>是<code>Vue</code>为了跨平台兼容性，对所有节点操作进行了封装，例如<code>nodeOps.createTextNode()</code>在浏览器端等同于<code>document.createTextNode()</code></p>\n</blockquote>\n<p>以上就完成了创建节点的操作，其完整流程图如下：</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425121000760.png\" alt=\"image-20210425121000760\"></p>\n<h6 id=\"删除节点\"><a href=\"#删除节点\" class=\"headerlink\" title=\"删除节点\"></a>删除节点</h6><p>如果某些节点再新的<code>VNode</code>中没有而在旧的<code>oldVNode</code>中有，那么就需要把这些节点从旧的<code>oldVNode</code>中删除。删除节点非常简单，只需在要删除节点的父元素上调用<code>removeChild</code>方法即可。源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">removeNode</span> (<span class=\"hljs-params\">el</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">const</span> parent = nodeOps.parentNode(el)  <span class=\"hljs-comment\">// 获取父节点</span><br>    <span class=\"hljs-keyword\">if</span> (isDef(parent)) &#123;<br>      nodeOps.removeChild(parent, el)  <span class=\"hljs-comment\">// 调用父节点的removeChild方法</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<h6 id=\"更新节点\"><a href=\"#更新节点\" class=\"headerlink\" title=\"更新节点\"></a>更新节点</h6><p>创建节点和删除节点都比较简单，而更新节点就相对较为复杂一点了，其实也不算多复杂，只要理清逻辑就能理解了。</p>\n<p>更新节点就是当某些节点在新的<code>VNode</code>和旧的<code>oldVNode</code>中都有时，我们就需要细致比较一下，找出不一样的地方进行更新。</p>\n<p>介绍更新节点之前，我们先介绍一个小的概念，就是什么是静态节点？我们看个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>我是不会变化的文字<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>面这个节点里面只包含了纯文字，没有任何可变的变量，这也就是说，不管数据再怎么变化，只要这个节点第一次渲染了，那么它以后就永远不会发生变化，这是因为它不包含任何变量，所以数据发生任何变化都与它无关。我们把这种节点称之为静态节点。</p>\n<p>OK，有了这个概念以后，我们开始更新节点。更新节点的时候我们需要对以下3种情况进行判断并分别处理：</p>\n<ol>\n<li><p>如果<code>VNode</code>和<code>oldVNode</code>均为静态节点</p>\n<p>我们说了，静态节点无论数据发生任何变化都与它无关，所以都为静态节点的话则直接跳过，无需处理。</p>\n</li>\n<li><p>如果<code>VNode</code>是文本节点</p>\n<p>如果<code>VNode</code>是文本节点即表示这个节点内只包含纯文本，那么只需看<code>oldVNode</code>是否也是文本节点，如果是，那就比较两个文本是否不同，如果不同则把<code>oldVNode</code>里的文本改成跟<code>VNode</code>的文本一样。如果<code>oldVNode</code>不是文本节点，那么不论它是什么，直接调用<code>setTextNode</code>方法把它改成文本节点，并且文本内容跟<code>VNode</code>相同。</p>\n</li>\n<li><p>如果<code>VNode</code>是元素节点</p>\n<p>如果<code>VNode</code>是元素节点，则又细分以下两种情况：</p>\n<ul>\n<li><p>该节点包含子节点</p>\n<p>如果新的节点内包含了子节点，那么此时要看旧的节点是否包含子节点，如果旧的节点里也包含了子节点，那就需要递归对比更新子节点；如果旧的节点里不包含子节点，那么这个旧节点有可能是空节点或者是文本节点，如果旧的节点是空节点就把新的节点里的子节点创建一份然后插入到旧的节点里面，如果旧的节点是文本节点，则把文本清空，然后把新的节点里的子节点创建一份然后插入到旧的节点里面。</p>\n</li>\n<li><p>该节点不包含子节点</p>\n<p>如果该节点不包含子节点，同时它又不是文本节点，那就说明该节点是个空节点，那就好办了，不管旧节点之前里面都有啥，直接清空即可。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>OK，处理完以上3种情况，更新节点就算基本完成了，接下来我们看下源码中具体是怎么实现的，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 更新节点</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">patchVnode</span> (<span class=\"hljs-params\">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// vnode与oldVnode是否完全一样？若是，退出程序</span><br>  <span class=\"hljs-keyword\">if</span> (oldVnode === vnode) &#123;<br>    <span class=\"hljs-keyword\">return</span><br>  &#125;<br>  <span class=\"hljs-keyword\">const</span> elm = vnode.elm = oldVnode.elm<br><br>  <span class=\"hljs-comment\">// vnode与oldVnode是否都是静态节点？若是，退出程序</span><br>  <span class=\"hljs-keyword\">if</span> (isTrue(vnode.isStatic) &amp;&amp;<br>    isTrue(oldVnode.isStatic) &amp;&amp;<br>    vnode.key === oldVnode.key &amp;&amp;<br>    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))<br>  ) &#123;<br>    <span class=\"hljs-keyword\">return</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">const</span> oldCh = oldVnode.children<br>  <span class=\"hljs-keyword\">const</span> ch = vnode.children<br>  <span class=\"hljs-comment\">// vnode有text属性？若没有：</span><br>  <span class=\"hljs-keyword\">if</span> (isUndef(vnode.text)) &#123;<br>    <span class=\"hljs-comment\">// vnode的子节点与oldVnode的子节点是否都存在？</span><br>    <span class=\"hljs-keyword\">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;<br>      <span class=\"hljs-comment\">// 若都存在，判断子节点是否相同，不同则更新子节点</span><br>      <span class=\"hljs-keyword\">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)<br>    &#125;<br>    <span class=\"hljs-comment\">// 若只有vnode的子节点存在</span><br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isDef(ch)) &#123;<br>      <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">       * 判断oldVnode是否有文本？</span><br><span class=\"hljs-comment\">       * 若没有，则把vnode的子节点添加到真实DOM中</span><br><span class=\"hljs-comment\">       * 若有，则清空Dom中的文本，再把vnode的子节点添加到真实DOM中</span><br><span class=\"hljs-comment\">       */</span><br>      <span class=\"hljs-keyword\">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class=\"hljs-string\">&#x27;&#x27;</span>)<br>      addVnodes(elm, <span class=\"hljs-literal\">null</span>, ch, <span class=\"hljs-number\">0</span>, ch.length - <span class=\"hljs-number\">1</span>, insertedVnodeQueue)<br>    &#125;<br>    <span class=\"hljs-comment\">// 若只有oldnode的子节点存在</span><br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isDef(oldCh)) &#123;<br>      <span class=\"hljs-comment\">// 清空DOM中的子节点</span><br>      removeVnodes(elm, oldCh, <span class=\"hljs-number\">0</span>, oldCh.length - <span class=\"hljs-number\">1</span>)<br>    &#125;<br>    <span class=\"hljs-comment\">// 若vnode和oldnode都没有子节点，但是oldnode中有文本</span><br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isDef(oldVnode.text)) &#123;<br>      <span class=\"hljs-comment\">// 清空oldnode文本</span><br>      nodeOps.setTextContent(elm, <span class=\"hljs-string\">&#x27;&#x27;</span>)<br>    &#125;<br>    <span class=\"hljs-comment\">// 上面两个判断一句话概括就是，如果vnode中既没有text，也没有子节点，那么对应的oldnode中有什么就清空什么</span><br>  &#125;<br>  <span class=\"hljs-comment\">// 若有，vnode的text属性与oldVnode的text属性是否相同？</span><br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (oldVnode.text !== vnode.text) &#123;<br>    <span class=\"hljs-comment\">// 若不相同：则用vnode的text替换真实DOM的文本</span><br>    nodeOps.setTextContent(elm, vnode.text)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码里注释已经写得很清晰了，接下来我们画流程图来梳理一下整个过程，流程图如下：</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425121148769.png\" alt=\"image-20210425121148769\"></p>\n<p>通过对照着流程图以及代码，相信更新节点这部分逻辑你很容易就能理解了。s</p>\n<p>另外，你可能注意到了，如果新旧<code>VNode</code>里都包含了子节点，那么对于子节点的更新在代码里调用了<code>updateChildren</code>方法，而这个方法的逻辑到底是怎样的我们放在下一篇文章中展开学习。</p>\n<h6 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h6><p>在本篇文章中我们介绍了<code>Vue</code>中的<code>DOM-Diff</code>算法：patch过程。我们先介绍了算法的整个思想流程，然后通过梳理算法思想，了解了整个<code>patch</code>过程干了三件事，分别是：创建节点，删除节点，更新节点。并且对每件事情都对照源码展开了细致的学习，画出了其逻辑流程图。另外对于更新节点中，如果新旧<code>VNode</code>里都包含了子节点，我们就需要细致的去更新子节点，关于更新子节点的过程我们在下一篇文章中展开学习。</p>\n<p>在上一篇文章中，我们了解了<code>Vue</code>中的<code>patch</code>过程，即<code>DOM-Diff</code>算法。并且知道了在<code>patch</code>过程中基本会干三件事，分别是：创建节点，删除节点和更新节点。创建节点和删除节点都比较简单，而更新节点因为要处理各种可能出现的情况所以逻辑略微复杂一些，但是没关系，我们通过分析过程，对照源码，画逻辑流程图来帮助我们理解了其中的过程。最后我们还遗留了一个问题，那就是在更新节点过程中，新旧<code>VNode</code>可能都包含有子节点，对于子节点的对比更新会有额外的一些逻辑，那么在本篇文章中我们就来学习在<code>Vue</code>中是怎么对比更新子节点的。</p>\n<h6 id=\"更新子节点：\"><a href=\"#更新子节点：\" class=\"headerlink\" title=\"更新子节点：\"></a>更新子节点：</h6><p>当新的<code>VNode</code>与旧的<code>oldVNode</code>都是元素节点并且都包含子节点时，那么这两个节点的<code>VNode</code>实例上的<code>children</code>属性就是所包含的子节点数组。我们把新的<code>VNode</code>上的子节点数组记为<code>newChildren</code>，把旧的<code>oldVNode</code>上的子节点数组记为<code>oldChildren</code>，我们把<code>newChildren</code>里面的元素与<code>oldChildren</code>里的元素一一进行对比，对比两个子节点数组肯定是要通过循环，外层循环<code>newChildren</code>数组，内层循环<code>oldChildren</code>数组，每循环外层<code>newChildren</code>数组里的一个子节点，就去内层<code>oldChildren</code>数组里找看有没有与之相同的子节点，伪代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; newChildren.length; i++) &#123;<br>  <span class=\"hljs-keyword\">const</span> newChild = newChildren[i];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">0</span>; j &lt; oldChildren.length; j++) &#123;<br>    <span class=\"hljs-keyword\">const</span> oldChild = oldChildren[j];<br>    <span class=\"hljs-keyword\">if</span> (newChild === oldChild) &#123;<br>      <span class=\"hljs-comment\">// ...</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>那么以上这个过程将会存在以下四种情况：</p>\n<ul>\n<li><p>创建子节点</p>\n<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找不到与之相同的子节点，那么说明<code>newChildren</code>里面的这个子节点是之前没有的，是需要此次新增的节点，那么就创建子节点。</p>\n</li>\n<li><p>删除子节点</p>\n<p>如果把<code>newChildren</code>里面的每一个子节点都循环完毕后，发现在<code>oldChildren</code>还有未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除。</p>\n</li>\n<li><p>移动子节点</p>\n<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以<code>newChildren</code>里子节点的位置为基准，调整<code>oldChildren</code>里该节点的位置，使之与在<code>newChildren</code>里的位置相同。</p>\n</li>\n<li><p>更新节点</p>\n<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找到了与之相同的子节点，并且所处的位置也相同，那么就更新<code>oldChildren</code>里该节点，使之与<code>newChildren</code>里的该节点相同。</p>\n</li>\n</ul>\n<p>OK，到这里，逻辑就相对清晰了，接下来我们只需分门别类的处理这四种情况就好了。</p>\n<h6 id=\"创建子节点\"><a href=\"#创建子节点\" class=\"headerlink\" title=\"创建子节点\"></a>创建子节点</h6><p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找不到与之相同的子节点，那么说明<code>newChildren</code>里面的这个子节点是之前没有的，是需要此次新增的节点，那么我们就创建这个节点，创建好之后再把它插入到<code>DOM</code>中合适的位置。</p>\n<p>创建节点这个很容易，我们在上一篇文章的第三章已经介绍过了，这里就不再赘述了。</p>\n<p>那么创建好之后如何插入到<code>DOM</code>中的合适的位置呢？显然，把节点插入到<code>DOM</code>中是很容易的，找到合适的位置是关键。接下来我们分析一下如何找这个合适的位置。我们看下面这个图：</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425133824295.png\" alt=\"image-20210425133824295\"></p>\n<p>上图中左边是新的<code>VNode</code>，右边是旧的<code>oldVNode</code>，同时也是真实的<code>DOM</code>。这个图意思是当我们循环<code>newChildren</code>数组里面的子节点，前两个子节点都在<code>oldChildren</code>里找到了与之对应的子节点，那么我们将其处理，处理过后把它们标志为已处理，当循环到<code>newChildren</code>数组里第三个子节点时，发现在<code>oldChildren</code>里找不到与之对应的子节点，那么我们就需要创建这个节点，创建好之后我们发现这个节点本是<code>newChildren</code>数组里左起第三个子节点，那么我们就把创建好的节点插入到真实<code>DOM</code>里的第三个节点位置，也就是所有已处理节点之后，OK，此时我们拍手称快，所有已处理节点之后就是我们要找的合适的位置，但是真的是这样吗？我们再来看下面这个图：</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425134249593.png\" alt=\"image-20210425134249593\"></p>\n<p>假如我们按照上面的方法把第三个节点插入到所有已处理节点之后，此时如果第四个节点也在<code>oldChildren</code>里找不到与之对应的节点，也是需要创建的节点，那么当我们把第四个节点也按照上面的说的插入到已处理节点之后，发现怎么插入到第三个位置了，可明明这个节点在<code>newChildren</code>数组里是第四个啊！</p>\n<p>这就是问题所在，其实，我们应该把新创建的节点插入到所有未处理节点之前，这样以来逻辑才正确。后面不管有多少个新增的节点，每一个都插入到所有未处理节点之前，位置才不会错。</p>\n<p>所以，<strong>合适的位置是所有未处理节点之前，而并非所有已处理节点之后</strong>。</p>\n<h6 id=\"删除子节点\"><a href=\"#删除子节点\" class=\"headerlink\" title=\"删除子节点\"></a>删除子节点</h6><p>如果把<code>newChildren</code>里面的每一个子节点都循环一遍，能在<code>oldChildren</code>数组里找到的就处理它，找不到的就新增，直到把<code>newChildren</code>里面所有子节点都过一遍后，发现在<code>oldChildren</code>还存在未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除。</p>\n<p>删除节点这个也很容易，我们在上一篇文章的第四章已经介绍过了，这里就不再赘述了。</p>\n<h6 id=\"更新子节点\"><a href=\"#更新子节点\" class=\"headerlink\" title=\"更新子节点\"></a>更新子节点</h6><p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找到了与之相同的子节点，并且所处的位置也相同，那么就更新<code>oldChildren</code>里该节点，使之与<code>newChildren</code>里的该节点相同。</p>\n<p>关于更新节点，我们在上一篇文章的第五章已经介绍过了，这里就不再赘述了。</p>\n<h6 id=\"移动子节点\"><a href=\"#移动子节点\" class=\"headerlink\" title=\"移动子节点\"></a>移动子节点</h6><p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以<code>newChildren</code>里子节点的位置为基准，调整<code>oldChildren</code>里该节点的位置，使之与在<code>newChildren</code>里的位置相同。</p>\n<p>同样，移动一个节点不难，关键在于该移动到哪，或者说关键在于移动到哪个位置，这个位置才是关键。我们看下图：</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425134557748.png\" alt=\"image-20210425134557748\"></p>\n<p>在上图中，绿色的两个节点是相同节点但是所处位置不同，即<code>newChildren</code>里面的第三个子节点与真实<code>DOM</code>即<code>oldChildren</code>里面的第四个子节点相同但是所处位置不同，按照上面所说的，我们应该以<code>newChildren</code>里子节点的位置为基准，调整<code>oldChildren</code>里该节点的位置，所以我们应该把真实<code>DOM</code>即<code>oldChildren</code>里面的第四个节点移动到第三个节点的位置，通过上图中的标注我们不难发现，<strong>所有未处理节点之前就是我们要移动的目的位置</strong>。如果此时你说那可不可以移动到所有已处理节点之后呢？那就又回到了更新节点时所遇到的那个问题了：如果前面有新增的节点呢？</p>\n<h6 id=\"回到源码\"><a href=\"#回到源码\" class=\"headerlink\" title=\"回到源码\"></a>回到源码</h6><p>OK，以上就是更新子节点时所要考虑的所有情况了，分析完以后，我们回到源码里看看实际情况是不是我们分析的这样子的，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 源码位置： /src/core/vdom/patch.js</span><br><br><span class=\"hljs-keyword\">if</span> (isUndef(idxInOld)) &#123;    <span class=\"hljs-comment\">// 如果在oldChildren里找不到当前循环的newChildren里的子节点</span><br>    <span class=\"hljs-comment\">// 新增节点并插入到合适位置</span><br>    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"hljs-literal\">false</span>, newCh, newStartIdx)<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">// 如果在oldChildren里找到了当前循环的newChildren里的子节点</span><br>    vnodeToMove = oldCh[idxInOld]<br>    <span class=\"hljs-comment\">// 如果两个节点相同</span><br>    <span class=\"hljs-keyword\">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;<br>        <span class=\"hljs-comment\">// 调用patchVnode更新节点</span><br>        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)<br>        oldCh[idxInOld] = <span class=\"hljs-literal\">undefined</span><br>        <span class=\"hljs-comment\">// canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动</span><br>        canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>以上代码中，首先判断在<code>oldChildren</code>里能否找到当前循环的<code>newChildren</code>里的子节点，如果找不到，那就是新增节点并插入到合适位置；如果找到了，先对比两个节点是否相同，若相同则先调用<code>patchVnode</code>更新节点，更新完之后再看是否需要移动节点，注意，源码里在判断是否需要移动子节点时用了简写的方式，下面这两种写法是等价的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">if</span>(canMove)&#123;<br>    nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们看到，源码里的实现跟我们分析的是一样一样的。</p>\n<h6 id=\"总结：：\"><a href=\"#总结：：\" class=\"headerlink\" title=\"总结：：\"></a>总结：：</h6><p>本篇文章我们分析了<code>Vue</code>在更新子节点时是外层循环<code>newChildren</code>数组，内层循环<code>oldChildren</code>数组，把<code>newChildren</code>数组里的每一个元素分别与<code>oldChildren</code>数组里的每一个元素匹配，根据不同情况作出创建子节点、删除子节点、更新子节点以及移动子节点的操作。并且我们对不同情况的不同操作都进行了深入分析，分析之后我们回到源码验证我们分析的正确性，发现我们的分析跟源码的实现是一致的。</p>\n<p>最后，我们再思考一个问题：这样双层循环虽然能解决问题，但是如果节点数量很多，这样循环算法的时间复杂度会不会很高？有没有什么可以优化的办法？答案当然是有的，并且<code>Vue</code>也意识到了这点，也进行了优化，那么下篇文章我们就来分析当节点数量很多时<code>Vue</code>是怎么优化算法的。</p>\n<h6 id=\"优化更新子节点\"><a href=\"#优化更新子节点\" class=\"headerlink\" title=\"优化更新子节点\"></a>优化更新子节点</h6><p>在上一篇文章中，我们介绍了当新的<code>VNode</code>与旧的<code>oldVNode</code>都是元素节点并且都包含子节点时，<code>Vue</code>对子节点是</p>\n<p>先外层循环<code>newChildren</code>数组，再内层循环<code>oldChildren</code>数组，每循环外层<code>newChildren</code>数组里的一个子节点，就去内层<code>oldChildren</code>数组里找看有没有与之相同的子节点，最后根据不同的情况作出不同的操作。</p>\n<p>在上一篇文章的结尾我们也说了，这种方法虽然能够解决问题，但是还存在可优化的地方。比如当包含的子节点数量很多时，这样循环算法的时间复杂度就会变的很大，不利于性能提升。当然，<code>Vue</code>也意识到了这点，并对此也进行了优化，那么本篇文章，就来学习一下关于子节点更新的优化问题<code>Vue</code>是如何做的。</p>\n<h6 id=\"优化策略介绍：\"><a href=\"#优化策略介绍：\" class=\"headerlink\" title=\"优化策略介绍：\"></a>优化策略介绍：</h6><p>假如我们现有一份新的<code>newChildren</code>数组和旧的<code>oldChildren</code>数组，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">newChildren = [<span class=\"hljs-string\">&#x27;新子节点1&#x27;</span>,<span class=\"hljs-string\">&#x27;新子节点2&#x27;</span>,<span class=\"hljs-string\">&#x27;新子节点3&#x27;</span>,<span class=\"hljs-string\">&#x27;新子节点4&#x27;</span>]<br>oldChildren = [<span class=\"hljs-string\">&#x27;旧子节点1&#x27;</span>,<span class=\"hljs-string\">&#x27;旧子节点2&#x27;</span>,<span class=\"hljs-string\">&#x27;旧子节点3&#x27;</span>,<span class=\"hljs-string\">&#x27;旧子节点4&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n<p>如果按照优化之前的解决方案，那么我们接下来的操作应该是这样的：先循环<code>newChildren</code>数组，拿到第一个新子节点1，然后用第一个新子节点1去跟<code>oldChildren</code>数组里的旧子节点逐一对比，如果运气好一点，刚好<code>oldChildren</code>数组里的第一个旧子节点1与第一个新子节点1相同，那就皆大欢喜，直接处理，不用再往下循环了。那如果运气坏一点，直到循环到<code>oldChildren</code>数组里的第四个旧子节点4才与第一个新子节点1相同，那此时就会多循环了4次。我们不妨把情况再设想的极端一点，如果<code>newChildren</code>数组和<code>oldChildren</code>数组里前三个节点都没有变化，只是第四个节点发生了变化，那么我们就会循环16次，只有在第16次循环的时候才发现新节点4与旧节点4相同，进行更新，如下图所示：</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425135252298.png\" alt=\"image-20210425135252298\">    </p>\n<p>上面例子中只有四个子节点，好像还看不出来有什么缺陷，但是当子节点数量很多的时候，算法的时间复杂度就会非常高，很不利于性能提升。</p>\n<p>那么我们该怎么优化呢？其实我们可以这样想，我们不要按顺序去循环<code>newChildren</code>和<code>oldChildren</code>这两个数组，可以先比较这两个数组里特殊位置的子节点，比如：</p>\n<ul>\n<li><p>先把<code>newChildren</code>数组里的所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作；</p>\n</li>\n<li><p>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作；</p>\n</li>\n<li><p>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</p>\n</li>\n<li><p>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</p>\n</li>\n<li><p>最后四种情况都试完如果还不同，那就按照之前循环的方式来查找节点。上面例子中只有四个子节点，好像还看不出来有什么缺陷，但是当子节点数量很多的时候，算法的时间复杂度就会非常高，很不利于性能提升。</p>\n<p>那么我们该怎么优化呢？其实我们可以这样想，我们不要按顺序去循环<code>newChildren</code>和<code>oldChildren</code>这两个数组，可以先比较这两个数组里特殊位置的子节点，比如：</p>\n<ul>\n<li>先把<code>newChildren</code>数组里的所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作；</li>\n<li>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作；</li>\n<li>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</li>\n<li>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</li>\n<li>最后四种情况都试完如果还不同，那就按照之前循环的方式来查找节点。</li>\n</ul>\n</li>\n</ul>\n<p>其过程如下图所示：</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425135454618.png\" alt=\"image-20210425135454618\"></p>\n<p>在上图中，我们把：</p>\n<ul>\n<li><code>newChildren</code>数组里的所有未处理子节点的第一个子节点称为：新前；</li>\n<li><code>newChildren</code>数组里的所有未处理子节点的最后一个子节点称为：新后；</li>\n<li><code>oldChildren</code>数组里的所有未处理子节点的第一个子节点称为：旧前；</li>\n<li><code>oldChildren</code>数组里的所有未处理子节点的最后一个子节点称为：旧后；</li>\n</ul>\n<p>OK，有了以上概念以后，下面我们就来看看其具体是如何实施的。</p>\n<h6 id=\"新前与旧前\"><a href=\"#新前与旧前\" class=\"headerlink\" title=\"新前与旧前\"></a>新前与旧前</h6><p>把<code>newChildren</code>数组里的所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那好极了，直接进入之前文章中说的更新节点的操作并且由于新前与旧前两个节点的位置也相同，无需进行节点移动操作；如果不同，没关系，再尝试后面三种情况。</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425135923348.png\" alt=\"image-20210425135923348\"></p>\n<h6 id=\"新后与旧后\"><a href=\"#新后与旧后\" class=\"headerlink\" title=\"新后与旧后\"></a>新后与旧后</h6><p>把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作并且由于新后与旧后两个节点的位置也相同，无需进行节点移动操作；如果不同，继续往后尝试。</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425140013890.png\" alt=\"image-20210425140013890\"></p>\n<h5 id=\"新后与旧前\"><a href=\"#新后与旧前\" class=\"headerlink\" title=\"新后与旧前\"></a>新后与旧前</h5><p>把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425140051237.png\" alt=\"image-20210425140051237\"></p>\n<p>此时，出现了移动节点的操作，移动节点最关键的地方在于找准要移动的位置。我们一再强调，<strong>更新节点要以新<code>VNode</code>为基准，然后操作旧的<code>oldVNode</code>，使之最后旧的<code>oldVNode</code>与新的<code>VNode</code>相同</strong>。那么现在的情况是：<code>newChildren</code>数组里的最后一个子节点与<code>oldChildren</code>数组里的第一个子节点相同，那么我们就应该在<code>oldChildren</code>数组里把第一个子节点移动到最后一个子节点的位置，如下图：</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425140208880.png\" alt=\"image-20210425140208880\"></p>\n<p>从图中不难看出，我们要把<code>oldChildren</code>数组里把第一个子节点移动到数组中<strong>所有未处理节点之后</strong>。</p>\n<p>如果对比之后发现这两个节点仍不是同一个节点，那就继续尝试最后一种情况。</p>\n<h6 id=\"新前与旧后\"><a href=\"#新前与旧后\" class=\"headerlink\" title=\"新前与旧后\"></a>新前与旧后</h6><p>把<code>newChildren</code>数组里所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425140311007.png\" alt=\"image-20210425140311007\"></p>\n<p>同样，这种情况的节点移动位置逻辑与“新后与旧前”的逻辑类似，那就是<code>newChildren</code>数组里的第一个子节点与<code>oldChildren</code>数组里的最后一个子节点相同，那么我们就应该在<code>oldChildren</code>数组里把最后一个子节点移动到第一个子节点的位置，如下图：</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425140415224.png\" alt=\"image-20210425140415224\"></p>\n<p>从图中不难看出，我们要把<code>oldChildren</code>数组里把最后一个子节点移动到数组中<strong>所有未处理节点之前</strong>。</p>\n<p>OK，以上就是子节点对比更新优化策略种的4种情况，如果以上4种情况逐个试遍之后要是还没找到相同的节点，那就再通过之前的循环方式查找。</p>\n<h6 id=\"回到源码：：\"><a href=\"#回到源码：：\" class=\"headerlink\" title=\"回到源码：：\"></a>回到源码：：</h6><p>思路分析完，逻辑理清之后，我们再回到源码里看看，验证一下源码实现的逻辑是否跟我们分析的一样。源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 循环更新子节点</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">updateChildren</span> (<span class=\"hljs-params\">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">let</span> oldStartIdx = <span class=\"hljs-number\">0</span>               <span class=\"hljs-comment\">// oldChildren开始索引</span><br>    <span class=\"hljs-keyword\">let</span> oldEndIdx = oldCh.length - <span class=\"hljs-number\">1</span>   <span class=\"hljs-comment\">// oldChildren结束索引</span><br>    <span class=\"hljs-keyword\">let</span> oldStartVnode = oldCh[<span class=\"hljs-number\">0</span>]        <span class=\"hljs-comment\">// oldChildren中所有未处理节点中的第一个</span><br>    <span class=\"hljs-keyword\">let</span> oldEndVnode = oldCh[oldEndIdx]   <span class=\"hljs-comment\">// oldChildren中所有未处理节点中的最后一个</span><br><br>    <span class=\"hljs-keyword\">let</span> newStartIdx = <span class=\"hljs-number\">0</span>               <span class=\"hljs-comment\">// newChildren开始索引</span><br>    <span class=\"hljs-keyword\">let</span> newEndIdx = newCh.length - <span class=\"hljs-number\">1</span>   <span class=\"hljs-comment\">// newChildren结束索引</span><br>    <span class=\"hljs-keyword\">let</span> newStartVnode = newCh[<span class=\"hljs-number\">0</span>]        <span class=\"hljs-comment\">// newChildren中所有未处理节点中的第一个</span><br>    <span class=\"hljs-keyword\">let</span> newEndVnode = newCh[newEndIdx]  <span class=\"hljs-comment\">// newChildren中所有未处理节点中的最后一个</span><br><br>    <span class=\"hljs-keyword\">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm<br><br>    <span class=\"hljs-comment\">// removeOnly is a special flag used only by &lt;transition-group&gt;</span><br>    <span class=\"hljs-comment\">// to ensure removed elements stay in correct relative positions</span><br>    <span class=\"hljs-comment\">// during leaving transitions</span><br>    <span class=\"hljs-keyword\">const</span> canMove = !removeOnly<br><br>    <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">&#x27;production&#x27;</span>) &#123;<br>      checkDuplicateKeys(newCh)<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 以&quot;新前&quot;、&quot;新后&quot;、&quot;旧前&quot;、&quot;旧后&quot;的方式开始比对节点</span><br>    <span class=\"hljs-keyword\">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;<br>      <span class=\"hljs-keyword\">if</span> (isUndef(oldStartVnode)) &#123;<br>        oldStartVnode = oldCh[++oldStartIdx] <span class=\"hljs-comment\">// 如果oldStartVnode不存在，则直接跳过，比对下一个</span><br>      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isUndef(oldEndVnode)) &#123;<br>        oldEndVnode = oldCh[--oldEndIdx]<br>      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;<br>        <span class=\"hljs-comment\">// 如果新前与旧前节点相同，就把两个节点进行patch更新</span><br>        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)<br>        oldStartVnode = oldCh[++oldStartIdx]<br>        newStartVnode = newCh[++newStartIdx]<br>      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;<br>        <span class=\"hljs-comment\">// 如果新后与旧后节点相同，就把两个节点进行patch更新</span><br>        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)<br>        oldEndVnode = oldCh[--oldEndIdx]<br>        newEndVnode = newCh[--newEndIdx]<br>      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class=\"hljs-comment\">// Vnode moved right</span><br>        <span class=\"hljs-comment\">// 如果新后与旧前节点相同，先把两个节点进行patch更新，然后把旧前节点移动到oldChilren中所有未处理节点之后</span><br>        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)<br>        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))<br>        oldStartVnode = oldCh[++oldStartIdx]<br>        newEndVnode = newCh[--newEndIdx]<br>      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class=\"hljs-comment\">// Vnode moved left</span><br>        <span class=\"hljs-comment\">// 如果新前与旧后节点相同，先把两个节点进行patch更新，然后把旧后节点移动到oldChilren中所有未处理节点之前</span><br>        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)<br>        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)<br>        oldEndVnode = oldCh[--oldEndIdx]<br>        newStartVnode = newCh[++newStartIdx]<br>      &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-comment\">// 如果不属于以上四种情况，就进行常规的循环比对patch</span><br>        <span class=\"hljs-keyword\">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)<br>        idxInOld = isDef(newStartVnode.key)<br>          ? oldKeyToIdx[newStartVnode.key]<br>          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)<br>        <span class=\"hljs-comment\">// 如果在oldChildren里找不到当前循环的newChildren里的子节点</span><br>        <span class=\"hljs-keyword\">if</span> (isUndef(idxInOld)) &#123; <span class=\"hljs-comment\">// New element</span><br>          <span class=\"hljs-comment\">// 新增节点并插入到合适位置</span><br>          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"hljs-literal\">false</span>, newCh, newStartIdx)<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>          <span class=\"hljs-comment\">// 如果在oldChildren里找到了当前循环的newChildren里的子节点</span><br>          vnodeToMove = oldCh[idxInOld]<br>          <span class=\"hljs-comment\">// 如果两个节点相同</span><br>          <span class=\"hljs-keyword\">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;<br>            <span class=\"hljs-comment\">// 调用patchVnode更新节点</span><br>            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)<br>            oldCh[idxInOld] = <span class=\"hljs-literal\">undefined</span><br>            <span class=\"hljs-comment\">// canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动</span><br>            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)<br>          &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">// same key but different element. treat as new element</span><br>            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"hljs-literal\">false</span>, newCh, newStartIdx)<br>          &#125;<br>        &#125;<br>        newStartVnode = newCh[++newStartIdx]<br>      &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (oldStartIdx &gt; oldEndIdx) &#123;<br>      <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">       * 如果oldChildren比newChildren先循环完毕，</span><br><span class=\"hljs-comment\">       * 那么newChildren里面剩余的节点都是需要新增的节点，</span><br><span class=\"hljs-comment\">       * 把[newStartIdx, newEndIdx]之间的所有节点都插入到DOM中</span><br><span class=\"hljs-comment\">       */</span><br>      refElm = isUndef(newCh[newEndIdx + <span class=\"hljs-number\">1</span>]) ? <span class=\"hljs-literal\">null</span> : newCh[newEndIdx + <span class=\"hljs-number\">1</span>].elm<br>      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (newStartIdx &gt; newEndIdx) &#123;<br>      <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">       * 如果newChildren比oldChildren先循环完毕，</span><br><span class=\"hljs-comment\">       * 那么oldChildren里面剩余的节点都是需要删除的节点，</span><br><span class=\"hljs-comment\">       * 把[oldStartIdx, oldEndIdx]之间的所有节点都删除</span><br><span class=\"hljs-comment\">       */</span><br>      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>读源码之前，我们先有这样一个概念：那就是在我们前面所说的优化策略中，节点有可能是从前面对比，也有可能是从后面对比，对比成功就会进行更新处理，也就是说我们有可能处理第一个，也有可能处理最后一个，那么我们在循环的时候就不能简单从前往后或从后往前循环，而是要从两边向中间循环。</p>\n<p>那么该如何从两边向中间循环呢？请看下图：</p>\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210425140631885.png\" alt=\"image-20210425140631885\"></p>\n<p>首先，我们先准备4个变量：</p>\n<ul>\n<li><strong>newStartIdx:</strong><code>newChildren</code>数组里开始位置的下标；</li>\n<li><strong>newEndIdx:</strong><code>newChildren</code>数组里结束位置的下标；</li>\n<li><strong>oldStartIdx:</strong><code>oldChildren</code>数组里开始位置的下标；</li>\n<li><strong>oldEndIdx:</strong><code>oldChildren</code>数组里结束位置的下标；</li>\n</ul>\n<p>在循环的时候，每处理一个节点，就将下标向图中箭头所指的方向移动一个位置，开始位置所表示的节点被处理后，就向后移动一个位置；结束位置所表示的节点被处理后，就向前移动一个位置；由于我们的优化策略都是新旧节点两两更新的，所以一次更新将会移动两个节点。说的再直白一点就是：<code>newStartIdx</code>和<code>oldStartIdx</code>只能往后移动（只会加），<code>newEndIdx</code>和<code>oldEndIdx</code>只能往前移动（只会减）。</p>\n<p>当开始位置大于结束位置时，表示所有节点都已经遍历过了。</p>\n<p>OK，有了这个概念后，我们开始读源码：</p>\n<ol>\n<li>如果<code>oldStartVnode</code>不存在，则直接跳过，将<code>oldStartIdx</code>加1，比对下一个</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 以&quot;新前&quot;、&quot;新后&quot;、&quot;旧前&quot;、&quot;旧后&quot;的方式开始比对节点</span><br><span class=\"hljs-keyword\">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;<br>\t<span class=\"hljs-keyword\">if</span> (isUndef(oldStartVnode)) &#123;<br>        oldStartVnode = oldCh[++oldStartIdx]<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果<code>oldEndVnode</code>不存在，则直接跳过，将<code>oldEndIdx</code>减1，比对前一个</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isUndef(oldEndVnode)) &#123;<br>    oldEndVnode = oldCh[--oldEndIdx]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果新前与旧前节点相同，就把两个节点进行<code>patch</code>更新，同时<code>oldStartIdx</code>和<code>newStartIdx</code>都加1，后移一个位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;<br>    patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)<br>    oldStartVnode = oldCh[++oldStartIdx]<br>    newStartVnode = newCh[++newStartIdx]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果新后与旧后节点相同，就把两个节点进行<code>patch</code>更新，同时<code>oldEndIdx</code>和<code>newEndIdx</code>都减1，前移一个位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;<br>    patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)<br>    oldEndVnode = oldCh[--oldEndIdx]<br>    newEndVnode = newCh[--newEndIdx]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果新后与旧前节点相同，先把两个节点进行<code>patch</code>更新，然后把旧前节点移动到<code>oldChilren</code>中所有未处理节点之后，最后把<code>oldStartIdx</code>加1，后移一个位置，<code>newEndIdx</code>减1，前移一个位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123;<br>    patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)<br>    canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))<br>    oldStartVnode = oldCh[++oldStartIdx]<br>    newEndVnode = newCh[--newEndIdx]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果新前与旧后节点相同，先把两个节点进行<code>patch</code>更新，然后把旧后节点移动到<code>oldChilren</code>中所有未处理节点之前，最后把<code>newStartIdx</code>加1，后移一个位置，<code>oldEndIdx</code>减1，前移一个位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class=\"hljs-comment\">// Vnode moved left</span><br>    patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)<br>    canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)<br>    oldEndVnode = oldCh[--oldEndIdx]<br>    newStartVnode = newCh[++newStartIdx]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果不属于以上四种情况，就进行常规的循环比对<code>patch</code></p>\n<p>如果在循环中，<code>oldStartIdx</code>大于<code>oldEndIdx</code>了，那就表示<code>oldChildren</code>比<code>newChildren</code>先循环完毕，那么<code>newChildren</code>里面剩余的节点都是需要新增的节点，把<code>[newStartIdx, newEndIdx]</code>之间的所有节点都插入到<code>DOM</code>中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">if</span> (oldStartIdx &gt; oldEndIdx) &#123;<br>    refElm = isUndef(newCh[newEndIdx + <span class=\"hljs-number\">1</span>]) ? <span class=\"hljs-literal\">null</span> : newCh[newEndIdx + <span class=\"hljs-number\">1</span>].elm<br>    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果在循环中，<code>newStartIdx</code>大于<code>newEndIdx</code>了，那就表示<code>newChildren</code>比<code>oldChildren</code>先循环完毕，那么<code>oldChildren</code>里面剩余的节点都是需要删除的节点，把<code>[oldStartIdx, oldEndIdx]</code>之间的所有节点都删除</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (newStartIdx &gt; newEndIdx) &#123;<br>    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>OK,处理完毕，可见源码中的处理逻辑跟我们之前分析的逻辑是一样的。</p>\n<h6 id=\"总结：-1\"><a href=\"#总结：-1\" class=\"headerlink\" title=\"总结：\"></a>总结：</h6><p>本篇文章中，我们介绍了<code>Vue</code>中子节点更新的优化策略，发现<code>Vue</code>为了避免双重循环数据量大时间复杂度升高带来的性能问题，而选择了从子节点数组中的4个特殊位置互相比对，分别是：新前与旧前，新后与旧后，新后与旧前，新前与旧后。对于每一种情况我们都通过图文的形式对其逻辑进行了分析。最后我们回到源码，通过阅读源码来验证我们分析的是否正确。幸运的是我们之前每一步的分析都在源码中找到了相应的实现，得以验证我们的分析没有错。以上就是<code>Vue</code>中的<code>patch</code>过程，即<code>DOM-Diff</code>算法所有内容了，到这里相信你再读这部分源码的时候就有比较清晰的思路了。</p>\n<p>撸码一时爽，一直撸码一直爽！！！</p>\n","raw":null,"categories":[],"tags":[{"name":"vue源码理解——虚拟DOM篇","path":"api/tags/vue源码理解——虚拟DOM篇.json"}]},{"title":"es6","slug":"es6","date":"2020-09-18T11:29:18.000Z","updated":"2021-06-02T03:12:06.519Z","comments":true,"top":null,"path":"api/articles/es6.json","excerpt":null,"keywords":null,"cover":null,"content":"<p>…</p>\n<h4 id=\"let：\"><a href=\"#let：\" class=\"headerlink\" title=\"let：\"></a>let：</h4><p>块级作用域；</p>\n<p>用{}来表示块级作用域；</p>\n<p>暂时性死区：在同一个作用域内，let声明变量x，那么在这一行代码之前就是x的暂时性死区‘’暂时性死区‘’也意味着typeof不再是一个百分之白安全的操作；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">typeof</span> x;<span class=\"hljs-comment\">//ReferenceError</span><br><span class=\"hljs-keyword\">let</span> x<br><span class=\"hljs-keyword\">typeof</span> undeclar_variable<span class=\"hljs-comment\">//&#x27;undefined&#x27;没有声明反而不会报错</span><br><br><br><span class=\"hljs-comment\">//不报错</span><br><span class=\"hljs-keyword\">var</span> x=x<br><br><span class=\"hljs-comment\">//报错</span><br><span class=\"hljs-keyword\">let</span> x=x<br><span class=\"hljs-comment\">//ReferenceError:x is not definde</span><br></code></pre></td></tr></table></figure>\n\n<p>不能变量提升（变量提升，即变量可以在声明之前使用），let所声明的变量一定要在声明后使用</p>\n<p>不能重复声明：let x；var x；（不可以）</p>\n<p>不能在函数内部重新声明函数</p>\n<h4 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h4><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>\n<p>具有let的特点</p>\n<p>const一旦声明变量，就必须立即初始化，不能到以后赋值。；</p>\n<p>不能重复赋值：const x=100；x=200；（不可以）</p>\n<p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</p>\n<p>如果const的值是一个对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> o=&#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&#x27;zs&#x27;</span>,<span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">10</span>&#125;<br>o=&#123;&#125;<span class=\"hljs-comment\">//报错</span><br>o.name=<span class=\"hljs-string\">&#x27;lisi&#x27;</span><span class=\"hljs-comment\">//可以</span><br><br></code></pre></td></tr></table></figure>\n\n<p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-built_in\">Object</span>.freeze(&#123;&#125;);<br><br><span class=\"hljs-comment\">// 常规模式时，下面一行不起作用；</span><br><span class=\"hljs-comment\">// 严格模式时，该行会报错</span><br>foo.prop = <span class=\"hljs-number\">123</span>;<br><br><span class=\"hljs-comment\">//将对象彻底冻结的函数</span><br><span class=\"hljs-keyword\">var</span> constantize = <span class=\"hljs-function\">(<span class=\"hljs-params\">obj</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">Object</span>.freeze(obj);<br>  <span class=\"hljs-built_in\">Object</span>.keys(obj).forEach( <span class=\"hljs-function\">(<span class=\"hljs-params\">key, i</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> ( <span class=\"hljs-keyword\">typeof</span> obj[key] === <span class=\"hljs-string\">&#x27;object&#x27;</span> ) &#123;<br>      constantize( obj[key] );<br>    &#125;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h4><p>Symbol表示独一无二的值，凡是属性名属于symbol类型，那都是独一无二的，可以保证不会与其他属性名产生冲突，他是javascript语言的第七种数据类型。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> s=<span class=\"hljs-built_in\">Symbol</span>()<br><span class=\"hljs-keyword\">typeof</span> s<br><span class=\"hljs-comment\">//&#x27;symbol&#x27;</span><br><br></code></pre></td></tr></table></figure>\n\n<p>如果Symbol的参数是一个对象，就会调用该对象的tostring方法，将其转为字符串，然后生成一个Symbol值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  toString() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;abc&#x27;</span>;<br>  &#125;<br>&#125;;<br><span class=\"hljs-keyword\">const</span> sym = <span class=\"hljs-built_in\">Symbol</span>(obj);<br>sym <span class=\"hljs-comment\">// Symbol(abc)</span><br><br><br><span class=\"hljs-comment\">//Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。</span><br><span class=\"hljs-comment\">// 没有参数的情况</span><br><span class=\"hljs-keyword\">let</span> s1 = <span class=\"hljs-built_in\">Symbol</span>();<br><span class=\"hljs-keyword\">let</span> s2 = <span class=\"hljs-built_in\">Symbol</span>();<br><br>s1 === s2 <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-comment\">// 有参数的情况</span><br><span class=\"hljs-keyword\">let</span> s1 = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br><span class=\"hljs-keyword\">let</span> s2 = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br><br>s1 === s2 <span class=\"hljs-comment\">// false</span><br><br><br><span class=\"hljs-keyword\">let</span> sym = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">&#x27;My symbol&#x27;</span>);<span class=\"hljs-comment\">//Symbol 值不能与其他类型的值进行运算，会报错。</span><br><span class=\"hljs-string\">&quot;your symbol is &quot;</span> + sym<br><span class=\"hljs-comment\">// TypeError: can&#x27;t convert symbol to string</span><br><span class=\"hljs-string\">`your symbol is <span class=\"hljs-subst\">$&#123;sym&#125;</span>`</span><br><span class=\"hljs-comment\">// TypeError: can&#x27;t convert symbol to string</span><br><br><span class=\"hljs-keyword\">let</span> sym = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">&#x27;My symbol&#x27;</span>);<span class=\"hljs-comment\">//Symbol 值可以显式转为字符串</span><br><span class=\"hljs-built_in\">String</span>(sym) <span class=\"hljs-comment\">// &#x27;Symbol(My symbol)&#x27;</span><br>sym.toString() <span class=\"hljs-comment\">// &#x27;Symbol(My symbol)&#x27;</span><br><br><span class=\"hljs-keyword\">let</span> sym = <span class=\"hljs-built_in\">Symbol</span>();<span class=\"hljs-comment\">//Symbol 值也可以转为布尔值，但是不能转为数值</span><br><span class=\"hljs-built_in\">Boolean</span>(sym) <span class=\"hljs-comment\">// true</span><br>!sym  <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-keyword\">if</span> (sym) &#123;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;<br><span class=\"hljs-built_in\">Number</span>(sym) <span class=\"hljs-comment\">// TypeError</span><br>sym + <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// TypeError</span><br></code></pre></td></tr></table></figure>\n\n<p>由于每一个Symbol都是不相等的，这意味着symbol值可以作为标识，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> mySymbol=symbol();<br><br><span class=\"hljs-comment\">//第一种写法</span><br><span class=\"hljs-keyword\">let</span> a=&#123;&#125;<br>a[mySmbol]=<span class=\"hljs-string\">&#x27;hellow&#x27;</span><br><br><span class=\"hljs-comment\">//第二种写法</span><br><span class=\"hljs-keyword\">let</span> a=&#123;<br>    [mySmbol]:<span class=\"hljs-string\">&#x27;hellow&#x27;</span><br>&#125;;<br><br><span class=\"hljs-comment\">//第三种写法</span><br><span class=\"hljs-keyword\">let</span> a=&#123;&#125;<br><span class=\"hljs-built_in\">Object</span>.defineProperty(a, mySymbol, &#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;Hello!&#x27;</span> &#125;);<br><span class=\"hljs-comment\">// 以上写法都得到同样结果</span><br>a[mySymbol] <span class=\"hljs-comment\">// &quot;Hello!&quot;</span><br><br><span class=\"hljs-comment\">//Symbol 值作为对象属性名时，不能用点运算符</span><br><span class=\"hljs-keyword\">const</span> mySymbol = <span class=\"hljs-built_in\">Symbol</span>();<br><span class=\"hljs-keyword\">const</span> a = &#123;&#125;;<br>a.mySymbol = <span class=\"hljs-string\">&#x27;Hello!&#x27;</span>;<span class=\"hljs-comment\">//因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值</span><br>a[mySymbol] <span class=\"hljs-comment\">// undefined</span><br>a[<span class=\"hljs-string\">&#x27;mySymbol&#x27;</span>] <span class=\"hljs-comment\">// &quot;Hello!&quot;</span><br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"解构赋值：\"><a href=\"#解构赋值：\" class=\"headerlink\" title=\"解构赋值：\"></a>解构赋值：</h3><h3 id=\"扩展运算符…\"><a href=\"#扩展运算符…\" class=\"headerlink\" title=\"扩展运算符…\"></a>扩展运算符…</h3><p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环</p>\n<p>rest参数 函数的形参</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\">a,b,...args</span>)</span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(a,b,args);<br>&#125;<br>fn(<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">40</span>,<span class=\"hljs-number\">50</span>)<br></code></pre></td></tr></table></figure>\n\n<p>数组的扩展运算符</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> arr=[<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>];<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\">a,b,c</span>)</span>&#123;&#125;<br>fn(...arr);<br><span class=\"hljs-keyword\">var</span> arr2=[...arr];<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p>类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>();<br><br>[<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>].forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> s.add(x));<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">of</span> s) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(i);<br>&#125;<br><span class=\"hljs-comment\">// 2 3 5 4 //通过add()方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值</span><br><br><br><span class=\"hljs-comment\">// 例一</span><br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>]);<br>[...set]<br><span class=\"hljs-comment\">// [1, 2, 3, 4]</span><br><span class=\"hljs-comment\">// 例二</span><br><span class=\"hljs-keyword\">const</span> items = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">5</span>]);<br>items.size <span class=\"hljs-comment\">// 5</span><br><span class=\"hljs-comment\">// 例三</span><br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>(<span class=\"hljs-built_in\">document</span>.querySelectorAll(<span class=\"hljs-string\">&#x27;div&#x27;</span>));<br>set.size <span class=\"hljs-comment\">// 56</span><br><span class=\"hljs-comment\">// 类似于</span><br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>();<br><span class=\"hljs-built_in\">document</span><br> .querySelectorAll(<span class=\"hljs-string\">&#x27;div&#x27;</span>)<br> .forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">div</span> =&gt;</span> set.add(div));<br>set.size <span class=\"hljs-comment\">// 56</span><br></code></pre></td></tr></table></figure>\n\n<p>set用于去重</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 去除数组的重复成员</span><br>[...new <span class=\"hljs-built_in\">Set</span>(array)]<br><span class=\"hljs-comment\">//去除字符串里面的重复字符</span><br>[...new <span class=\"hljs-built_in\">Set</span>(<span class=\"hljs-string\">&#x27;ababbc&#x27;</span>)].join(<span class=\"hljs-string\">&#x27;&#x27;</span>)<br><span class=\"hljs-comment\">// &quot;abc&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>();<br><span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-literal\">NaN</span>;<br><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-literal\">NaN</span>;<br>set.add(a);<br>set.add(b);<br>set <span class=\"hljs-comment\">// Set &#123;NaN&#125;  //只添加了一个NaN，表明在 Set 内部，两个NaN是相等的</span><br><span class=\"hljs-comment\">//两个对象总是不相等的</span><br><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>();<br>set.add(&#123;&#125;);<br>set.size <span class=\"hljs-comment\">// 1</span><br>set.add(&#123;&#125;);<br>set.size <span class=\"hljs-comment\">// 2  由于两个空对象不相等，所以它们被视为两个值</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//Set 结构的实例有以下属性：</span><br><span class=\"hljs-built_in\">Set</span>.prototype.constructor：构造函数，默认就是<span class=\"hljs-built_in\">Set</span>函数。<br><span class=\"hljs-built_in\">Set</span>.prototype.size：返回<span class=\"hljs-built_in\">Set</span>实例的成员总数。<br><span class=\"hljs-comment\">//Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。</span><br><span class=\"hljs-comment\">//四个操作方法</span><br><span class=\"hljs-built_in\">Set</span>.prototype.add(value)：添加某个值，返回 <span class=\"hljs-built_in\">Set</span> 结构本身。<br><span class=\"hljs-built_in\">Set</span>.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。<br><span class=\"hljs-built_in\">Set</span>.prototype.has(value)：返回一个布尔值，表示该值是否为<span class=\"hljs-built_in\">Set</span>的成员。<br><span class=\"hljs-built_in\">Set</span>.prototype.clear()：清除所有成员，没有返回值。<br><br>s.add(<span class=\"hljs-number\">1</span>).add(<span class=\"hljs-number\">2</span>).add(<span class=\"hljs-number\">2</span>);<br><span class=\"hljs-comment\">// 注意2被加入了两次</span><br>s.size <span class=\"hljs-comment\">// 2</span><br>s.has(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// true</span><br>s.has(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// true</span><br>s.has(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">// false</span><br>s.delete(<span class=\"hljs-number\">2</span>);<br>s.has(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-comment\">//Set 结构的实例有四个遍历方法，可以用于遍历成员，Set的遍历顺序就是插入顺序。</span><br><span class=\"hljs-built_in\">Set</span>.prototype.keys()：返回键名的遍历器<br><span class=\"hljs-built_in\">Set</span>.prototype.values()：返回键值的遍历器<br><span class=\"hljs-built_in\">Set</span>.prototype.entries()：返回键值对的遍历器<br><span class=\"hljs-built_in\">Set</span>.prototype.forEach()：使用回调函数遍历每个成员<br><br><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-string\">&#x27;red&#x27;</span>, <span class=\"hljs-string\">&#x27;green&#x27;</span>, <span class=\"hljs-string\">&#x27;blue&#x27;</span>]);<br><span class=\"hljs-comment\">//keys方法、values方法、entries方法返回的都是遍历器对象，由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> set.keys()) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(item);<br>&#125;<br><span class=\"hljs-comment\">// red</span><br><span class=\"hljs-comment\">// green</span><br><span class=\"hljs-comment\">// blue</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> set.values()) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(item);<br>&#125;<br><span class=\"hljs-comment\">// red</span><br><span class=\"hljs-comment\">// green</span><br><span class=\"hljs-comment\">// blue</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> set.entries()) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(item);<br>&#125;<br><span class=\"hljs-comment\">// [&quot;red&quot;, &quot;red&quot;]</span><br><span class=\"hljs-comment\">// [&quot;green&quot;, &quot;green&quot;]</span><br><span class=\"hljs-comment\">// [&quot;blue&quot;, &quot;blue&quot;]</span><br><br><span class=\"hljs-comment\">//Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。</span><br><span class=\"hljs-built_in\">Set</span>.prototype[<span class=\"hljs-built_in\">Symbol</span>.iterator] === <span class=\"hljs-built_in\">Set</span>.prototype.values<br><span class=\"hljs-comment\">// true</span><br><span class=\"hljs-comment\">//这意味着，可以省略values方法，直接用for...of循环遍历 Set。</span><br><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-string\">&#x27;red&#x27;</span>, <span class=\"hljs-string\">&#x27;green&#x27;</span>, <span class=\"hljs-string\">&#x27;blue&#x27;</span>]);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> x <span class=\"hljs-keyword\">of</span> set) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(x);<br>&#125;<br><span class=\"hljs-comment\">// red</span><br><span class=\"hljs-comment\">// green</span><br><span class=\"hljs-comment\">// blue</span><br><br><span class=\"hljs-comment\">//Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</span><br><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">9</span>]);<br>set.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">value, key</span>) =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(key + <span class=\"hljs-string\">&#x27; : &#x27;</span> + value))<br><span class=\"hljs-comment\">// 1 : 1</span><br><span class=\"hljs-comment\">// 4 : 4</span><br><span class=\"hljs-comment\">// 9 : 9</span><br><br><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-string\">&#x27;red&#x27;</span>, <span class=\"hljs-string\">&#x27;green&#x27;</span>, <span class=\"hljs-string\">&#x27;blue&#x27;</span>]);<br><span class=\"hljs-keyword\">let</span> arr = [...set];<br><span class=\"hljs-comment\">// [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]</span><br><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">5</span>];<br><span class=\"hljs-keyword\">let</span> unique = [...new <span class=\"hljs-built_in\">Set</span>(arr)];<br><span class=\"hljs-comment\">// [3, 5, 2]</span><br><br><span class=\"hljs-comment\">//数组的map和filter方法可以间接用于 Set </span><br><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]);<br>set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([...set].map(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x * <span class=\"hljs-number\">2</span>));<br><span class=\"hljs-comment\">// 返回Set结构：&#123;2, 4, 6&#125;</span><br><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]);<br>set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([...set].filter(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> (x % <span class=\"hljs-number\">2</span>) == <span class=\"hljs-number\">0</span>));<br><span class=\"hljs-comment\">// 返回Set结构：&#123;2, 4&#125;</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//Array.from方法可以将 Set 结构转为数组</span><br><span class=\"hljs-keyword\">const</span> items = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]);<br><span class=\"hljs-keyword\">const</span> array = <span class=\"hljs-built_in\">Array</span>.from(items);<br><span class=\"hljs-comment\">//用于数组去重</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dedupe</span>(<span class=\"hljs-params\">array</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Array</span>.from(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>(array));<br>&#125;<br>dedupe([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]) <span class=\"hljs-comment\">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n\n<p>使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]);<br><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>]);<br><span class=\"hljs-comment\">// 并集</span><br><span class=\"hljs-keyword\">let</span> union = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([...a, ...b]);<br><span class=\"hljs-comment\">// Set &#123;1, 2, 3, 4&#125;</span><br><span class=\"hljs-comment\">// 交集</span><br><span class=\"hljs-keyword\">let</span> intersect = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([...a].filter(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> b.has(x)));<br><span class=\"hljs-comment\">// set &#123;2, 3&#125;</span><br><span class=\"hljs-comment\">//（a 相对于 b 的）差集</span><br><span class=\"hljs-keyword\">let</span> difference = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([...a].filter(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> !b.has(x)));<br><span class=\"hljs-comment\">// Set &#123;1&#125;</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。</span><br><span class=\"hljs-comment\">// 方法一</span><br><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]);<br>set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([...set].map(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> val * <span class=\"hljs-number\">2</span>));<br><span class=\"hljs-comment\">// set的值是2, 4, 6</span><br><br><span class=\"hljs-comment\">// 方法二</span><br><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]);<br>set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>(<span class=\"hljs-built_in\">Array</span>.from(set, <span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> val * <span class=\"hljs-number\">2</span>));<br><span class=\"hljs-comment\">// set的值是2, 4, 6</span><br></code></pre></td></tr></table></figure>\n\n<p>Array.from()方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</p>\n<p>​        伪数组对象（拥有一个 length 属性和若干索引属性的任意对象）</p>\n<p>​        可迭代对象（可以获取对象中的元素,如 Map和 Set 等）</p>\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>\n<p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>\n<p>WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> ws = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakSet</span>();<br><span class=\"hljs-comment\">//作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</span><br><span class=\"hljs-keyword\">const</span> a = [[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]];<br><span class=\"hljs-keyword\">const</span> ws = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakSet</span>(a);<br><span class=\"hljs-comment\">// WeakSet &#123;[1, 2], [3, 4]&#125;</span><br><span class=\"hljs-keyword\">const</span> b = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];<br><span class=\"hljs-keyword\">const</span> ws = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakSet</span>(b);<span class=\"hljs-comment\">//数组b的成员不是对象，加入 WeakSet 就会报错</span><br><span class=\"hljs-comment\">// Uncaught TypeError: Invalid value used in weak set(…)</span><br></code></pre></td></tr></table></figure>\n\n<p>WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。</p>\n<p>WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。</p>\n<p>WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</p>\n<p>WeakSet 没有<code>size</code>属性。</p>\n<p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>Map类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> m = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();<br><span class=\"hljs-keyword\">const</span> o = &#123;<span class=\"hljs-attr\">p</span>: <span class=\"hljs-string\">&#x27;Hello World&#x27;</span>&#125;;<br>m.set(o, <span class=\"hljs-string\">&#x27;content&#x27;</span>)<br>m.get(o) <span class=\"hljs-comment\">// &quot;content&quot;</span><br>m.has(o) <span class=\"hljs-comment\">// true</span><br>m.delete(o) <span class=\"hljs-comment\">// true</span><br>m.has(o) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-comment\">//上面代码使用 Map 结构的set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键</span><br><br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>([<br>  [<span class=\"hljs-string\">&#x27;name&#x27;</span>, <span class=\"hljs-string\">&#x27;张三&#x27;</span>],<br>  [<span class=\"hljs-string\">&#x27;title&#x27;</span>, <span class=\"hljs-string\">&#x27;Author&#x27;</span>]<br>]);<br>map.size <span class=\"hljs-comment\">// 2</span><br>map.has(<span class=\"hljs-string\">&#x27;name&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>map.get(<span class=\"hljs-string\">&#x27;name&#x27;</span>) <span class=\"hljs-comment\">// &quot;张三&quot;</span><br>map.has(<span class=\"hljs-string\">&#x27;title&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>map.get(<span class=\"hljs-string\">&#x27;title&#x27;</span>) <span class=\"hljs-comment\">// &quot;Author&quot;</span><br><br></code></pre></td></tr></table></figure>\n\n<p>任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<br>  [<span class=\"hljs-string\">&#x27;foo&#x27;</span>, <span class=\"hljs-number\">1</span>],<br>  [<span class=\"hljs-string\">&#x27;bar&#x27;</span>, <span class=\"hljs-number\">2</span>]<br>]);<br><span class=\"hljs-keyword\">const</span> m1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>(set);<br>m1.get(<span class=\"hljs-string\">&#x27;foo&#x27;</span>) <span class=\"hljs-comment\">// 1</span><br><br><span class=\"hljs-keyword\">const</span> m2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>([[<span class=\"hljs-string\">&#x27;baz&#x27;</span>, <span class=\"hljs-number\">3</span>]]);<br><span class=\"hljs-keyword\">const</span> m3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>(m2);<br>m3.get(<span class=\"hljs-string\">&#x27;baz&#x27;</span>) <span class=\"hljs-comment\">// 3</span><br><br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();<span class=\"hljs-comment\">//对同一个键多次赋值，后面的值将覆盖前面的值</span><br>map.set(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;aaa&#x27;</span>).set(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;bbb&#x27;</span>);<br>map.get(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// &quot;bbb&quot;</span><br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>().get(<span class=\"hljs-string\">&#x27;asfddfsasadf&#x27;</span>)<span class=\"hljs-comment\">//读取一个未知的键，则返回undefined</span><br><span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();<br>map.set([<span class=\"hljs-string\">&#x27;a&#x27;</span>], <span class=\"hljs-number\">555</span>);<br>map.get([<span class=\"hljs-string\">&#x27;a&#x27;</span>]) <span class=\"hljs-comment\">// undefined  这是两个不同的数组实例，内存地址是不一样的，因此get方法无法读取该键，返回undefined</span><br><br></code></pre></td></tr></table></figure>\n\n<p>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();<br>map.set(<span class=\"hljs-string\">&#x27;foo&#x27;</span>, <span class=\"hljs-literal\">true</span>);<br>map.set(<span class=\"hljs-string\">&#x27;bar&#x27;</span>, <span class=\"hljs-literal\">false</span>);<br>map.size <span class=\"hljs-comment\">// 2  size属性返回 Map 结构的成员总数</span><br><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"模版字符串\"><a href=\"#模版字符串\" class=\"headerlink\" title=\"模版字符串:\"></a>模版字符串:</h3><p>``</p>\n<p>模板字符串中嵌入变量，需要将变量名写在<code>$&#123;&#125;</code>之中，大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性，如果大括号内部是一个字符串，将会原样输出。。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> a=<span class=\"hljs-string\">``</span>;<br><span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">$&#123;<span class=\"hljs-string\">&#x27;World&#x27;</span>&#125;</span>`</span><br><span class=\"hljs-comment\">// &quot;Hello World&quot;</span><br><span class=\"hljs-keyword\">const</span> tmpl = <span class=\"hljs-function\"><span class=\"hljs-params\">addrs</span> =&gt;</span> <span class=\"hljs-string\">`//嵌套</span><br><span class=\"hljs-string\">  &lt;table&gt;</span><br><span class=\"hljs-string\">  <span class=\"hljs-subst\">$&#123;addrs.map(addr =&gt; <span class=\"hljs-string\">`</span></span></span><br><span class=\"hljs-string\"><span class=\"hljs-subst\"><span class=\"hljs-string\">    &lt;tr&gt;&lt;td&gt;<span class=\"hljs-subst\">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span><br><span class=\"hljs-string\"><span class=\"hljs-subst\"><span class=\"hljs-string\">    &lt;tr&gt;&lt;td&gt;<span class=\"hljs-subst\">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span><br><span class=\"hljs-string\"><span class=\"hljs-subst\"><span class=\"hljs-string\">  `</span>).join(<span class=\"hljs-string\">&#x27;&#x27;</span>)&#125;</span></span><br><span class=\"hljs-string\">  &lt;/table&gt;</span><br><span class=\"hljs-string\">`</span>;<br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Class：\"><a href=\"#Class：\" class=\"headerlink\" title=\"Class：\"></a>Class：</h3><p>静态方法和属性由class调用，非静态方法和属性由实例调用；</p>\n<h4 id=\"class继承：\"><a href=\"#class继承：\" class=\"headerlink\" title=\"class继承：\"></a>class继承：</h4><p>Class 可以通过extends关键字实现继承，super关键字表示父类的构造函数，用来新建父类的this对象。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Point</span></span>&#123;<br>  <br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ColorPoint</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Point</span> </span>&#123;<span class=\"hljs-comment\">//继承</span><br>  <span class=\"hljs-keyword\">constructor</span>(x, y, color) &#123;<br>    <span class=\"hljs-built_in\">super</span>(x, y); <span class=\"hljs-comment\">// 调用父类的constructor(x, y)，super方法要在this之前调用</span><br>    <span class=\"hljs-built_in\">this</span>.color = color;<br>  &#125;<br><br>  toString() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.color + <span class=\"hljs-string\">&#x27; &#x27;</span> + <span class=\"hljs-built_in\">super</span>.toString(); <span class=\"hljs-comment\">// 调用父类的toString()</span><br>  &#125;<br>&#125;<br><br><br><span class=\"hljs-comment\">//构造函数</span><br><span class=\"hljs-keyword\">var</span> p=<span class=\"hljs-keyword\">new</span> Person();<br><span class=\"hljs-comment\">//new：</span><br><span class=\"hljs-comment\">//1.创建一个空object</span><br><span class=\"hljs-comment\">//2.把this指针指向这个空object</span><br><span class=\"hljs-comment\">//3.把this指向的这个空对象当作函数的返回值;  return this;</span><br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Promise-的含义\"><a href=\"#Promise-的含义\" class=\"headerlink\" title=\"Promise 的含义\"></a>Promise 的含义</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>\n<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>\n<p><code>Promise</code>对象有以下两个特点。</p>\n<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>\n<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n<p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p>\n<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>\n<p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>\n<p>如果某些事件不断地反复发生，一般来说，使用 <a href=\"https://nodejs.org/api/stream.html\">Stream</a> 模式是比部署<code>Promise</code>更好的选择。</p>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>\n<p>下面代码创造了一个<code>Promise</code>实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// ... some code</span><br><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-comment\">/* 异步操作成功 */</span>)&#123;<br>    resolve(value);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    reject(error);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>\n<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>\n<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">promise.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// success</span><br>&#125;, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// failure</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。这两个函数都是可选的，不一定要提供。它们都接受<code>Promise</code>对象传出的值作为参数。</p>\n<p>下面是一个<code>Promise</code>对象的简单例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">timeout</span>(<span class=\"hljs-params\">ms</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(resolve, ms, <span class=\"hljs-string\">&#x27;done&#x27;</span>);<br>  &#125;);<br>&#125;<br><br>timeout(<span class=\"hljs-number\">100</span>).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(value);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p>\n<p>Promise 新建后就会立即执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Promise&#x27;</span>);<br>  resolve();<br>&#125;);<br><br>promise.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;resolved.&#x27;</span>);<br>&#125;);<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Hi!&#x27;</span>);<br><br><span class=\"hljs-comment\">// Promise</span><br><span class=\"hljs-comment\">// Hi!</span><br><span class=\"hljs-comment\">// resolved</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p>\n<p>下面是异步加载图片的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">loadImageAsync</span>(<span class=\"hljs-params\">url</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">const</span> image = <span class=\"hljs-keyword\">new</span> Image();<br><br>    image.onload = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      resolve(image);<br>    &#125;;<br><br>    image.onerror = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      reject(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;Could not load image at &#x27;</span> + url));<br>    &#125;;<br><br>    image.src = url;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p>\n<p>下面是一个用<code>Promise</code>对象实现的 Ajax 操作的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> getJSON = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">url</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>)</span>&#123;<br>    <span class=\"hljs-keyword\">const</span> handler = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.readyState !== <span class=\"hljs-number\">4</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span>;<br>      &#125;<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.status === <span class=\"hljs-number\">200</span>) &#123;<br>        resolve(<span class=\"hljs-built_in\">this</span>.response);<br>      &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        reject(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-built_in\">this</span>.statusText));<br>      &#125;<br>    &#125;;<br>    <span class=\"hljs-keyword\">const</span> client = <span class=\"hljs-keyword\">new</span> XMLHttpRequest();<br>    client.open(<span class=\"hljs-string\">&quot;GET&quot;</span>, url);<br>    client.onreadystatechange = handler;<br>    client.responseType = <span class=\"hljs-string\">&quot;json&quot;</span>;<br>    client.setRequestHeader(<span class=\"hljs-string\">&quot;Accept&quot;</span>, <span class=\"hljs-string\">&quot;application/json&quot;</span>);<br>    client.send();<br><br>  &#125;);<br><br>  <span class=\"hljs-keyword\">return</span> promise;<br>&#125;;<br><br>getJSON(<span class=\"hljs-string\">&quot;/posts.json&quot;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">json</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Contents: &#x27;</span> + json);<br>&#125;, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&#x27;出错了&#x27;</span>, error);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p>\n<p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;);<br><br><span class=\"hljs-keyword\">const</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// ...</span><br>  resolve(p1);<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p>\n<p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> reject(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;fail&#x27;</span>)), <span class=\"hljs-number\">3000</span>)<br>&#125;)<br><br><span class=\"hljs-keyword\">const</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> resolve(p1), <span class=\"hljs-number\">1000</span>)<br>&#125;)<br><br>p2<br>  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(result))<br>  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(error))<br><span class=\"hljs-comment\">// Error: fail</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p>\n<p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class=\"hljs-number\">1</span>);<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>);<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-params\">r</span> =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(r);<br>&#125;);<br><span class=\"hljs-comment\">// 2</span><br><span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>\n<p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> resolve(<span class=\"hljs-number\">1</span>);<br>  <span class=\"hljs-comment\">// 后面的语句不会执行</span><br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then()\"></a>Promise.prototype.then()</h2><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数，它们都是可选的。</p>\n<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">getJSON(<span class=\"hljs-string\">&quot;/posts.json&quot;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">json</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> json.post;<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">post</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>\n<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">getJSON(<span class=\"hljs-string\">&quot;/post/1.json&quot;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">post</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> getJSON(post.commentURL);<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">comments</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;resolved: &quot;</span>, comments);<br>&#125;, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>)</span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;rejected: &quot;</span>, err);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p>\n<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">getJSON(<span class=\"hljs-string\">&quot;/post/1.json&quot;</span>).then(<br>  post =&gt; getJSON(post.commentURL)<br>).then(<br>  comments =&gt; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;resolved: &quot;</span>, comments),<br>  err =&gt; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;rejected: &quot;</span>, err)<br>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch()\"></a>Promise.prototype.catch()</h2><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">getJSON(<span class=\"hljs-string\">&#x27;/posts.json&#x27;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">posts</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;).catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span><br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;发生错误！&#x27;</span>, error);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">p.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;fulfilled:&#x27;</span>, val))<br>  .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;rejected&#x27;</span>, err));<br><br><span class=\"hljs-comment\">// 等同于</span><br>p.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;fulfilled:&#x27;</span>, val))<br>  .then(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;rejected:&quot;</span>, err));<br></code></pre></td></tr></table></figure>\n\n<p>下面是一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;test&#x27;</span>);<br>&#125;);<br>promise.catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(error);<br>&#125;);<br><span class=\"hljs-comment\">// Error: test</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 写法一</span><br><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;test&#x27;</span>);<br>  &#125; <span class=\"hljs-keyword\">catch</span>(e) &#123;<br>    reject(e);<br>  &#125;<br>&#125;);<br>promise.catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(error);<br>&#125;);<br><br><span class=\"hljs-comment\">// 写法二</span><br><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>  reject(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;test&#x27;</span>));<br>&#125;);<br>promise.catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(error);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误。</p>\n<p>如果 Promise 状态已经变成<code>resolved</code>，再抛出错误是无效的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>  resolve(<span class=\"hljs-string\">&#x27;ok&#x27;</span>);<br>  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;test&#x27;</span>);<br>&#125;);<br>promise<br>  .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(value) &#125;)<br>  .catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(error) &#125;);<br><span class=\"hljs-comment\">// ok</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p>\n<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">getJSON(<span class=\"hljs-string\">&#x27;/post/1.json&#x27;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">post</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> getJSON(post.commentURL);<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">comments</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// some code</span><br>&#125;).catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// 处理前面三个Promise产生的错误</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p>\n<p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br>promise<br>  .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data</span>) </span>&#123;<br>    <span class=\"hljs-comment\">// success</span><br>  &#125;, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) </span>&#123;<br>    <span class=\"hljs-comment\">// error</span><br>  &#125;);<br><br><span class=\"hljs-comment\">// good</span><br>promise<br>  .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data</span>) </span>&#123; <span class=\"hljs-comment\">//cb</span><br>    <span class=\"hljs-comment\">// success</span><br>  &#125;)<br>  .catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) </span>&#123;<br>    <span class=\"hljs-comment\">// error</span><br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</p>\n<p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> someAsyncThing = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>    <span class=\"hljs-comment\">// 下面一行会报错，因为x没有声明</span><br>    resolve(x + <span class=\"hljs-number\">2</span>);<br>  &#125;);<br>&#125;;<br><br>someAsyncThing().then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;everything is great&#x27;</span>);<br>&#125;);<br><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">123</span>) &#125;, <span class=\"hljs-number\">2000</span>);<br><span class=\"hljs-comment\">// Uncaught (in promise) ReferenceError: x is not defined</span><br><span class=\"hljs-comment\">// 123</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程、终止脚本执行，2 秒之后还是会输出<code>123</code>。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p>\n<p>这个脚本放在服务器执行，退出码就是<code>0</code>（即表示执行成功）。不过，Node.js 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">process.on(<span class=\"hljs-string\">&#x27;unhandledRejection&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, p</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">throw</span> err;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>unhandledRejection</code>事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</p>\n<p>注意，Node 有计划在未来废除<code>unhandledRejection</code>事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p>\n<p>再看下面的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>  resolve(<span class=\"hljs-string\">&#x27;ok&#x27;</span>);<br>  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;test&#x27;</span>) &#125;, <span class=\"hljs-number\">0</span>)<br>&#125;);<br>promise.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(value) &#125;);<br><span class=\"hljs-comment\">// ok</span><br><span class=\"hljs-comment\">// Uncaught Error: test</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p>\n<p>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> someAsyncThing = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>    <span class=\"hljs-comment\">// 下面一行会报错，因为x没有声明</span><br>    resolve(x + <span class=\"hljs-number\">2</span>);<br>  &#125;);<br>&#125;;<br><br>someAsyncThing()<br>.catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;oh no&#x27;</span>, error);<br>&#125;)<br>.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;carry on&#x27;</span>);<br>&#125;);<br><span class=\"hljs-comment\">// oh no [ReferenceError: x is not defined]</span><br><span class=\"hljs-comment\">// carry on</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。如果没有报错，则会跳过<code>catch()</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Promise</span>.resolve()<br>.catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;oh no&#x27;</span>, error);<br>&#125;)<br>.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;carry on&#x27;</span>);<br>&#125;);<br><span class=\"hljs-comment\">// carry on</span><br></code></pre></td></tr></table></figure>\n\n<p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p>\n<p><code>catch()</code>方法之中，还能再抛出错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> someAsyncThing = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>    <span class=\"hljs-comment\">// 下面一行会报错，因为x没有声明</span><br>    resolve(x + <span class=\"hljs-number\">2</span>);<br>  &#125;);<br>&#125;;<br><br>someAsyncThing().then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> someOtherAsyncThing();<br>&#125;).catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;oh no&#x27;</span>, error);<br>  <span class=\"hljs-comment\">// 下面一行会报错，因为 y 没有声明</span><br>  y + <span class=\"hljs-number\">2</span>;<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;carry on&#x27;</span>);<br>&#125;);<br><span class=\"hljs-comment\">// oh no [ReferenceError: x is not defined]</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">someAsyncThing().then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> someOtherAsyncThing();<br>&#125;).catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;oh no&#x27;</span>, error);<br>  <span class=\"hljs-comment\">// 下面一行会报错，因为y没有声明</span><br>  y + <span class=\"hljs-number\">2</span>;<br>&#125;).catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;carry on&#x27;</span>, error);<br>&#125;);<br><span class=\"hljs-comment\">// oh no [ReferenceError: x is not defined]</span><br><span class=\"hljs-comment\">// carry on [ReferenceError: y is not defined]</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p>\n<h2 id=\"Promise-prototype-finally\"><a href=\"#Promise-prototype-finally\" class=\"headerlink\" title=\"Promise.prototype.finally()\"></a>Promise.prototype.finally()</h2><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">promise<br>.then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =&gt;</span> &#123;···&#125;)<br>.catch(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> &#123;···&#125;)<br>.finally(<span class=\"hljs-function\">() =&gt;</span> &#123;···&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>\n<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">server.listen(port)<br>  .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>  &#125;)<br>  .finally(server.stop);<br></code></pre></td></tr></table></figure>\n\n<p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>\n<p><code>finally</code>本质上是<code>then</code>方法的特例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">promise<br>.finally(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">// 语句</span><br>&#125;);<br><br><span class=\"hljs-comment\">// 等同于</span><br>promise<br>.then(<br>  result =&gt; &#123;<br>    <span class=\"hljs-comment\">// 语句</span><br>    <span class=\"hljs-keyword\">return</span> result;<br>  &#125;,<br>  error =&gt; &#123;<br>    <span class=\"hljs-comment\">// 语句</span><br>    <span class=\"hljs-keyword\">throw</span> error;<br>  &#125;<br>);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p>\n<p>它的实现也很简单。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Promise</span>.prototype.finally = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">callback</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> P = <span class=\"hljs-built_in\">this</span>.constructor;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.then(<br>    value  =&gt; P.resolve(callback()).then(<span class=\"hljs-function\">() =&gt;</span> value),<br>    reason =&gt; P.resolve(callback()).then(<span class=\"hljs-function\">() =&gt;</span> &#123; <span class=\"hljs-keyword\">throw</span> reason &#125;)<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p>\n<p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// resolve 的值是 undefined</span><br><span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-number\">2</span>).then(<span class=\"hljs-function\">() =&gt;</span> &#123;&#125;, <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;)<br><br><span class=\"hljs-comment\">// resolve 的值是 2</span><br><span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-number\">2</span>).finally(<span class=\"hljs-function\">() =&gt;</span> &#123;&#125;)<br><br><span class=\"hljs-comment\">// reject 的值是 undefined</span><br><span class=\"hljs-built_in\">Promise</span>.reject(<span class=\"hljs-number\">3</span>).then(<span class=\"hljs-function\">() =&gt;</span> &#123;&#125;, <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;)<br><br><span class=\"hljs-comment\">// reject 的值是 3</span><br><span class=\"hljs-built_in\">Promise</span>.reject(<span class=\"hljs-number\">3</span>).finally(<span class=\"hljs-function\">() =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h2><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-built_in\">Promise</span>.all([p1, p2, p3]);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p>\n<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>\n<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>\n<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>\n<p>下面是一个具体的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 生成一个Promise对象的数组</span><br><span class=\"hljs-keyword\">const</span> promises = [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>].map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">id</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> getJSON(<span class=\"hljs-string\">&#x27;/post/&#x27;</span> + id + <span class=\"hljs-string\">&quot;.json&quot;</span>);<br>&#125;);<br><br><span class=\"hljs-built_in\">Promise</span>.all(promises).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">posts</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;).catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">reason</span>)</span>&#123;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>\n<p>下面是另一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> databasePromise = connectDatabase();<br><br><span class=\"hljs-keyword\">const</span> booksPromise = databasePromise<br>  .then(findAllBooks);<br><br><span class=\"hljs-keyword\">const</span> userPromise = databasePromise<br>  .then(getCurrentUser);<br><br><span class=\"hljs-built_in\">Promise</span>.all([<br>  booksPromise,<br>  userPromise<br>])<br>.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">[books, user]</span>) =&gt;</span> pickTopRecommendations(books, user));<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p>\n<p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);<br>&#125;)<br>.then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =&gt;</span> result)<br>.catch(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> e);<br><br><span class=\"hljs-keyword\">const</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;报错了&#x27;</span>);<br>&#125;)<br>.then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =&gt;</span> result)<br>.catch(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> e);<br><br><span class=\"hljs-built_in\">Promise</span>.all([p1, p2])<br>.then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(result))<br>.catch(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(e));<br><span class=\"hljs-comment\">// [&quot;hello&quot;, Error: 报错了]</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p>\n<p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);<br>&#125;)<br>.then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =&gt;</span> result);<br><br><span class=\"hljs-keyword\">const</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;报错了&#x27;</span>);<br>&#125;)<br>.then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =&gt;</span> result);<br><br><span class=\"hljs-built_in\">Promise</span>.all([p1, p2])<br>.then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(result))<br>.catch(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(e));<br><span class=\"hljs-comment\">// Error: 报错了</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h2><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-built_in\">Promise</span>.race([p1, p2, p3]);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>\n<p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p>\n<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-built_in\">Promise</span>.race([<br>  fetch(<span class=\"hljs-string\">&#x27;/resource-that-may-take-a-while&#x27;</span>),<br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> reject(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;request timeout&#x27;</span>)), <span class=\"hljs-number\">5000</span>)<br>  &#125;)<br>]);<br><br>p<br>.then(<span class=\"hljs-built_in\">console</span>.log)<br>.catch(<span class=\"hljs-built_in\">console</span>.error);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>\n<h2 id=\"Promise-allSettled\"><a href=\"#Promise-allSettled\" class=\"headerlink\" title=\"Promise.allSettled()\"></a>Promise.allSettled()</h2><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。该方法由 <a href=\"https://github.com/tc39/proposal-promise-allSettled\">ES2020</a> 引入。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> promises = [<br>  fetch(<span class=\"hljs-string\">&#x27;/api-1&#x27;</span>),<br>  fetch(<span class=\"hljs-string\">&#x27;/api-2&#x27;</span>),<br>  fetch(<span class=\"hljs-string\">&#x27;/api-3&#x27;</span>),<br>];<br><br><span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.allSettled(promises);<br>removeLoadingIndicator();<br></code></pre></td></tr></table></figure>\n\n<p>上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p>\n<p>该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入<code>Promise.allSettled()</code>的 Promise 实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> resolved = <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-number\">42</span>);<br><span class=\"hljs-keyword\">const</span> rejected = <span class=\"hljs-built_in\">Promise</span>.reject(<span class=\"hljs-number\">-1</span>);<br><br><span class=\"hljs-keyword\">const</span> allSettledPromise = <span class=\"hljs-built_in\">Promise</span>.allSettled([resolved, rejected]);<br><br>allSettledPromise.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">results</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(results);<br>&#125;);<br><span class=\"hljs-comment\">// [</span><br><span class=\"hljs-comment\">//    &#123; status: &#x27;fulfilled&#x27;, value: 42 &#125;,</span><br><span class=\"hljs-comment\">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span><br><span class=\"hljs-comment\">// ]</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。它的监听函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应传入<code>Promise.allSettled()</code>的两个 Promise 实例。每个对象都有<code>status</code>属性，该属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>。<code>fulfilled</code>时，对象有<code>value</code>属性，<code>rejected</code>时有<code>reason</code>属性，对应两种状态的返回值。</p>\n<p>下面是返回值用法的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> promises = [ fetch(<span class=\"hljs-string\">&#x27;index.html&#x27;</span>), fetch(<span class=\"hljs-string\">&#x27;https://does-not-exist/&#x27;</span>) ];<br><span class=\"hljs-keyword\">const</span> results = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.allSettled(promises);<br><br><span class=\"hljs-comment\">// 过滤出成功的请求</span><br><span class=\"hljs-keyword\">const</span> successfulPromises = results.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">p</span> =&gt;</span> p.status === <span class=\"hljs-string\">&#x27;fulfilled&#x27;</span>);<br><br><span class=\"hljs-comment\">// 过滤出失败的请求，并输出原因</span><br><span class=\"hljs-keyword\">const</span> errors = results<br>  .filter(<span class=\"hljs-function\"><span class=\"hljs-params\">p</span> =&gt;</span> p.status === <span class=\"hljs-string\">&#x27;rejected&#x27;</span>)<br>  .map(<span class=\"hljs-function\"><span class=\"hljs-params\">p</span> =&gt;</span> p.reason);<br></code></pre></td></tr></table></figure>\n\n<p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，<code>Promise.allSettled()</code>方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。<code>Promise.all()</code>方法无法做到这一点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> urls = [ <span class=\"hljs-comment\">/* ... */</span> ];<br><span class=\"hljs-keyword\">const</span> requests = urls.map(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> fetch(x));<br><br><span class=\"hljs-keyword\">try</span> &#123;<br>  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.all(requests);<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;所有请求都成功。&#x27;</span>);<br>&#125; <span class=\"hljs-keyword\">catch</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;至少一个请求失败，其他请求可能还没结束。&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Promise.all()</code>无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了<code>Promise.allSettled()</code>，这就很容易了。</p>\n<h2 id=\"Promise-any\"><a href=\"#Promise-any\" class=\"headerlink\" title=\"Promise.any()\"></a>Promise.any()</h2><p>ES2021 引入了<a href=\"https://github.com/tc39/proposal-promise-any\"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p>\n<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> promises = [<br>  fetch(<span class=\"hljs-string\">&#x27;/endpoint-a&#x27;</span>).then(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-string\">&#x27;a&#x27;</span>),<br>  fetch(<span class=\"hljs-string\">&#x27;/endpoint-b&#x27;</span>).then(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-string\">&#x27;b&#x27;</span>),<br>  fetch(<span class=\"hljs-string\">&#x27;/endpoint-c&#x27;</span>).then(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-string\">&#x27;c&#x27;</span>),<br>];<br><span class=\"hljs-keyword\">try</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> first = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.any(promises);<br>  <span class=\"hljs-built_in\">console</span>.log(first);<br>&#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(error);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p>\n<p><code>Promise.any()</code>抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">new</span> AggregateError() <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">Array</span> -&gt; AggregateError<br><br><span class=\"hljs-keyword\">const</span> err = <span class=\"hljs-keyword\">new</span> AggregateError();<br>err.push(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;first error&quot;</span>));<br>err.push(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;second error&quot;</span>));<br><span class=\"hljs-keyword\">throw</span> err;<br></code></pre></td></tr></table></figure>\n\n<p>捕捉错误时，如果不用<code>try...catch</code>结构和 await 命令，可以像下面这样写。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Promise</span>.any(promises).then(<br>  (first) =&gt; &#123;<br>    <span class=\"hljs-comment\">// Any of the promises was fulfilled.</span><br>  &#125;,<br>  (error) =&gt; &#123;<br>    <span class=\"hljs-comment\">// All of the promises were rejected.</span><br>  &#125;<br>);<br></code></pre></td></tr></table></figure>\n\n<p>下面是一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> resolved = <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-number\">42</span>);<br><span class=\"hljs-keyword\">var</span> rejected = <span class=\"hljs-built_in\">Promise</span>.reject(<span class=\"hljs-number\">-1</span>);<br><span class=\"hljs-keyword\">var</span> alsoRejected = <span class=\"hljs-built_in\">Promise</span>.reject(<span class=\"hljs-literal\">Infinity</span>);<br><br><span class=\"hljs-built_in\">Promise</span>.any([resolved, rejected, alsoRejected]).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">result</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(result); <span class=\"hljs-comment\">// 42</span><br>&#125;);<br><br><span class=\"hljs-built_in\">Promise</span>.any([rejected, alsoRejected]).catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">results</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(results); <span class=\"hljs-comment\">// [-1, Infinity]</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h2><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> jsPromise = <span class=\"hljs-built_in\">Promise</span>.resolve($.ajax(<span class=\"hljs-string\">&#x27;/whatever.json&#x27;</span>));<br></code></pre></td></tr></table></figure>\n\n<p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p>\n<p><code>Promise.resolve()</code>等价于下面的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br><span class=\"hljs-comment\">// 等价于</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> resolve(<span class=\"hljs-string\">&#x27;foo&#x27;</span>))<br></code></pre></td></tr></table></figure>\n\n<p><code>Promise.resolve()</code>方法的参数分成四种情况。</p>\n<p><strong>（1）参数是一个 Promise 实例</strong></p>\n<p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p>\n<p><strong>（2）参数是一个<code>thenable</code>对象</strong></p>\n<p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> thenable = &#123;<br>  then: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>    resolve(<span class=\"hljs-number\">42</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> thenable = &#123;<br>  then: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>    resolve(<span class=\"hljs-number\">42</span>);<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> p1 = <span class=\"hljs-built_in\">Promise</span>.resolve(thenable);<br>p1.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(value);  <span class=\"hljs-comment\">// 42</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出42。</p>\n<p><strong>（3）参数不是具有<code>then()</code>方法的对象，或根本就不是对象</strong></p>\n<p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>);<br><br>p.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">s</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(s)<br>&#125;);<br><span class=\"hljs-comment\">// Hello</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve()</code>方法的参数，会同时传给回调函数。</p>\n<p><strong>（4）不带有任何参数</strong></p>\n<p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p>\n<p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-built_in\">Promise</span>.resolve();<br><br>p.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p>\n<p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;three&#x27;</span>);<br>&#125;, <span class=\"hljs-number\">0</span>);<br><br><span class=\"hljs-built_in\">Promise</span>.resolve().then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;two&#x27;</span>);<br>&#125;);<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;one&#x27;</span>);<br><br><span class=\"hljs-comment\">// one</span><br><span class=\"hljs-comment\">// two</span><br><span class=\"hljs-comment\">// three</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p>\n<h2 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h2><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-built_in\">Promise</span>.reject(<span class=\"hljs-string\">&#x27;出错了&#x27;</span>);<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> reject(<span class=\"hljs-string\">&#x27;出错了&#x27;</span>))<br><br>p.then(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">s</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(s)<br>&#125;);<br><span class=\"hljs-comment\">// 出错了</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p>\n<p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Promise</span>.reject(<span class=\"hljs-string\">&#x27;出错了&#x27;</span>)<br>.catch(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(e === <span class=\"hljs-string\">&#x27;出错了&#x27;</span>)<br>&#125;)<br><span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"加载图片\"><a href=\"#加载图片\" class=\"headerlink\" title=\"加载图片\"></a>加载图片</h3><p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> preloadImage = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">path</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">const</span> image = <span class=\"hljs-keyword\">new</span> Image();<br>    image.onload  = resolve;<br>    image.onerror = reject;<br>    image.src = path;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Generator-函数与-Promise-的结合\"><a href=\"#Generator-函数与-Promise-的结合\" class=\"headerlink\" title=\"Generator 函数与 Promise 的结合\"></a>Generator 函数与 Promise 的结合</h3><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getFoo</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>)</span>&#123;<br>    resolve(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br>  &#125;);<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> g = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* (<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-keyword\">yield</span> getFoo();<br>    <span class=\"hljs-built_in\">console</span>.log(foo);<br>  &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(e);<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">run</span> (<span class=\"hljs-params\">generator</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> it = generator();<br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">go</span>(<span class=\"hljs-params\">result</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (result.done) <span class=\"hljs-keyword\">return</span> result.value;<br><br>    <span class=\"hljs-keyword\">return</span> result.value.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> go(it.next(value));<br>    &#125;, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">error</span>) </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> go(it.throw(error));<br>    &#125;);<br>  &#125;<br><br>  go(it.next());<br>&#125;<br><br>run(g);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p>\n<h2 id=\"Promise-try\"><a href=\"#Promise-try\" class=\"headerlink\" title=\"Promise.try()\"></a>Promise.try()</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Promise</span>.resolve().then(f)<br></code></pre></td></tr></table></figure>\n\n<p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> f = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;now&#x27;</span>);<br><span class=\"hljs-built_in\">Promise</span>.resolve().then(f);<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;next&#x27;</span>);<br><span class=\"hljs-comment\">// next</span><br><span class=\"hljs-comment\">// now</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p>\n<p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用<code>async</code>函数来写。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> f = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;now&#x27;</span>);<br>(<span class=\"hljs-keyword\">async</span> () =&gt; f())();<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;next&#x27;</span>);<br><span class=\"hljs-comment\">// now</span><br><span class=\"hljs-comment\">// next</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(<span class=\"hljs-keyword\">async</span> () =&gt; f())()<br>.then(...)<br></code></pre></td></tr></table></figure>\n\n<p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(<span class=\"hljs-keyword\">async</span> () =&gt; f())()<br>.then(...)<br>.catch(...)<br></code></pre></td></tr></table></figure>\n\n<p>第二种写法是使用<code>new Promise()</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> f = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;now&#x27;</span>);<br>(<br>  () =&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<br>    resolve =&gt; resolve(f())<br>  )<br>)();<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;next&#x27;</span>);<br><span class=\"hljs-comment\">// now</span><br><span class=\"hljs-comment\">// next</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p>\n<p>鉴于这是一个很常见的需求，所以现在有一个<a href=\"https://github.com/ljharb/proposal-promise-try\">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> f = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;now&#x27;</span>);<br><span class=\"hljs-built_in\">Promise</span>.try(f);<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;next&#x27;</span>);<br><span class=\"hljs-comment\">// now</span><br><span class=\"hljs-comment\">// next</span><br></code></pre></td></tr></table></figure>\n\n<p>事实上，<code>Promise.try</code>存在已久，Promise 库<a href=\"http://bluebirdjs.com/docs/api/promise.try.html\"><code>Bluebird</code></a>、<a href=\"https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs\"><code>Q</code></a>和<a href=\"https://github.com/cujojs/when/blob/master/docs/api.md#whentry\"><code>when</code></a>，早就提供了这个方法。</p>\n<p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a href=\"http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/\">许多好处</a>，其中一点就是可以更好地管理异常。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getUsername</span>(<span class=\"hljs-params\">userId</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> database.users.get(&#123;<span class=\"hljs-attr\">id</span>: userId&#125;)<br>  .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">user</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> user.name;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">database.users.get(&#123;<span class=\"hljs-attr\">id</span>: userId&#125;)<br>.then(...)<br>.catch(...)<br></code></pre></td></tr></table></figure>\n\n<p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">try</span> &#123;<br>  database.users.get(&#123;<span class=\"hljs-attr\">id</span>: userId&#125;)<br>  .then(...)<br>  .catch(...)<br>&#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Promise</span>.try(<span class=\"hljs-function\">() =&gt;</span> database.users.get(&#123;<span class=\"hljs-attr\">id</span>: userId&#125;))<br>  .then(...)<br>  .catch(...)<br></code></pre></td></tr></table></figure>\n\n<p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p>\n<h2 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\n<p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>\n<p>前文有一个 Generator 函数，依次读取两个文件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> readFile = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">fileName</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>    fs.readFile(fileName, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error, data</span>) </span>&#123;<br>      <span class=\"hljs-keyword\">if</span> (error) <span class=\"hljs-keyword\">return</span> reject(error);<br>      resolve(data);<br>    &#125;);<br>  &#125;);<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> gen = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* (<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> f1 = <span class=\"hljs-keyword\">yield</span> readFile(<span class=\"hljs-string\">&#x27;/etc/fstab&#x27;</span>);<br>  <span class=\"hljs-keyword\">const</span> f2 = <span class=\"hljs-keyword\">yield</span> readFile(<span class=\"hljs-string\">&#x27;/etc/shells&#x27;</span>);<br>  <span class=\"hljs-built_in\">console</span>.log(f1.toString());<br>  <span class=\"hljs-built_in\">console</span>.log(f2.toString());<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> asyncReadFile = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> f1 = <span class=\"hljs-keyword\">await</span> readFile(<span class=\"hljs-string\">&#x27;/etc/fstab&#x27;</span>);<br>  <span class=\"hljs-keyword\">const</span> f2 = <span class=\"hljs-keyword\">await</span> readFile(<span class=\"hljs-string\">&#x27;/etc/shells&#x27;</span>);<br>  <span class=\"hljs-built_in\">console</span>.log(f1.toString());<br>  <span class=\"hljs-built_in\">console</span>.log(f2.toString());<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p>\n<p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p>\n<p>（1）内置执行器。</p>\n<p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">asyncReadFile();<br></code></pre></td></tr></table></figure>\n\n<p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p>\n<p>（2）更好的语义。</p>\n<p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p>\n<p>（3）更广的适用性。</p>\n<p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p>\n<p>（4）返回值是 Promise。</p>\n<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>\n<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>\n<h2 id=\"基本用法-1\"><a href=\"#基本用法-1\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>\n<p>下面是一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getStockPriceByName</span>(<span class=\"hljs-params\">name</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> symbol = <span class=\"hljs-keyword\">await</span> getStockSymbol(name);<br>  <span class=\"hljs-keyword\">const</span> stockPrice = <span class=\"hljs-keyword\">await</span> getStockPrice(symbol);<br>  <span class=\"hljs-keyword\">return</span> stockPrice;<br>&#125;<br><br>getStockPriceByName(<span class=\"hljs-string\">&#x27;goog&#x27;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">result</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(result);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p>\n<p>下面是另一个例子，指定多少毫秒后输出一个值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">timeout</span>(<span class=\"hljs-params\">ms</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(resolve, ms);<br>  &#125;);<br>&#125;<br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncPrint</span>(<span class=\"hljs-params\">value, ms</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">await</span> timeout(ms);<br>  <span class=\"hljs-built_in\">console</span>.log(value);<br>&#125;<br><br>asyncPrint(<span class=\"hljs-string\">&#x27;hello world&#x27;</span>, <span class=\"hljs-number\">50</span>);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码指定 50 毫秒以后，输出<code>hello world</code>。</p>\n<p>由于<code>async</code>函数返回的是 Promise 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">timeout</span>(<span class=\"hljs-params\">ms</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(resolve, ms);<br>  &#125;);<br>&#125;<br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncPrint</span>(<span class=\"hljs-params\">value, ms</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">await</span> timeout(ms);<br>  <span class=\"hljs-built_in\">console</span>.log(value);<br>&#125;<br><br>asyncPrint(<span class=\"hljs-string\">&#x27;hello world&#x27;</span>, <span class=\"hljs-number\">50</span>);<br></code></pre></td></tr></table></figure>\n\n<p>async 函数有多种使用形式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 函数声明</span><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>&#123;&#125;<br><br><span class=\"hljs-comment\">// 函数表达式</span><br><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;;<br><br><span class=\"hljs-comment\">// 对象的方法</span><br><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-keyword\">async</span> foo() &#123;&#125; &#125;;<br>obj.foo().then(...)<br><br><span class=\"hljs-comment\">// Class 的方法</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Storage</span> </span>&#123;<br>  <span class=\"hljs-keyword\">constructor</span>() &#123;<br>    <span class=\"hljs-built_in\">this</span>.cachePromise = caches.open(<span class=\"hljs-string\">&#x27;avatars&#x27;</span>);<br>  &#125;<br><br>  <span class=\"hljs-keyword\">async</span> getAvatar(name) &#123;<br>    <span class=\"hljs-keyword\">const</span> cache = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">this</span>.cachePromise;<br>    <span class=\"hljs-keyword\">return</span> cache.match(<span class=\"hljs-string\">`/avatars/<span class=\"hljs-subst\">$&#123;name&#125;</span>.jpg`</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> storage = <span class=\"hljs-keyword\">new</span> Storage();<br>storage.getAvatar(<span class=\"hljs-string\">&#x27;jake&#x27;</span>).then(…);<br><br><span class=\"hljs-comment\">// 箭头函数</span><br><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-keyword\">async</span> () =&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p>\n<h3 id=\"返回-Promise-对象\"><a href=\"#返回-Promise-对象\" class=\"headerlink\" title=\"返回 Promise 对象\"></a>返回 Promise 对象</h3><p><code>async</code>函数返回一个 Promise 对象。</p>\n<p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello world&#x27;</span>;<br>&#125;<br><br>f().then(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(v))<br><span class=\"hljs-comment\">// &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p>\n<p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;出错了&#x27;</span>);<br>&#125;<br><br>f().then(<br>  v =&gt; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;resolve&#x27;</span>, v),<br>  e =&gt; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;reject&#x27;</span>, e)<br>)<br><span class=\"hljs-comment\">//reject Error: 出错了</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Promise-对象的状态变化\"><a href=\"#Promise-对象的状态变化\" class=\"headerlink\" title=\"Promise 对象的状态变化\"></a>Promise 对象的状态变化</h3><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p>\n<p>下面是一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getTitle</span>(<span class=\"hljs-params\">url</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> response = <span class=\"hljs-keyword\">await</span> fetch(url);<br>  <span class=\"hljs-keyword\">let</span> html = <span class=\"hljs-keyword\">await</span> response.text();<br>  <span class=\"hljs-keyword\">return</span> html.match(<span class=\"hljs-regexp\">/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i</span>)[<span class=\"hljs-number\">1</span>];<br>&#125;<br>getTitle(<span class=\"hljs-string\">&#x27;https://tc39.github.io/ecma262/&#x27;</span>).then(<span class=\"hljs-built_in\">console</span>.log)<br><span class=\"hljs-comment\">// &quot;ECMAScript 2017 Language Specification&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p>\n<h3 id=\"await-命令\"><a href=\"#await-命令\" class=\"headerlink\" title=\"await 命令\"></a>await 命令</h3><p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-comment\">// 等同于</span><br>  <span class=\"hljs-comment\">// return 123;</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-number\">123</span>;<br>&#125;<br><br>f().then(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(v))<br><span class=\"hljs-comment\">// 123</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，这时等同于<code>return 123</code>。</p>\n<p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Sleep</span> </span>&#123;<br>  <span class=\"hljs-keyword\">constructor</span>(timeout) &#123;<br>    <span class=\"hljs-built_in\">this</span>.timeout = timeout;<br>  &#125;<br>  then(resolve, reject) &#123;<br>    <span class=\"hljs-keyword\">const</span> startTime = <span class=\"hljs-built_in\">Date</span>.now();<br>    <span class=\"hljs-built_in\">setTimeout</span>(<br>      () =&gt; resolve(<span class=\"hljs-built_in\">Date</span>.now() - startTime),<br>      <span class=\"hljs-built_in\">this</span>.timeout<br>    );<br>  &#125;<br>&#125;<br><br>(<span class=\"hljs-keyword\">async</span> () =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> sleepTime = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">new</span> Sleep(<span class=\"hljs-number\">1000</span>);<br>  <span class=\"hljs-built_in\">console</span>.log(sleepTime);<br>&#125;)();<br><span class=\"hljs-comment\">// 1000</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>await</code>命令后面是一个<code>Sleep</code>对象的实例。这个实例不是 Promise 对象，但是因为定义了<code>then</code>方法，<code>await</code>会将其视为<code>Promise</code>处理。</p>\n<p>这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助<code>await</code>命令就可以让程序停顿指定的时间。下面给出了一个简化的<code>sleep</code>实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sleep</span>(<span class=\"hljs-params\">interval</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(resolve, interval);<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-comment\">// 用法</span><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">one2FiveInAsync</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">5</span>; i++) &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(i);<br>    <span class=\"hljs-keyword\">await</span> sleep(<span class=\"hljs-number\">1000</span>);<br>  &#125;<br>&#125;<br><br>one2FiveInAsync();<br></code></pre></td></tr></table></figure>\n\n<p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.reject(<span class=\"hljs-string\">&#x27;出错了&#x27;</span>);<br>&#125;<br><br>f()<br>.then(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(v))<br>.catch(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(e))<br><span class=\"hljs-comment\">// 出错了</span><br></code></pre></td></tr></table></figure>\n\n<p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p>\n<p>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.reject(<span class=\"hljs-string\">&#x27;出错了&#x27;</span>);<br>  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">&#x27;hello world&#x27;</span>); <span class=\"hljs-comment\">// 不会执行</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p>\n<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.reject(<span class=\"hljs-string\">&#x27;出错了&#x27;</span>);<br>  &#125; <span class=\"hljs-keyword\">catch</span>(e) &#123;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">&#x27;hello world&#x27;</span>);<br>&#125;<br><br>f()<br>.then(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(v))<br><span class=\"hljs-comment\">// hello world</span><br></code></pre></td></tr></table></figure>\n\n<p>另一种方法是<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.reject(<span class=\"hljs-string\">&#x27;出错了&#x27;</span>)<br>    .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(e));<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">&#x27;hello world&#x27;</span>);<br>&#125;<br><br>f()<br>.then(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(v))<br><span class=\"hljs-comment\">// 出错了</span><br><span class=\"hljs-comment\">// hello world</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;出错了&#x27;</span>);<br>  &#125;);<br>&#125;<br><br>f()<br>.then(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(v))<br>.catch(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(e))<br><span class=\"hljs-comment\">// Error：出错了</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的 Promise 对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。</p>\n<p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;出错了&#x27;</span>);<br>    &#125;);<br>  &#125; <span class=\"hljs-keyword\">catch</span>(e) &#123;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span>(<span class=\"hljs-string\">&#x27;hello world&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> val1 = <span class=\"hljs-keyword\">await</span> firstStep();<br>    <span class=\"hljs-keyword\">const</span> val2 = <span class=\"hljs-keyword\">await</span> secondStep(val1);<br>    <span class=\"hljs-keyword\">const</span> val3 = <span class=\"hljs-keyword\">await</span> thirdStep(val1, val2);<br><br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Final: &#x27;</span>, val3);<br>  &#125;<br>  <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-built_in\">console</span>.error(err);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> superagent = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;superagent&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> NUM_RETRIES = <span class=\"hljs-number\">3</span>;<br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> i;<br>  <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; NUM_RETRIES; ++i) &#123;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>      <span class=\"hljs-keyword\">await</span> superagent.get(<span class=\"hljs-string\">&#x27;http://google.com/this-throws-an-error&#x27;</span>);<br>      <span class=\"hljs-keyword\">break</span>;<br>    &#125; <span class=\"hljs-keyword\">catch</span>(err) &#123;&#125;<br>  &#125;<br>  <span class=\"hljs-built_in\">console</span>.log(i); <span class=\"hljs-comment\">// 3</span><br>&#125;<br><br>test();<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p>\n<h3 id=\"使用注意点\"><a href=\"#使用注意点\" class=\"headerlink\" title=\"使用注意点\"></a>使用注意点</h3><p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">await</span> somethingThatReturnsAPromise();<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(err);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 另一种写法</span><br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">await</span> somethingThatReturnsAPromise()<br>  .catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(err);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-keyword\">await</span> getFoo();<br><span class=\"hljs-keyword\">let</span> bar = <span class=\"hljs-keyword\">await</span> getBar();<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 写法一</span><br><span class=\"hljs-keyword\">let</span> [foo, bar] = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.all([getFoo(), getBar()]);<br><br><span class=\"hljs-comment\">// 写法二</span><br><span class=\"hljs-keyword\">let</span> fooPromise = getFoo();<br><span class=\"hljs-keyword\">let</span> barPromise = getBar();<br><span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-keyword\">await</span> fooPromise;<br><span class=\"hljs-keyword\">let</span> bar = <span class=\"hljs-keyword\">await</span> barPromise;<br></code></pre></td></tr></table></figure>\n\n<p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p>\n<p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dbFuc</span>(<span class=\"hljs-params\">db</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br><br>  <span class=\"hljs-comment\">// 报错</span><br>  docs.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">doc</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">await</span> db.post(doc);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dbFuc</span>(<span class=\"hljs-params\">db</span>) </span>&#123; <span class=\"hljs-comment\">//这里不需要 async</span><br>  <span class=\"hljs-keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br><br>  <span class=\"hljs-comment\">// 可能得到错误结果</span><br>  docs.forEach(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">doc</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">await</span> db.post(doc);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码可能不会正常工作，原因是这时三个<code>db.post()</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dbFuc</span>(<span class=\"hljs-params\">db</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> doc <span class=\"hljs-keyword\">of</span> docs) &#123;<br>    <span class=\"hljs-keyword\">await</span> db.post(doc);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>另一种方法是使用数组的<code>reduce()</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dbFuc</span>(<span class=\"hljs-params\">db</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br><br>  <span class=\"hljs-keyword\">await</span> docs.reduce(<span class=\"hljs-keyword\">async</span> (_, doc) =&gt; &#123;<br>    <span class=\"hljs-keyword\">await</span> _;<br>    <span class=\"hljs-keyword\">await</span> db.post(doc);<br>  &#125;, <span class=\"hljs-literal\">undefined</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面例子中，<code>reduce()</code>方法的第一个参数是<code>async</code>函数，导致该函数的第一个参数是前一步操作返回的 Promise 对象，所以必须使用<code>await</code>等待它操作结束。另外，<code>reduce()</code>方法返回的是<code>docs</code>数组最后一个成员的<code>async</code>函数的执行结果，也是一个 Promise 对象，导致在它前面也必须加上<code>await</code>。</p>\n<p>上面的<code>reduce()</code>的参数函数里面没有<code>return</code>语句，原因是这个函数的主要目的是<code>db.post()</code>操作，不是返回值。而且<code>async</code>函数不管有没有<code>return</code>语句，总是返回一个 Promise 对象，所以这里的<code>return</code>是不必要的。</p>\n<p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。当三个请求都会<code>resolved</code>时，下面两种写法效果相同。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dbFuc</span>(<span class=\"hljs-params\">db</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br>  <span class=\"hljs-keyword\">let</span> promises = docs.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">doc</span>) =&gt;</span> db.post(doc));<br><br>  <span class=\"hljs-keyword\">let</span> results = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.all(promises);<br>  <span class=\"hljs-built_in\">console</span>.log(results);<br>&#125;<br><br><span class=\"hljs-comment\">// 或者使用下面的写法</span><br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dbFuc</span>(<span class=\"hljs-params\">db</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br>  <span class=\"hljs-keyword\">let</span> promises = docs.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">doc</span>) =&gt;</span> db.post(doc));<br><br>  <span class=\"hljs-keyword\">let</span> results = [];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> promise <span class=\"hljs-keyword\">of</span> promises) &#123;<br>    results.push(<span class=\"hljs-keyword\">await</span> promise);<br>  &#125;<br>  <span class=\"hljs-built_in\">console</span>.log(results);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>第四点，async 函数可以保留运行堆栈。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  b().then(<span class=\"hljs-function\">() =&gt;</span> c());<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，函数<code>a</code>内部运行了一个异步任务<code>b()</code>。当<code>b()</code>运行的时候，函数<code>a()</code>不会中断，而是继续执行。等到<code>b()</code>运行结束，可能<code>a()</code>早就运行结束了，<code>b()</code>所在的上下文环境已经消失了。如果<code>b()</code>或<code>c()</code>报错，错误堆栈将不包括<code>a()</code>。</p>\n<p>现在将这个例子改成<code>async</code>函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-keyword\">async</span> () =&gt; &#123;<br>  <span class=\"hljs-keyword\">await</span> b();<br>  c();<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>b()</code>运行的时候，<code>a()</code>是暂停执行，上下文环境都保存着。一旦<code>b()</code>或<code>c()</code>报错，错误堆栈将包括<code>a()</code>。</p>\n<h2 id=\"async-函数的实现原理\"><a href=\"#async-函数的实现原理\" class=\"headerlink\" title=\"async 函数的实现原理\"></a>async 函数的实现原理</h2><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\">args</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br><span class=\"hljs-comment\">// 等同于</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\">args</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> spawn(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p>\n<p>下面给出<code>spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">spawn</span>(<span class=\"hljs-params\">genF</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">const</span> gen = genF();<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">step</span>(<span class=\"hljs-params\">nextF</span>) </span>&#123;<br>      <span class=\"hljs-keyword\">let</span> next;<br>      <span class=\"hljs-keyword\">try</span> &#123;<br>        next = nextF();<br>      &#125; <span class=\"hljs-keyword\">catch</span>(e) &#123;<br>        <span class=\"hljs-keyword\">return</span> reject(e);<br>      &#125;<br>      <span class=\"hljs-keyword\">if</span>(next.done) &#123;<br>        <span class=\"hljs-keyword\">return</span> resolve(next.value);<br>      &#125;<br>      <span class=\"hljs-built_in\">Promise</span>.resolve(next.value).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">v</span>) </span>&#123;<br>        step(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-keyword\">return</span> gen.next(v); &#125;);<br>      &#125;, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>&#123;<br>        step(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-keyword\">return</span> gen.throw(e); &#125;);<br>      &#125;);<br>    &#125;<br>    step(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-keyword\">return</span> gen.next(<span class=\"hljs-literal\">undefined</span>); &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"与其他异步处理方法的比较\"><a href=\"#与其他异步处理方法的比较\" class=\"headerlink\" title=\"与其他异步处理方法的比较\"></a>与其他异步处理方法的比较</h2><p>我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。</p>\n<p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>\n<p>首先是 Promise 的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">chainAnimationsPromise</span>(<span class=\"hljs-params\">elem, animations</span>) </span>&#123;<br><br>  <span class=\"hljs-comment\">// 变量ret用来保存上一个动画的返回值</span><br>  <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-literal\">null</span>;<br><br>  <span class=\"hljs-comment\">// 新建一个空的Promise</span><br>  <span class=\"hljs-keyword\">let</span> p = <span class=\"hljs-built_in\">Promise</span>.resolve();<br><br>  <span class=\"hljs-comment\">// 使用then方法，添加所有动画</span><br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> anim <span class=\"hljs-keyword\">of</span> animations) &#123;<br>    p = p.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">val</span>) </span>&#123;<br>      ret = val;<br>      <span class=\"hljs-keyword\">return</span> anim(elem);<br>    &#125;);<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 返回一个部署了错误捕捉机制的Promise</span><br>  <span class=\"hljs-keyword\">return</span> p.catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>&#123;<br>    <span class=\"hljs-comment\">/* 忽略错误，继续执行 */</span><br>  &#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> ret;<br>  &#125;);<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（<code>then</code>、<code>catch</code>等等），操作本身的语义反而不容易看出来。</p>\n<p>接着是 Generator 函数的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">chainAnimationsGenerator</span>(<span class=\"hljs-params\">elem, animations</span>) </span>&#123;<br><br>  <span class=\"hljs-keyword\">return</span> spawn(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>*(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-literal\">null</span>;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> anim <span class=\"hljs-keyword\">of</span> animations) &#123;<br>        ret = <span class=\"hljs-keyword\">yield</span> anim(elem);<br>      &#125;<br>    &#125; <span class=\"hljs-keyword\">catch</span>(e) &#123;<br>      <span class=\"hljs-comment\">/* 忽略错误，继续执行 */</span><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> ret;<br>  &#125;);<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在<code>spawn</code>函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的<code>spawn</code>函数就是自动执行器，它返回一个 Promise 对象，而且必须保证<code>yield</code>语句后面的表达式，必须返回一个 Promise。</p>\n<p>最后是 async 函数的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">chainAnimationsAsync</span>(<span class=\"hljs-params\">elem, animations</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-literal\">null</span>;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> anim <span class=\"hljs-keyword\">of</span> animations) &#123;<br>      ret = <span class=\"hljs-keyword\">await</span> anim(elem);<br>    &#125;<br>  &#125; <span class=\"hljs-keyword\">catch</span>(e) &#123;<br>    <span class=\"hljs-comment\">/* 忽略错误，继续执行 */</span><br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。</p>\n<h2 id=\"实例：按顺序完成异步操作\"><a href=\"#实例：按顺序完成异步操作\" class=\"headerlink\" title=\"实例：按顺序完成异步操作\"></a>实例：按顺序完成异步操作</h2><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p>\n<p>Promise 的写法如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logInOrder</span>(<span class=\"hljs-params\">urls</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// 远程读取所有URL</span><br>  <span class=\"hljs-keyword\">const</span> textPromises = urls.map(<span class=\"hljs-function\"><span class=\"hljs-params\">url</span> =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> fetch(url).then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> response.text());<br>  &#125;);<br><br>  <span class=\"hljs-comment\">// 按次序输出</span><br>  textPromises.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">chain, textPromise</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> chain.then(<span class=\"hljs-function\">() =&gt;</span> textPromise)<br>      .then(<span class=\"hljs-function\"><span class=\"hljs-params\">text</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(text));<br>  &#125;, <span class=\"hljs-built_in\">Promise</span>.resolve());<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码使用<code>fetch</code>方法，同时远程读取一组 URL。每个<code>fetch</code>操作都返回一个 Promise 对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个 Promise 对象，然后使用<code>then</code>，将所有 Promise 对象连起来，因此就可以依次输出结果。</p>\n<p>这种写法不太直观，可读性比较差。下面是 async 函数实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logInOrder</span>(<span class=\"hljs-params\">urls</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> url <span class=\"hljs-keyword\">of</span> urls) &#123;<br>    <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> fetch(url);<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">await</span> response.text());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logInOrder</span>(<span class=\"hljs-params\">urls</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// 并发读取远程URL</span><br>  <span class=\"hljs-keyword\">const</span> textPromises = urls.map(<span class=\"hljs-keyword\">async</span> url =&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> fetch(url);<br>    <span class=\"hljs-keyword\">return</span> response.text();<br>  &#125;);<br><br>  <span class=\"hljs-comment\">// 按次序输出</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> textPromise <span class=\"hljs-keyword\">of</span> textPromises) &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">await</span> textPromise);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，虽然<code>map</code>方法的参数是<code>async</code>函数，但它是并发执行的，因为只有<code>async</code>函数内部是继发执行，外部不受影响。后面的<code>for..of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。</p>\n<h2 id=\"顶层-await\"><a href=\"#顶层-await\" class=\"headerlink\" title=\"顶层 await\"></a>顶层 await</h2><p>根据语法规格，<code>await</code>命令只能出现在 async 函数内部，否则都会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 报错</span><br><span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">&#x27;https://api.example.com&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>await</code>命令独立使用，没有放在 async 函数里面，就会报错。</p>\n<p>目前，有一个<a href=\"https://github.com/tc39/proposal-top-level-await\">语法提案</a>，允许在模块的顶层独立使用<code>await</code>命令，使得上面那行代码不会报错了。这个提案的目的，是借用<code>await</code>解决模块异步加载的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// awaiting.js</span><br><span class=\"hljs-keyword\">let</span> output;<br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> dynamic = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">import</span>(someMission);<br>  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> fetch(url);<br>  output = someProcess(dynamic.default, data);<br>&#125;<br>main();<br><span class=\"hljs-keyword\">export</span> &#123; output &#125;;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，模块<code>awaiting.js</code>的输出值<code>output</code>，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量<code>output</code>才会有值，否则就返回<code>undefined</code>。</p>\n<p>上面的代码也可以写成立即执行函数的形式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// awaiting.js</span><br><span class=\"hljs-keyword\">let</span> output;<br>(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> dynamic = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">import</span>(someMission);<br>  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> fetch(url);<br>  output = someProcess(dynamic.default, data);<br>&#125;)();<br><span class=\"hljs-keyword\">export</span> &#123; output &#125;;<br></code></pre></td></tr></table></figure>\n\n<p>下面是加载这个模块的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// usage.js</span><br><span class=\"hljs-keyword\">import</span> &#123; output &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./awaiting.js&quot;</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">outputPlusValue</span>(<span class=\"hljs-params\">value</span>) </span>&#123; <span class=\"hljs-keyword\">return</span> output + value &#125;<br><br><span class=\"hljs-built_in\">console</span>.log(outputPlusValue(<span class=\"hljs-number\">100</span>));<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(outputPlusValue(<span class=\"hljs-number\">100</span>), <span class=\"hljs-number\">1000</span>);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>outputPlusValue()</code>的执行结果，完全取决于执行的时间。如果<code>awaiting.js</code>里面的异步操作没执行完，加载进来的<code>output</code>的值就是<code>undefined</code>。</p>\n<p>目前的解决方法，就是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// awaiting.js</span><br><span class=\"hljs-keyword\">let</span> output;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> (<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> dynamic = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">import</span>(someMission);<br>  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> fetch(url);<br>  output = someProcess(dynamic.default, data);<br>&#125;)();<br><span class=\"hljs-keyword\">export</span> &#123; output &#125;;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>awaiting.js</code>除了输出<code>output</code>，还默认输出一个 Promise 对象（async 函数立即执行后，返回一个 Promise 对象），从这个对象判断异步操作是否结束。</p>\n<p>下面是加载这个模块的新的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// usage.js</span><br><span class=\"hljs-keyword\">import</span> promise, &#123; output &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./awaiting.js&quot;</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">outputPlusValue</span>(<span class=\"hljs-params\">value</span>) </span>&#123; <span class=\"hljs-keyword\">return</span> output + value &#125;<br><br>promise.then(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(outputPlusValue(<span class=\"hljs-number\">100</span>));<br>  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(outputPlusValue(<span class=\"hljs-number\">100</span>), <span class=\"hljs-number\">1000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，将<code>awaiting.js</code>对象的输出，放在<code>promise.then()</code>里面，这样就能保证异步操作完成以后，才去读取<code>output</code>。</p>\n<p>这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的<code>usage.js</code>又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载。</p>\n<p>顶层的<code>await</code>命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// awaiting.js</span><br><span class=\"hljs-keyword\">const</span> dynamic = <span class=\"hljs-keyword\">import</span>(someMission);<br><span class=\"hljs-keyword\">const</span> data = fetch(url);<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> output = someProcess((<span class=\"hljs-keyword\">await</span> dynamic).default, <span class=\"hljs-keyword\">await</span> data);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，两个异步操作在输出的时候，都加上了<code>await</code>命令。只有等到异步操作完成，这个模块才会输出值。</p>\n<p>加载这个模块的写法如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// usage.js</span><br><span class=\"hljs-keyword\">import</span> &#123; output &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./awaiting.js&quot;</span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">outputPlusValue</span>(<span class=\"hljs-params\">value</span>) </span>&#123; <span class=\"hljs-keyword\">return</span> output + value &#125;<br><br><span class=\"hljs-built_in\">console</span>.log(outputPlusValue(<span class=\"hljs-number\">100</span>));<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(outputPlusValue(<span class=\"hljs-number\">100</span>), <span class=\"hljs-number\">1000</span>);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。</p>\n<p>这时，模块的加载会等待依赖模块（上例是<code>awaiting.js</code>）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的<code>output</code>，不会因为加载时机的不同，而得到不一样的值。</p>\n<p>注意，顶层<code>await</code>只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的<code>require()</code>是同步加载，如果有顶层<code>await</code>，就没法处理加载了。</p>\n<p>下面是顶层<code>await</code>的一些使用场景。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// import() 方法加载</span><br><span class=\"hljs-keyword\">const</span> strings = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">`/i18n/<span class=\"hljs-subst\">$&#123;navigator.language&#125;</span>`</span>);<br><br><span class=\"hljs-comment\">// 数据库操作</span><br><span class=\"hljs-keyword\">const</span> connection = <span class=\"hljs-keyword\">await</span> dbConnector();<br><br><span class=\"hljs-comment\">// 依赖回滚</span><br><span class=\"hljs-keyword\">let</span> jQuery;<br><span class=\"hljs-keyword\">try</span> &#123;<br>  jQuery = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;https://cdn-a.com/jQuery&#x27;</span>);<br>&#125; <span class=\"hljs-keyword\">catch</span> &#123;<br>  jQuery = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;https://cdn-b.com/jQuery&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>注意，如果加载多个包含顶层<code>await</code>命令的模块，加载命令是同步执行的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// x.js</span><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;X1&quot;</span>);<br><span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">r</span> =&gt;</span> <span class=\"hljs-built_in\">setTimeout</span>(r, <span class=\"hljs-number\">1000</span>));<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;X2&quot;</span>);<br><br><span class=\"hljs-comment\">// y.js</span><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Y&quot;</span>);<br><br><span class=\"hljs-comment\">// z.js</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./x.js&quot;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./y.js&quot;</span>;<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Z&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码有三个模块，最后的<code>z.js</code>加载<code>x.js</code>和<code>y.js</code>，打印结果是<code>X1</code>、<code>Y</code>、<code>X2</code>、<code>Z</code>。这说明，<code>z.js</code>并没有等待<code>x.js</code>加载完成，再去加载<code>y.js</code>。</p>\n<p>顶层的<code>await</code>命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\n<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>\n<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// CommonJS模块</span><br><span class=\"hljs-keyword\">let</span> &#123; stat, exists, readfile &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs&#x27;</span>);<br><br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">let</span> _fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs&#x27;</span>);<br><span class=\"hljs-keyword\">let</span> stat = _fs.stat;<br><span class=\"hljs-keyword\">let</span> exists = _fs.exists;<br><span class=\"hljs-keyword\">let</span> readfile = _fs.readfile;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>\n<p>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES6模块</span><br><span class=\"hljs-keyword\">import</span> &#123; stat, exists, readFile &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;fs&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>\n<p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p>\n<p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p>\n<ul>\n<li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li>\n<li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li>\n<li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li>\n</ul>\n<p>本章介绍 ES6 模块的语法，下一章介绍如何在浏览器和 Node 之中，加载 ES6 模块。</p>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p>\n<p>严格模式主要有以下限制。</p>\n<ul>\n<li>变量必须声明后再使用</li>\n<li>函数的参数不能有同名属性，否则报错</li>\n<li>不能使用<code>with</code>语句</li>\n<li>不能对只读属性赋值，否则报错</li>\n<li>不能使用前缀 0 表示八进制数，否则报错</li>\n<li>不能删除不可删除的属性，否则报错</li>\n<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>\n<li><code>eval</code>不会在它的外层作用域引入变量</li>\n<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>\n<li><code>arguments</code>不会自动反映函数参数的变化</li>\n<li>不能使用<code>arguments.callee</code></li>\n<li>不能使用<code>arguments.caller</code></li>\n<li>禁止<code>this</code>指向全局对象</li>\n<li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>\n<li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li>\n</ul>\n<p>上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本书不再详细介绍了。</p>\n<p>其中，尤其需要注意<code>this</code>的限制。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code>。</p>\n<h2 id=\"export-命令\"><a href=\"#export-命令\" class=\"headerlink\" title=\"export 命令\"></a>export 命令</h2><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p>\n<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// profile.js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> firstName = <span class=\"hljs-string\">&#x27;Michael&#x27;</span>;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> lastName = <span class=\"hljs-string\">&#x27;Jackson&#x27;</span>;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> year = <span class=\"hljs-number\">1958</span>;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码是<code>profile.js</code>文件，保存了用户信息。ES6 将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p>\n<p><code>export</code>的写法，除了像上面这样，还有另外一种。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// profile.js</span><br><span class=\"hljs-keyword\">var</span> firstName = <span class=\"hljs-string\">&#x27;Michael&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> lastName = <span class=\"hljs-string\">&#x27;Jackson&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> year = <span class=\"hljs-number\">1958</span>;<br><br><span class=\"hljs-keyword\">export</span> &#123; firstName, lastName, year &#125;;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在<code>var</code>语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p>\n<p><code>export</code>命令除了输出变量，还可以输出函数或类（class）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">multiply</span>(<span class=\"hljs-params\">x, y</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> x * y;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码对外输出一个函数<code>multiply</code>。</p>\n<p>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">v1</span>(<span class=\"hljs-params\"></span>) </span>&#123; ... &#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">v2</span>(<span class=\"hljs-params\"></span>) </span>&#123; ... &#125;<br><br><span class=\"hljs-keyword\">export</span> &#123;<br>  v1 <span class=\"hljs-keyword\">as</span> streamV1,<br>  v2 <span class=\"hljs-keyword\">as</span> streamV2,<br>  v2 <span class=\"hljs-keyword\">as</span> streamLatestVersion<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p>\n<p>需要特别注意的是，<code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 报错</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-number\">1</span>;<br><br><span class=\"hljs-comment\">// 报错</span><br><span class=\"hljs-keyword\">var</span> m = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">export</span> m;<br></code></pre></td></tr></table></figure>\n\n<p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量<code>m</code>，还是直接输出 1。<code>1</code>只是一个值，不是接口。正确的写法是下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 写法一</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> m = <span class=\"hljs-number\">1</span>;<br><br><span class=\"hljs-comment\">// 写法二</span><br><span class=\"hljs-keyword\">var</span> m = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">export</span> &#123;m&#125;;<br><br><span class=\"hljs-comment\">// 写法三</span><br><span class=\"hljs-keyword\">var</span> n = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">export</span> &#123;n <span class=\"hljs-keyword\">as</span> m&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>上面三种写法都是正确的，规定了对外的接口<code>m</code>。其他脚本可以通过这个接口，取到值<code>1</code>。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p>\n<p>同样的，<code>function</code>和<code>class</code>的输出，也必须遵守这样的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 报错</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>) </span>&#123;&#125;<br><span class=\"hljs-keyword\">export</span> f;<br><br><span class=\"hljs-comment\">// 正确</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>) </span>&#123;&#125;;<br><br><span class=\"hljs-comment\">// 正确</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>) </span>&#123;&#125;<br><span class=\"hljs-keyword\">export</span> &#123;f&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>另外，<code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-string\">&#x27;bar&#x27;</span>;<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> foo = <span class=\"hljs-string\">&#x27;baz&#x27;</span>, <span class=\"hljs-number\">500</span>);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500 毫秒之后变成<code>baz</code>。</p>\n<p>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新，详见下文《Module 的加载实现》一节。</p>\n<p>最后，<code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-string\">&#x27;bar&#x27;</span> <span class=\"hljs-comment\">// SyntaxError</span><br>&#125;<br>foo()<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>export</code>语句放在函数之中，结果报错。</p>\n<h2 id=\"import-命令\"><a href=\"#import-命令\" class=\"headerlink\" title=\"import 命令\"></a>import 命令</h2><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// main.js</span><br><span class=\"hljs-keyword\">import</span> &#123; firstName, lastName, year &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./profile.js&#x27;</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">setName</span>(<span class=\"hljs-params\">element</span>) </span>&#123;<br>  element.textContent = firstName + <span class=\"hljs-string\">&#x27; &#x27;</span> + lastName;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码的<code>import</code>命令，用于加载<code>profile.js</code>文件，并从中输入变量。<code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p>\n<p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; lastName <span class=\"hljs-keyword\">as</span> surname &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./profile.js&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p><code>import</code>命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123;a&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./xxx.js&#x27;</span><br><br>a = &#123;&#125;; <span class=\"hljs-comment\">// Syntax Error : &#x27;a&#x27; is read-only;</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，脚本加载了变量<code>a</code>，对其重新赋值就会报错，因为<code>a</code>是一个只读的接口。但是，如果<code>a</code>是一个对象，改写<code>a</code>的属性是允许的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123;a&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./xxx.js&#x27;</span><br><br>a.foo = <span class=\"hljs-string\">&#x27;hello&#x27;</span>; <span class=\"hljs-comment\">// 合法操作</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>a</code>的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。</p>\n<p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径。如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; myMethod &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;util&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>util</code>是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p>\n<p>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">foo();<br><br><span class=\"hljs-keyword\">import</span> &#123; foo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;my_module&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。</p>\n<p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 报错</span><br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-string\">&#x27;f&#x27;</span> + <span class=\"hljs-string\">&#x27;oo&#x27;</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;my_module&#x27;</span>;<br><br><span class=\"hljs-comment\">// 报错</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-built_in\">module</span> = <span class=\"hljs-string\">&#x27;my_module&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; foo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-built_in\">module</span>;<br><br><span class=\"hljs-comment\">// 报错</span><br><span class=\"hljs-keyword\">if</span> (x === <span class=\"hljs-number\">1</span>) &#123;<br>  <span class=\"hljs-keyword\">import</span> &#123; foo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;module1&#x27;</span>;<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>  <span class=\"hljs-keyword\">import</span> &#123; foo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;module2&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面三种写法都会报错，因为它们用到了表达式、变量和<code>if</code>结构。在静态分析阶段，这些语法都是没法得到值的。</p>\n<p>最后，<code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;lodash&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p>\n<p>如果多次重复执行同一句<code>import</code>语句，那么只会执行一次，而不会执行多次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;lodash&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;lodash&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码加载了两次<code>lodash</code>，但是只会执行一次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; foo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;my_module&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; bar &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;my_module&#x27;</span>;<br><br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">import</span> &#123; foo, bar &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;my_module&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，虽然<code>foo</code>和<code>bar</code>在两个语句中加载，但是它们对应的是同一个<code>my_module</code>模块。也就是说，<code>import</code>语句是 Singleton 模式。</p>\n<p>目前阶段，通过 Babel 转码，CommonJS 模块的<code>require</code>命令和 ES6 模块的<code>import</code>命令，可以写在同一个模块里面，但是最好不要这样做。因为<code>import</code>在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;core-js/modules/es6.symbol&#x27;</span>);<br><span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;core-js/modules/es6.promise&#x27;</span>);<br><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;React&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"模块的整体加载\"><a href=\"#模块的整体加载\" class=\"headerlink\" title=\"模块的整体加载\"></a>模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</p>\n<p>下面是一个<code>circle.js</code>文件，它输出两个方法<code>area</code>和<code>circumference</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// circle.js</span><br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">area</span>(<span class=\"hljs-params\">radius</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Math</span>.PI * radius * radius;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">circumference</span>(<span class=\"hljs-params\">radius</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span> * <span class=\"hljs-built_in\">Math</span>.PI * radius;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>现在，加载这个模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// main.js</span><br><br><span class=\"hljs-keyword\">import</span> &#123; area, circumference &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./circle&#x27;</span>;<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;圆面积：&#x27;</span> + area(<span class=\"hljs-number\">4</span>));<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;圆周长：&#x27;</span> + circumference(<span class=\"hljs-number\">14</span>));<br></code></pre></td></tr></table></figure>\n\n<p>上面写法是逐一指定要加载的方法，整体加载的写法如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> circle <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./circle&#x27;</span>;<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;圆面积：&#x27;</span> + circle.area(<span class=\"hljs-number\">4</span>));<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;圆周长：&#x27;</span> + circle.circumference(<span class=\"hljs-number\">14</span>));<br></code></pre></td></tr></table></figure>\n\n<p>注意，模块整体加载所在的那个对象（上例是<code>circle</code>），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> circle <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./circle&#x27;</span>;<br><br><span class=\"hljs-comment\">// 下面两行都是不允许的</span><br>circle.foo = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>circle.area = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"export-default-命令\"><a href=\"#export-default-命令\" class=\"headerlink\" title=\"export default 命令\"></a>export default 命令</h2><p>从前面的例子可以看出，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p>\n<p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<code>export default</code>命令，为模块指定默认输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// export-default.js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p>\n<p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// import-default.js</span><br><span class=\"hljs-keyword\">import</span> customName <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./export-default&#x27;</span>;<br>customName(); <span class=\"hljs-comment\">// &#x27;foo&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p>\n<p><code>export default</code>命令用在非匿名函数前，也是可以的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// export-default.js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// 或者写成</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> foo;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>foo</code>函数的函数名<code>foo</code>，在模块外部是无效的。加载的时候，视同匿名函数加载。</p>\n<p>下面比较一下默认输出和正常输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 第一组</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">crc32</span>(<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-comment\">// 输出</span><br>  <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br><span class=\"hljs-keyword\">import</span> crc32 <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;crc32&#x27;</span>; <span class=\"hljs-comment\">// 输入</span><br><br><span class=\"hljs-comment\">// 第二组</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">crc32</span>(<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-comment\">// 输出</span><br>  <span class=\"hljs-comment\">// ...</span><br>&#125;;<br><br><span class=\"hljs-keyword\">import</span> &#123;crc32&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;crc32&#x27;</span>; <span class=\"hljs-comment\">// 输入</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码的两组写法，第一组是使用<code>export default</code>时，对应的<code>import</code>语句不需要使用大括号；第二组是不使用<code>export default</code>时，对应的<code>import</code>语句需要使用大括号。</p>\n<p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令。</p>\n<p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// modules.js</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\">x, y</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> x * y;<br>&#125;<br><span class=\"hljs-keyword\">export</span> &#123;add <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">default</span>&#125;;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-comment\">// export default add;</span><br><br><span class=\"hljs-comment\">// app.js</span><br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">as</span> foo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;modules&#x27;</span>;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-comment\">// import foo from &#x27;modules&#x27;;</span><br></code></pre></td></tr></table></figure>\n\n<p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 正确</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;<br><br><span class=\"hljs-comment\">// 正确</span><br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> a;<br><br><span class=\"hljs-comment\">// 错误</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>export default a</code>的含义是将变量<code>a</code>的值赋给变量<code>default</code>。所以，最后一种写法会报错。</p>\n<p>同样地，因为<code>export default</code>命令的本质是将后面的值，赋给<code>default</code>变量，所以可以直接将一个值写在<code>export default</code>之后。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 正确</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">42</span>;<br><br><span class=\"hljs-comment\">// 报错</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-number\">42</span>;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为<code>default</code>。</p>\n<p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入 lodash 模块为例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> _ <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;lodash&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>如果想在一条<code>import</code>语句中，同时输入默认方法和其他接口，可以写成下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> _, &#123; each, forEach &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;lodash&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>对应上面代码的<code>export</code>语句如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">obj</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// ···</span><br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">each</span>(<span class=\"hljs-params\">obj, iterator, context</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// ···</span><br>&#125;<br><br><span class=\"hljs-keyword\">export</span> &#123; each <span class=\"hljs-keyword\">as</span> forEach &#125;;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码的最后一行的意思是，暴露出<code>forEach</code>接口，默认指向<code>each</code>接口，即<code>forEach</code>和<code>each</code>指向同一个方法。</p>\n<p><code>export default</code>也可以用来输出类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// MyClass.js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> </span>&#123; ... &#125;<br><br><span class=\"hljs-comment\">// main.js</span><br><span class=\"hljs-keyword\">import</span> MyClass <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;MyClass&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> o = <span class=\"hljs-keyword\">new</span> MyClass();<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"export-与-import-的复合写法\"><a href=\"#export-与-import-的复合写法\" class=\"headerlink\" title=\"export 与 import 的复合写法\"></a>export 与 import 的复合写法</h2><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">export</span> &#123; foo, bar &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;my_module&#x27;</span>;<br><br><span class=\"hljs-comment\">// 可以简单理解为</span><br><span class=\"hljs-keyword\">import</span> &#123; foo, bar &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;my_module&#x27;</span>;<br><span class=\"hljs-keyword\">export</span> &#123; foo, bar &#125;;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>export</code>和<code>import</code>语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，<code>foo</code>和<code>bar</code>实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用<code>foo</code>和<code>bar</code>。</p>\n<p>模块的接口改名和整体输出，也可以采用这种写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 接口改名</span><br><span class=\"hljs-keyword\">export</span> &#123; foo <span class=\"hljs-keyword\">as</span> myFoo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;my_module&#x27;</span>;<br><br><span class=\"hljs-comment\">// 整体输出</span><br><span class=\"hljs-keyword\">export</span> * <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;my_module&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>默认接口的写法如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">export</span> &#123; <span class=\"hljs-keyword\">default</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;foo&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>具名接口改为默认接口的写法如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">export</span> &#123; es6 <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">default</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./someModule&#x27;</span>;<br><br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">import</span> &#123; es6 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./someModule&#x27;</span>;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> es6;<br></code></pre></td></tr></table></figure>\n\n<p>同样地，默认接口也可以改名为具名接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">export</span> &#123; <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">as</span> es6 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./someModule&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>ES2020 之前，有一种<code>import</code>语句，没有对应的复合写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> someIdentifier <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;someModule&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/tc39/proposal-export-ns-from\">ES2020</a>补上了这个写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">export</span> * <span class=\"hljs-keyword\">as</span> ns <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;mod&quot;</span>;<br><br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> ns <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;mod&quot;</span>;<br><span class=\"hljs-keyword\">export</span> &#123;ns&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"模块的继承\"><a href=\"#模块的继承\" class=\"headerlink\" title=\"模块的继承\"></a>模块的继承</h2><p>模块之间也可以继承。</p>\n<p>假设有一个<code>circleplus</code>模块，继承了<code>circle</code>模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// circleplus.js</span><br><br><span class=\"hljs-keyword\">export</span> * <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;circle&#x27;</span>;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> e = <span class=\"hljs-number\">2.71828182846</span>;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Math</span>.exp(x);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中的<code>export *</code>，表示再输出<code>circle</code>模块的所有属性和方法。注意，<code>export *</code>命令会忽略<code>circle</code>模块的<code>default</code>方法。然后，上面代码又输出了自定义的<code>e</code>变量和默认方法。</p>\n<p>这时，也可以将<code>circle</code>的属性或方法，改名后再输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// circleplus.js</span><br><br><span class=\"hljs-keyword\">export</span> &#123; area <span class=\"hljs-keyword\">as</span> circleArea &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;circle&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码表示，只输出<code>circle</code>模块的<code>area</code>方法，且将其改名为<code>circleArea</code>。</p>\n<p>加载上面模块的写法如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// main.js</span><br><br><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> math <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;circleplus&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> exp <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;circleplus&#x27;</span>;<br><span class=\"hljs-built_in\">console</span>.log(exp(math.e));<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中的<code>import exp</code>表示，将<code>circleplus</code>模块的默认方法加载为<code>exp</code>方法。</p>\n<h2 id=\"跨模块常量\"><a href=\"#跨模块常量\" class=\"headerlink\" title=\"跨模块常量\"></a>跨模块常量</h2><p>本书介绍<code>const</code>命令的时候说过，<code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// constants.js 模块</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> A = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> B = <span class=\"hljs-number\">3</span>;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> C = <span class=\"hljs-number\">4</span>;<br><br><span class=\"hljs-comment\">// test1.js 模块</span><br><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> constants <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./constants&#x27;</span>;<br><span class=\"hljs-built_in\">console</span>.log(constants.A); <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-built_in\">console</span>.log(constants.B); <span class=\"hljs-comment\">// 3</span><br><br><span class=\"hljs-comment\">// test2.js 模块</span><br><span class=\"hljs-keyword\">import</span> &#123;A, B&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./constants&#x27;</span>;<br><span class=\"hljs-built_in\">console</span>.log(A); <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-built_in\">console</span>.log(B); <span class=\"hljs-comment\">// 3</span><br></code></pre></td></tr></table></figure>\n\n<p>如果要使用的常量非常多，可以建一个专门的<code>constants</code>目录，将各种常量写在不同的文件里面，保存在该目录下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// constants/db.js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> db = &#123;<br>  url: <span class=\"hljs-string\">&#x27;http://my.couchdbserver.local:5984&#x27;</span>,<br>  admin_username: <span class=\"hljs-string\">&#x27;admin&#x27;</span>,<br>  admin_password: <span class=\"hljs-string\">&#x27;admin password&#x27;</span><br>&#125;;<br><br><span class=\"hljs-comment\">// constants/user.js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> users = [<span class=\"hljs-string\">&#x27;root&#x27;</span>, <span class=\"hljs-string\">&#x27;admin&#x27;</span>, <span class=\"hljs-string\">&#x27;staff&#x27;</span>, <span class=\"hljs-string\">&#x27;ceo&#x27;</span>, <span class=\"hljs-string\">&#x27;chief&#x27;</span>, <span class=\"hljs-string\">&#x27;moderator&#x27;</span>];<br></code></pre></td></tr></table></figure>\n\n<p>然后，将这些文件输出的常量，合并在<code>index.js</code>里面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// constants/index.js</span><br><span class=\"hljs-keyword\">export</span> &#123;db&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./db&#x27;</span>;<br><span class=\"hljs-keyword\">export</span> &#123;users&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./users&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>使用的时候，直接加载<code>index.js</code>就可以了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// script.js</span><br><span class=\"hljs-keyword\">import</span> &#123;db, users&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./constants/index&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import()\"></a>import()</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>前面介绍过，<code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（<code>import</code>命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 报错</span><br><span class=\"hljs-keyword\">if</span> (x === <span class=\"hljs-number\">2</span>) &#123;<br>  <span class=\"hljs-keyword\">import</span> MyModual <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./myModual&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，<code>import</code>和<code>export</code>命令只能在模块的顶层，不能在代码块之中（比如，在<code>if</code>代码块之中，或在函数之中）。</p>\n<p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果<code>import</code>命令要取代 Node 的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-string\">&#x27;./&#x27;</span> + fileName;<br><span class=\"hljs-keyword\">const</span> myModual = <span class=\"hljs-built_in\">require</span>(path);<br></code></pre></td></tr></table></figure>\n\n<p>上面的语句就是动态加载，<code>require</code>到底加载哪一个模块，只有运行时才知道。<code>import</code>命令做不到这一点。</p>\n<p><a href=\"https://github.com/tc39/proposal-dynamic-import\">ES2020提案</a> 引入<code>import()</code>函数，支持动态加载模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span>(specifier)<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</p>\n<p><code>import()</code>返回一个 Promise 对象。下面是一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> main = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;main&#x27;</span>);<br><br><span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">`./section-modules/<span class=\"hljs-subst\">$&#123;someVariable&#125;</span>.js`</span>)<br>  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">module</span> =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">module</span>.loadPageInto(main);<br>  &#125;)<br>  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> &#123;<br>    main.textContent = err.message;<br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。<code>import()</code>类似于 Node 的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。</p>\n<h3 id=\"适用场合\"><a href=\"#适用场合\" class=\"headerlink\" title=\"适用场合\"></a>适用场合</h3><p>下面是<code>import()</code>的一些适用场合。</p>\n<p>（1）按需加载。</p>\n<p><code>import()</code>可以在需要的时候，再加载某个模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">button.addEventListener(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./dialogBox.js&#x27;</span>)<br>  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">dialogBox</span> =&gt;</span> &#123;<br>    dialogBox.open();<br>  &#125;)<br>  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> &#123;<br>    <span class=\"hljs-comment\">/* Error handling */</span><br>  &#125;)<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>import()</code>方法放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p>\n<p>（2）条件加载</p>\n<p><code>import()</code>可以放在<code>if</code>代码块，根据不同的情况，加载不同的模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">if</span> (condition) &#123;<br>  <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;moduleA&#x27;</span>).then(...);<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>  <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;moduleB&#x27;</span>).then(...);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。</p>\n<p>（3）动态的模块路径</p>\n<p><code>import()</code>允许模块路径动态生成。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span>(f())<br>.then(...);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，根据函数<code>f</code>的返回结果，加载不同的模块。</p>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><p><code>import()</code>加载模块成功以后，这个模块会作为一个对象，当作<code>then</code>方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./myModule.js&#x27;</span>)<br>.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">&#123;export1, export2&#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">// ...·</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>export1</code>和<code>export2</code>都是<code>myModule.js</code>的输出接口，可以解构获得。</p>\n<p>如果模块有<code>default</code>输出接口，可以用参数直接获得。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./myModule.js&#x27;</span>)<br>.then(<span class=\"hljs-function\"><span class=\"hljs-params\">myModule</span> =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(myModule.default);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>上面的代码也可以使用具名输入的形式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./myModule.js&#x27;</span>)<br>.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">&#123;<span class=\"hljs-keyword\">default</span>: theDefault&#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(theDefault);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>如果想同时加载多个模块，可以采用下面的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Promise</span>.all([<br>  <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./module1.js&#x27;</span>),<br>  <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./module2.js&#x27;</span>),<br>  <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./module3.js&#x27;</span>),<br>])<br>.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">[module1, module2, module3]</span>) =&gt;</span> &#123;<br>   ···<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p><code>import()</code>也可以用在 async 函数之中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> myModule = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./myModule.js&#x27;</span>);<br>  <span class=\"hljs-keyword\">const</span> &#123;export1, export2&#125; = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./myModule.js&#x27;</span>);<br>  <span class=\"hljs-keyword\">const</span> [module1, module2, module3] =<br>    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.all([<br>      <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./module1.js&#x27;</span>),<br>      <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./module2.js&#x27;</span>),<br>      <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./module3.js&#x27;</span>),<br>    ]);<br>&#125;<br>main();<br></code></pre></td></tr></table></figure>","raw":null,"categories":[],"tags":[{"name":"es6","path":"api/tags/es6.json"}]}]}