{"total":24,"pageSize":10,"pageCount":3,"data":[{"title":"vue源码理解——指令篇","slug":"vue源码理解8","date":"2021-03-18T11:29:18.000Z","updated":"2021-04-25T06:58:40.444Z","comments":true,"top":null,"path":"api/articles/vue源码理解8.json","excerpt":null,"keywords":null,"cover":null,"content":"<h4 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h4><p>在<code>Vue</code>中，除了<code>Vue</code>本身为我们提供的一些内置指令之外，<code>Vue</code>还支持用户自定义指令。并且用户有两种定义指令的方式：一种是使用全局API——<code>Vue.directive</code>来定义全局指令，这种方式定义的指令会被存放在<code>Vue.options[&#39;directives&#39;]</code>中；另一种是在组件内的<code>directive</code>选项中定义专为该组件使用的局部指令，这种方式定义的指令会被存放在<code>vm.$options[&#39;directives&#39;]</code>中。</p>\n<p>可以看到，无论是使用哪一种方式定义的指令它都是将定义好的指令存放在指定的地方，而并不能让指令生效。那么定义的指令什么时候才会生效呢？或者说它是如何生效的呢？本篇文章就来带你探究自定义指令如何生效的内部原理。</p>\n<p>撸码一时爽，一直撸码一直爽！！！</p>\n","raw":null,"categories":[],"tags":[{"name":"vue源码理解——指令篇","path":"api/tags/vue源码理解——指令篇.json"}]},{"title":"vue源码理解——过滤器篇","slug":"vue源码理解7","date":"2021-03-18T11:29:18.000Z","updated":"2021-04-25T06:58:00.896Z","comments":true,"top":null,"path":"api/articles/vue源码理解7.json","excerpt":null,"keywords":null,"cover":null,"content":"<h4 id=\"过虑器\"><a href=\"#过虑器\" class=\"headerlink\" title=\"过虑器\"></a>过虑器</h4><p>过滤器在我们日常开发中应该算是一个非常常用的功能了，它经常会被用来格式化模板中的文本。过滤器可以单个使用，也可以多个串联一起使用，还可以传参数使用。那么在<code>Vue</code>中过滤器是如何工作的呢？其内部原理是怎样的？<code>Vue</code>又是如何识别出我们所写的过滤器的？接下来，我们将从源码角度出发，探究过滤器内部的工作原理，分析其工作流程，揭开它神秘的面纱。</p>\n<p>撸码一时爽，一直撸码一直爽！！！</p>\n","raw":null,"categories":[],"tags":[{"name":"vue源码理解——过滤器篇","path":"api/tags/vue源码理解——过滤器篇.json"}]},{"title":"vue源码理解——内置组件篇","slug":"vue源码理解9","date":"2021-03-18T11:29:18.000Z","updated":"2021-04-25T06:59:08.263Z","comments":true,"top":null,"path":"api/articles/vue源码理解9.json","excerpt":null,"keywords":null,"cover":null,"content":"<h4 id=\"内置组件\"><a href=\"#内置组件\" class=\"headerlink\" title=\"内置组件\"></a>内置组件</h4><p><code>&lt;keep-alive&gt;</code> 是 <code>Vue</code> 实现的一个内置组件，也就是说 <code>Vue</code> 源码不仅实现了一套组件化的机制，也实现了一些内置组件，关于<code>&lt;keep-alive&gt;</code>组件，官网如下介绍：</p>\n<blockquote>\n<p><code>&lt;keep-alive&gt;</code>是<code>Vue</code>中内置的一个抽象组件，它自身不会渲染一个 <code>DOM</code> 元素，也不会出现在父组件链中。当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。</p>\n</blockquote>\n<p>这句话的意思简单来说：就是我们可以把一些不常变动的组件或者需要缓存的组件用<code>&lt;keep-alive&gt;</code>包裹起来，这样<code>&lt;keep-alive&gt;</code>就会帮我们把组件保存在内存中，而不是直接的销毁，这样做可以保留组件的状态或避免多次重新渲染，以提高页面性能。</p>\n<p>撸码一时爽，一直撸码一直爽！！！</p>\n","raw":null,"categories":[],"tags":[{"name":"vue源码理解——内置组件篇","path":"api/tags/vue源码理解——内置组件篇.json"}]},{"title":"小程序","slug":"小程序","date":"2020-09-18T11:14:53.000Z","updated":"2021-09-13T04:02:09.389Z","comments":true,"top":null,"path":"api/articles/小程序.json","excerpt":null,"keywords":null,"cover":"https://images.weserv.nl/?url=https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1620680741158-48410cc39150.jpg","content":"<p><img src=\"https://images.weserv.nl/?url=https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1620680741158-48410cc39150.jpg\" alt=\"img\"></p>\n<h3 id=\"微信公众平台\"><a href=\"#微信公众平台\" class=\"headerlink\" title=\"微信公众平台\"></a>微信公众平台</h3><p>地址：<a href=\"https://mp.weixin.qq.com/\">https://mp.weixin.qq.com/</a></p>\n<h5 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h5><p>微信公众平台，简称公众号。曾命名为’官号平台’、’媒体平台’、’微信公众号’，最终定位公众平台</p>\n<h3 id=\"微信小程序\"><a href=\"#微信小程序\" class=\"headerlink\" title=\"微信小程序\"></a>微信小程序</h3><h5 id=\"概念：\"><a href=\"#概念：\" class=\"headerlink\" title=\"概念：\"></a>概念：</h5><p>就是一个简化的app应用，2017年1月9日，微信之父张小龙发布第一款微信小程序</p>\n<h5 id=\"优点和缺点\"><a href=\"#优点和缺点\" class=\"headerlink\" title=\"优点和缺点\"></a>优点和缺点</h5><ul>\n<li>优点</li>\n</ul>\n<p>1对用户而言，节省了手机内存，即开即用，用户体验好</p>\n<p>2对开发者而言</p>\n<p>(1) 开发成本（时间   技术   资金）上，接近h5，要比原生app（android   ios）端低</p>\n<p>(2 )功能上，接近原生app，比h5强大，比如重力感应  定位等</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>1项目大小是2M限制（分包加载优化）</p>\n<p>2分享到朋友圈权限android，不支持ios</p>\n<p>3项目发布需要微信团队审核，审核周期1-7日</p>\n<p>4功能对于个人开发者有些限制，比如支付  表单提交 （社交分享类）</p>\n<h4 id=\"注册微信小程序开发者账号\"><a href=\"#注册微信小程序开发者账号\" class=\"headerlink\" title=\"注册微信小程序开发者账号\"></a>注册微信小程序开发者账号</h4><p>地址</p>\n<p><a href=\"https://mp.weixin.qq.com/\">https://mp.weixin.qq.com/</a></p>\n<h4 id=\"微信开发者工具下载安装\"><a href=\"#微信开发者工具下载安装\" class=\"headerlink\" title=\"微信开发者工具下载安装\"></a>微信开发者工具下载安装</h4><h5 id=\"地址：\"><a href=\"#地址：\" class=\"headerlink\" title=\"地址：\"></a>地址：</h5><p><a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html\">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a></p>\n<p>下载稳定版</p>\n<p>安装时无需注意，一直next就可以了</p>\n","raw":null,"categories":[],"tags":[]},{"title":"算法理解","slug":"算法理解","date":"2020-09-18T11:14:53.000Z","updated":"2021-09-13T03:47:33.301Z","comments":true,"top":null,"path":"api/articles/算法理解.json","excerpt":null,"keywords":null,"cover":"https://images.weserv.nl/?url=https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1621940022939-67cbe6a348d8.jpg","content":"<p><img src=\"https://images.weserv.nl/?url=https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1621940022939-67cbe6a348d8.jpg\" alt=\"img\"></p>\n<h5 id=\"两数之和：\"><a href=\"#两数之和：\" class=\"headerlink\" title=\"两数之和：\"></a>两数之和：</h5><p>​    思路（javaScript）：使用map函数，利用差值判断并返回值。</p>\n<p>​    代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><br><span class=\"hljs-keyword\">var</span> findSum=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums,target</span>)</span>&#123;<br>    <span class=\"hljs-keyword\">let</span>  map=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>,len=nums.length;i&lt;len;i++)&#123;<br>        <br>        <span class=\"hljs-comment\">//利用差值判断是否有存在与其对应的值</span><br>        <span class=\"hljs-keyword\">let</span> key =target-nums[i]<br>        <span class=\"hljs-keyword\">if</span>(map.has(key))&#123;<br>            <span class=\"hljs-keyword\">return</span> [map.get(key),i]<br>        &#125;<br>        map.set(nums[i],i)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"整数反转：\"><a href=\"#整数反转：\" class=\"headerlink\" title=\"整数反转：\"></a>整数反转：</h5><p>​    思路（javaScript）：利用对10取余，向下取整，二者对应的思想</p>\n<p>​    代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> fn=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">num</span>)</span>&#123;<br>    <span class=\"hljs-keyword\">let</span> res=<span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">while</span>(num)&#123;<br>        res=res*<span class=\"hljs-number\">10</span>+num%<span class=\"hljs-number\">10</span><br>        <span class=\"hljs-comment\">//res &gt; Math.pow(2, 31) - 1 || res &lt; Math.pow(-2, 31)字节的最小和最大</span><br>        <span class=\"hljs-keyword\">if</span>(res &gt; <span class=\"hljs-built_in\">Math</span>.pow(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">31</span>) - <span class=\"hljs-number\">1</span> || res &lt; <span class=\"hljs-built_in\">Math</span>.pow(<span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">31</span>))&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br>        &#125;<br>        <span class=\"hljs-comment\">// ~~可以理解向下取整，类似Math.floor()</span><br>        num=~~(num/<span class=\"hljs-number\">10</span>)<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"正序数组的中位数：\"><a href=\"#正序数组的中位数：\" class=\"headerlink\" title=\"正序数组的中位数：\"></a>正序数组的中位数：</h5><p>思路（javaScript）：合并数组（concat）并排序（.sort（a,b）=&gt;a-b），在用下标对2取余如果是奇数就就取[nums  .length / 2],如果是偶数就取(nums[nums.length/2-1]+nums[nums/2])/2</p>\n<p>代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> find = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">nums1, nums2</span>) </span>&#123;<br>       <span class=\"hljs-keyword\">let</span> nums = nums1.concat(nums2).sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a - b)<br>       <span class=\"hljs-keyword\">return</span> nums.length % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span> ? (nums[nums.length / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">1</span>] + nums[nums.length / <span class=\"hljs-number\">2</span>]) / <span class=\"hljs-number\">2</span> : nums[<span class=\"hljs-built_in\">Math</span>.floor(nums<br>          .length / <span class=\"hljs-number\">2</span>)]<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n","raw":null,"categories":[],"tags":[{"name":"算法理解","path":"api/tags/算法理解.json"}]},{"title":"javascript 1","slug":"javascript","date":"2020-09-22T10:40:54.000Z","updated":"2021-09-13T04:03:29.422Z","comments":true,"top":null,"path":"api/articles/javascript.json","excerpt":null,"keywords":null,"cover":"https://images.weserv.nl/?url=https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1625903443536-ec7e0e5fc341.jpg","content":"<p><img src=\"https://images.weserv.nl/?url=https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1625903443536-ec7e0e5fc341.jpg\" alt=\"img\"></p>\n<h1 id=\"javascript\"><a href=\"#javascript\" class=\"headerlink\" title=\"javascript\"></a>javascript</h1><h3 id=\"1-JavaScript-是什么\"><a href=\"#1-JavaScript-是什么\" class=\"headerlink\" title=\"1 JavaScript 是什么\"></a>1 JavaScript 是什么</h3><p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/图片7.png\"></p>\n<ul>\n<li><p>JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 是脚本的意思）</p>\n</li>\n<li><p>脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行</p>\n</li>\n<li><p>现在也可以基于 Node.js 技术进行服务器端编程</p>\n<p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/图片8.png\"></p>\n</li>\n</ul>\n<h3 id=\"3-2-JavaScript的作用\"><a href=\"#3-2-JavaScript的作用\" class=\"headerlink\" title=\"3.2 JavaScript的作用\"></a>3.2 JavaScript的作用</h3><ul>\n<li>表单动态校验（密码强度检测）  （ JS 产生最初的目的 ）</li>\n<li>网页特效</li>\n<li>服务端开发(Node.js)</li>\n<li>桌面程序(Electron)</li>\n<li>App(Cordova) </li>\n<li>控制硬件-物联网(Ruff)</li>\n<li>游戏开发(cocos2d-js)</li>\n</ul>\n<h3 id=\"3-3-HTML-CSS-JS-的关系\"><a href=\"#3-3-HTML-CSS-JS-的关系\" class=\"headerlink\" title=\"3.3 HTML/CSS/JS 的关系\"></a>3.3 HTML/CSS/JS 的关系</h3><p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/图片9.png\"></p>\n<h3 id=\"3-4-浏览器执行-JS-简介\"><a href=\"#3-4-浏览器执行-JS-简介\" class=\"headerlink\" title=\"3.4 浏览器执行 JS 简介\"></a>3.4 浏览器执行 JS 简介</h3><p><strong>浏览器分成两部分：渲染引擎和 JS 引擎</strong></p>\n<p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/neihe.png\"></p>\n<pre><code>    浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。</code></pre>\n<p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/图片10.png\"></p>\n<h3 id=\"3-5-JS-的组成\"><a href=\"#3-5-JS-的组成\" class=\"headerlink\" title=\"3.5 JS 的组成\"></a>3.5 JS 的组成</h3><p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/图片11.png\"></p>\n<h4 id=\"1-ECMAScript\"><a href=\"#1-ECMAScript\" class=\"headerlink\" title=\"1.ECMAScript\"></a><strong>1.ECMAScript</strong></h4><p>​        ECMAScript 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。</p>\n<p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/图片12.png\"></p>\n<p>​        ECMAScript：规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。</p>\n<p>更多参看MDN: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview\">MDN手册</a></p>\n<h4 id=\"2-DOM——文档对象模型\"><a href=\"#2-DOM——文档对象模型\" class=\"headerlink\" title=\"2.DOM——文档对象模型\"></a><strong>2.DOM——文档对象模型</strong></h4><p>​        <strong>文档对象模型</strong>（DocumentObject Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）</p>\n<h4 id=\"3-BOM——浏览器对象模型\"><a href=\"#3-BOM——浏览器对象模型\" class=\"headerlink\" title=\"3.BOM——浏览器对象模型\"></a><strong>3.BOM——浏览器对象模型</strong></h4><p>​        <strong>浏览器对象模型</strong>(Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</p>\n<h3 id=\"3-6-JavaScript的特点\"><a href=\"#3-6-JavaScript的特点\" class=\"headerlink\" title=\"3.6  JavaScript的特点\"></a>3.6  JavaScript的特点</h3><p>​        JavaScript是基于对象和事件驱动的解释性的脚本语言，适用于静态或动态页面，是一种广泛使用的客户端脚本语言，它具有解释性、基于对象、事件驱动、安全性和跨平台等特点。</p>\n<h4 id=\"1-解释性\"><a href=\"#1-解释性\" class=\"headerlink\" title=\"1.  解释性\"></a>1.  解释性</h4><p>JavaScript 不同于一些编译性的程序语言，例如 C、C++ 等，他是一种解释性的程序语言，它的源代码不需要经过编译，而直接在浏览器种运行时被解析。</p>\n<h4 id=\"2-基于对象\"><a href=\"#2-基于对象\" class=\"headerlink\" title=\"2.  基于对象\"></a>2.  基于对象</h4><p>JavaScript 是一种基于对象的语言，这意味着它能运用自己已经创建的对象，因此，许多功能可以来自脚本环境中对象的方法与脚本的相互作用。</p>\n<h4 id=\"3-事件驱动\"><a href=\"#3-事件驱动\" class=\"headerlink\" title=\"3.  事件驱动\"></a>3.  事件驱动</h4><p>JavaScript 可以直接对用户或者客户输入做出响应，无须经过 web 服务器，它对用户的响应，以事件驱动的方式进行。</p>\n<h4 id=\"4-跨平台\"><a href=\"#4-跨平台\" class=\"headerlink\" title=\"4.  跨平台\"></a>4.  跨平台</h4><p>JavaScript依赖于浏览器本身，与操作环境无关，只要能运行浏览器的计算机，并支持 JavaScript 的浏览器就可正常执行。</p>\n<h3 id=\"3-7-JS-初体验\"><a href=\"#3-7-JS-初体验\" class=\"headerlink\" title=\"3.7 JS 初体验\"></a>3.7 JS 初体验</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">JS 有<span class=\"hljs-number\">3</span>种书写位置，分别为行内、内嵌和外部。<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>行内式</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;点我试试&quot;</span> <span class=\"hljs-attr\">onclick</span>=<span class=\"hljs-string\">&quot;alert(&#x27;Hello World&#x27;)&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），如：onclick</li>\n<li>注意单双引号的使用：在HTML中我们推荐使用双引号, JS 中我们推荐使用单引号</li>\n<li>可读性差， 在html中编写JS大量代码时，不方便阅读；</li>\n<li>引号易错，引号多层嵌套匹配时，非常容易弄混；</li>\n<li>特殊情况下使用</li>\n</ul>\n</li>\n<li><p>内嵌式</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"javascript\">    alert(<span class=\"hljs-string\">&#x27;Hello  World~!&#x27;</span>);</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>可以将多行JS代码写到 script 标签中</li>\n<li>内嵌 JS 是学习时常用的方式</li>\n</ul>\n</li>\n<li><p>外部JS文件</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;my.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>利于HTML页面代码结构化，把大段 JS代码独立到 HTML 页面之外，既美观，也方便文件级别的复用</li>\n<li>引用外部 JS文件的 script 标签中间不可以写代码</li>\n<li>适合于JS 代码量比较大的情况</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"4-JavaScript注释\"><a href=\"#4-JavaScript注释\" class=\"headerlink\" title=\"4 - JavaScript注释\"></a>4 - JavaScript注释</h2><h4 id=\"4-1-单行注释\"><a href=\"#4-1-单行注释\" class=\"headerlink\" title=\"4.1  单行注释\"></a>4.1  单行注释</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">为了提高代码的可读性，JS与CSS一样，也提供了注释功能。<br>JS中的注释主要有两种，分别是 单行注释 和 多行注释。<br></code></pre></td></tr></table></figure>\n\n<p>单行注释的注释方式如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">// 我是一行文字，不想被 JS引擎 执行，所以 注释起来\t<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">// 用来注释单行文字（  快捷键   ctrl  +  /   ）<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-多行注释\"><a href=\"#4-2-多行注释\" class=\"headerlink\" title=\"4.2 多行注释\"></a>4.2 多行注释</h4><p>多行注释的注释方式如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">/*<br>  获取用户年龄和姓名<br>  并通过提示框显示出来<br>*/<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">/* */  用来注释多行文字（ 默认快捷键  alt +  shift  + a ） <br></code></pre></td></tr></table></figure>\n\n<p>快捷键修改为：   ctrl + command  +  /</p>\n<p>vscode → 首选项按钮 → 键盘快捷方式 → 查找 原来的快捷键 → 修改为新的快捷键 → 回车确认</p>\n<h2 id=\"5-JavaScript输入输出语句\"><a href=\"#5-JavaScript输入输出语句\" class=\"headerlink\" title=\"5 - JavaScript输入输出语句\"></a>5 - JavaScript输入输出语句</h2><p>为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th align=\"left\">说明</th>\n<th>归属</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>alert(msg)</td>\n<td align=\"left\">浏览器弹出警示框</td>\n<td>浏览器</td>\n</tr>\n<tr>\n<td>console.log(msg)</td>\n<td align=\"left\">浏览器控制台打印输出信息</td>\n<td>浏览器</td>\n</tr>\n<tr>\n<td>prompt(info)</td>\n<td align=\"left\">浏览器弹出输入框，用户可以输入</td>\n<td>浏览器</td>\n</tr>\n</tbody></table>\n<ul>\n<li>注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。</li>\n</ul>\n<h2 id=\"6-事件基础\"><a href=\"#6-事件基础\" class=\"headerlink\" title=\"6 - 事件基础\"></a>6 - 事件基础</h2><h4 id=\"6-1-事件概述\"><a href=\"#6-1-事件概述\" class=\"headerlink\" title=\"6.1. 事件概述\"></a>6.1. 事件概述</h4><p>​     JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。</p>\n<p>简单理解： <strong>触发— 响应机制</strong>。</p>\n<p>​    网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。</p>\n<h4 id=\"6-2-事件三要素\"><a href=\"#6-2-事件三要素\" class=\"headerlink\" title=\"6.2  事件三要素\"></a>6.2  事件三要素</h4><p>交互效果可以遵循简单三步曲来实现：</p>\n<ul>\n<li>事件源（谁）：触发事件的元素</li>\n<li>事件类型（什么事件）： 例如 click 点击事件</li>\n<li>事件处理程序（做啥）：事件触发后要执行的代码(函数形式)，事件处理函数</li>\n</ul>\n<h4 id=\"6-3-js获取标签\"><a href=\"#6-3-js获取标签\" class=\"headerlink\" title=\"6.3 js获取标签\"></a>6.3 js获取标签</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;div1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><br>  /*<br><span class=\"javascript\"> <span class=\"hljs-built_in\">document</span>:文档</span><br> get:获取<br> Element:元素<br> By:通过<br> Id:ID名<br> */<br><span class=\"javascript\"> alert(<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;div1&quot;</span>));  <span class=\"hljs-comment\">//[object HTMLDivElement]</span></span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>事件案例代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;body&gt;<br>    &lt;button id=<span class=\"hljs-string\">&quot;btn&quot;</span>&gt;唐伯虎&lt;/button&gt;<br>    &lt;script&gt;<br>        <span class=\"hljs-comment\">// 点击一个按钮，弹出对话框</span><br>        <span class=\"hljs-comment\">// 1. 事件是有三部分组成  事件源  事件类型  事件处理程序   我们也称为事件三要素</span><br>        <span class=\"hljs-comment\">//(1) 事件源 事件被触发的对象   谁  按钮</span><br>        <span class=\"hljs-keyword\">var</span> btn = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;btn&#x27;</span>);<br>        <span class=\"hljs-comment\">//(2) 事件类型  如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下</span><br>        <span class=\"hljs-comment\">//(3) 事件处理程序  通过一个函数赋值的方式 完成</span><br>        btn.onclick = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>            alert(<span class=\"hljs-string\">&#x27;点秋香&#x27;</span>);<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"6-4-执行事件的步骤\"><a href=\"#6-4-执行事件的步骤\" class=\"headerlink\" title=\"6.4. 执行事件的步骤\"></a>6.4. 执行事件的步骤</h4><p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550734387056.png\" alt=\"1550734387056\"></p>\n<p><strong>案例代码</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;body&gt;<br>    &lt;div&gt;<span class=\"hljs-number\">123</span>&lt;/div&gt;<br>    &lt;script&gt;<br>        <span class=\"hljs-comment\">// 执行事件步骤</span><br>        <span class=\"hljs-comment\">// 点击div 控制台输出 我被选中了</span><br>        <span class=\"hljs-comment\">// 1. 获取事件源</span><br>        <span class=\"hljs-keyword\">var</span> div = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;div&#x27;</span>);<br>        <span class=\"hljs-comment\">// 2.绑定事件 注册事件</span><br>        <span class=\"hljs-comment\">// div.onclick </span><br>        <span class=\"hljs-comment\">// 3.添加事件处理程序 </span><br>        div.onclick = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;我被选中了&#x27;</span>);<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"6-5-常见的鼠标事件\"><a href=\"#6-5-常见的鼠标事件\" class=\"headerlink\" title=\"6.5. 常见的鼠标事件\"></a>6.5. 常见的鼠标事件</h4><p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550734506084.png\" alt=\"1550734506084\"></p>\n<h4 id=\"6-6-分析事件三要素\"><a href=\"#6-6-分析事件三要素\" class=\"headerlink\" title=\"6.6. 分析事件三要素\"></a>6.6. 分析事件三要素</h4><ul>\n<li>下拉菜单三要素</li>\n<li>关闭广告三要素</li>\n</ul>\n<h4 id=\"6-7-添加事件\"><a href=\"#6-7-添加事件\" class=\"headerlink\" title=\"6.7  添加事件\"></a>6.7  添加事件</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;div1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><br>/*<br>onclick:单击事件<br>*/<br><span class=\"javascript\"><span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;div1&quot;</span>).onclick = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"javascript\"> <span class=\"hljs-comment\">// 存放 展示效果的代码块</span></span><br>&#125;<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"6-8-点击按钮触发事件弹出-hello-world\"><a href=\"#6-8-点击按钮触发事件弹出-hello-world\" class=\"headerlink\" title=\"6.8  点击按钮触发事件弹出 hello world\"></a>6.8  点击按钮触发事件弹出 hello world</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;but&quot;</span>&gt;</span>弹出<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><br>/*<br><span class=\"javascript\"><span class=\"hljs-number\">1.</span> 找到谁 按钮 <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;but&quot;</span>);</span><br>2. 加事件 ( 点击事件 ) 标签.onclick<br><span class=\"javascript\"><span class=\"hljs-number\">3.</span> 要做的事情 (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>)</span>&#123;&#125;)</span><br><span class=\"javascript\">语法：标签.事件 = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;要做的事情&#125;</span><br>*/<br><span class=\"javascript\"><span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;but&quot;</span>).onclick = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"javascript\">   alert(<span class=\"hljs-string\">&quot;hello world&quot;</span>);</span><br>&#125;<br> <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"7-window-onload\"><a href=\"#7-window-onload\" class=\"headerlink\" title=\"7 - window.onload\"></a>7 - window.onload</h2><p>window.onload的作用是，当文档和资源都加载完成后调用。</p>\n<p>​        当我们把script标签放在head里面去获取元素的时候，我们会发现获取到的值为null，那是因为代码是从上往下执行，当获取标签的时候，标签还没有被加载。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"javascript\"><span class=\"hljs-built_in\">window</span>.onload = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">   <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;but&quot;</span>).onclick = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"javascript\">\t alert(<span class=\"hljs-string\">&quot;hello world&quot;</span>);</span><br>  &#125;<br>&#125;<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;but&quot;</span>&gt;</span>按钮<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"8-其他事件\"><a href=\"#8-其他事件\" class=\"headerlink\" title=\"8 - 其他事件\"></a>8 - 其他事件</h2><p>​        js 的事件有很多，如鼠标事件，键盘事件，文本事件，窗口事件等等，这些后期会讲，我们这里先掌握简单的鼠标事件。</p>\n<p>鼠标事件除了点击onclick之外，还有很多其他的鼠标事件，具体如下：</p>\n<ul>\n<li>onclick ：点击事件</li>\n<li>ondblclick ：双击事件</li>\n<li>onmouseover ： 鼠标移入元素</li>\n<li>onmouseout :  鼠标离开元素</li>\n<li>onmouseenter ：鼠标移入元素</li>\n<li>onmouseleave ：鼠标离开元素</li>\n<li>onmousemove:  鼠标在元素中移动</li>\n<li>onmousedown： 鼠标按下</li>\n<li>onmouseup： 鼠标抬起</li>\n<li>oncontextmenu ：鼠标右键菜单事件</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"javascript\">    <span class=\"hljs-comment\">// 1.onclick ：点击事件</span></span><br><span class=\"javascript\">    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;box&quot;</span>).onclick = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;点击了&quot;</span>);</span><br>    &#125;<br><span class=\"javascript\">    <span class=\"hljs-comment\">// 2.onmouseover ：鼠标移入元素</span></span><br><span class=\"javascript\">    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;box&quot;</span>).onmouseover = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;鼠标移入元素&quot;</span>);</span><br>    &#125;<br><span class=\"javascript\">    <span class=\"hljs-comment\">// ......</span></span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;box&quot;</span>&gt;</span>我是box<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"9-变量的概念\"><a href=\"#9-变量的概念\" class=\"headerlink\" title=\"9 - 变量的概念\"></a>9 - 变量的概念</h2><h4 id=\"9-1-什么是变量\"><a href=\"#9-1-什么是变量\" class=\"headerlink\" title=\"9.1 什么是变量\"></a>9.1 什么是变量</h4><p>白话：变量就是一个装东西的盒子。</p>\n<p>通俗：变量是用于存放数据的容器。 我们通过 变量名 获取数据，甚至数据可以修改。<br><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/图片13.png\"></p>\n<h4 id=\"9-2-变量在内存中的存储\"><a href=\"#9-2-变量在内存中的存储\" class=\"headerlink\" title=\"9.2 变量在内存中的存储\"></a>9.2 变量在内存中的存储</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">本质：变量是程序在内存中申请的一块用来存放数据的空间。类似我们酒店的房间，一个房间就可以看做是一个变量。 <br></code></pre></td></tr></table></figure>\n\n<p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/图片14.png\" alt=\"图片14\"></p>\n<h2 id=\"10-变量的使用\"><a href=\"#10-变量的使用\" class=\"headerlink\" title=\"10 - 变量的使用\"></a>10 - 变量的使用</h2><ul>\n<li>变量的声明   </li>\n<li>变量的赋值 </li>\n</ul>\n<h4 id=\"10-1-声明变量\"><a href=\"#10-1-声明变量\" class=\"headerlink\" title=\"10.1 声明变量\"></a>10.1 声明变量</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//  声明变量  </span><br><span class=\"hljs-keyword\">var</span> age; <span class=\"hljs-comment\">//  声明一个 名称为age 的变量     </span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>var 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管</p>\n</li>\n<li><p>age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间</p>\n</li>\n</ul>\n<h4 id=\"10-2-赋值\"><a href=\"#10-2-赋值\" class=\"headerlink\" title=\"10.2 赋值\"></a>10.2 赋值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">age = <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// 给 age  这个变量赋值为 10        </span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>= 用来把右边的值赋给左边的变量空间中   此处代表赋值的意思</li>\n<li>变量值是程序员保存到变量空间里的值</li>\n</ul>\n<h4 id=\"10-3-变量的初始化\"><a href=\"#10-3-变量的初始化\" class=\"headerlink\" title=\"10.3 变量的初始化\"></a>10.3 变量的初始化</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> age  = <span class=\"hljs-number\">18</span>;  <span class=\"hljs-comment\">// 声明变量同时赋值为 18</span><br><span class=\"hljs-comment\">// 声明一个变量并赋值， 我们称之为变量的初始化。</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"10-4-变量语法扩展\"><a href=\"#10-4-变量语法扩展\" class=\"headerlink\" title=\"10.4 变量语法扩展\"></a>10.4 变量语法扩展</h4><ul>\n<li>更新变量</li>\n</ul>\n<p>​           一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> age = <span class=\"hljs-number\">18</span>;<br>age = <span class=\"hljs-number\">81</span>;   <span class=\"hljs-comment\">// 最后的结果就是81因为18 被覆盖掉了  </span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>同时声明多个变量</p>\n<p>​        同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。    </p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> age = <span class=\"hljs-number\">10</span>,  name = <span class=\"hljs-string\">&#x27;zs&#x27;</span>, sex = <span class=\"hljs-number\">2</span>;       <br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>声明变量特殊情况</p>\n<table>\n<thead>\n<tr>\n<th>情况</th>\n<th>说明</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>var  age ; console.log (age);</td>\n<td>只声明 不赋值</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>console.log(age)</td>\n<td>不声明 不赋值  直接使用</td>\n<td>报错</td>\n</tr>\n<tr>\n<td>age   = 10; console.log (age);</td>\n<td>不声明   只赋值</td>\n<td>10</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h4 id=\"10-5-变量命名规范\"><a href=\"#10-5-变量命名规范\" class=\"headerlink\" title=\"10.5 变量命名规范\"></a>10.5 变量命名规范</h4><p>规则：</p>\n<ul>\n<li>由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name</li>\n<li>严格区分大小写。var app; 和 var App; 是两个变量</li>\n<li>不能 以数字开头。  18age   是错误的</li>\n<li>不能 是关键字、保留字。例如：var、for、while</li>\n<li>变量名必须有意义。 MMD   BBD        nl   →     age  </li>\n<li>遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName![](/Users/mac/Desktop/one/第一章 JavaScript初识/笔记/图片15.png)</li>\n</ul>\n<p>推荐翻译网站： 有道    爱词霸</p>\n<h2 id=\"11-操作元素\"><a href=\"#11-操作元素\" class=\"headerlink\" title=\"11 - 操作元素\"></a>11 - 操作元素</h2><p>​    JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的）</p>\n<h4 id=\"11-1-改变元素内容（获取或设置）\"><a href=\"#11-1-改变元素内容（获取或设置）\" class=\"headerlink\" title=\"11.1. 改变元素内容（获取或设置）\"></a>11.1. 改变元素内容（获取或设置）</h4><p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550735016756.png\" alt=\"1550735016756\"></p>\n<p><strong>innerText改变元素内容</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;body&gt;<br>    &lt;button&gt;显示当前系统时间&lt;/button&gt;<br>    &lt;div&gt;某个时间&lt;/div&gt;<br>    &lt;p&gt;<span class=\"hljs-number\">1123</span>&lt;/p&gt;<br>    &lt;script&gt;<br>        <span class=\"hljs-comment\">// 当我们点击了按钮，  div里面的文字会发生变化</span><br>        <span class=\"hljs-comment\">// 1. 获取元素 </span><br>        <span class=\"hljs-keyword\">var</span> btn = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;button&#x27;</span>);<br>        <span class=\"hljs-keyword\">var</span> div = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;div&#x27;</span>);<br>        <span class=\"hljs-comment\">// 2.注册事件</span><br>        btn.onclick = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>            <span class=\"hljs-comment\">// div.innerText = &#x27;2019-6-6&#x27;;</span><br>            div.innerHTML = getDate();<br>        &#125;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getDate</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>            <span class=\"hljs-keyword\">var</span> date = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>();<br>            <span class=\"hljs-comment\">// 我们写一个 2019年 5月 1日 星期三</span><br>            <span class=\"hljs-keyword\">var</span> year = date.getFullYear();<br>            <span class=\"hljs-keyword\">var</span> month = date.getMonth() + <span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">var</span> dates = date.getDate();<br>            <span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-string\">&#x27;星期日&#x27;</span>, <span class=\"hljs-string\">&#x27;星期一&#x27;</span>, <span class=\"hljs-string\">&#x27;星期二&#x27;</span>, <span class=\"hljs-string\">&#x27;星期三&#x27;</span>, <span class=\"hljs-string\">&#x27;星期四&#x27;</span>, <span class=\"hljs-string\">&#x27;星期五&#x27;</span>, <span class=\"hljs-string\">&#x27;星期六&#x27;</span>];<br>            <span class=\"hljs-keyword\">var</span> day = date.getDay();<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;今天是：&#x27;</span> + year + <span class=\"hljs-string\">&#x27;年&#x27;</span> + month + <span class=\"hljs-string\">&#x27;月&#x27;</span> + dates + <span class=\"hljs-string\">&#x27;日 &#x27;</span> + arr[day];<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>\n\n<p><strong>innerText和innerHTML的区别</strong></p>\n<ul>\n<li>获取内容时的区别：</li>\n</ul>\n<p>​    innerText会去除空格和换行，而innerHTML会保留空格和换行    </p>\n<ul>\n<li>设置内容时的区别：</li>\n</ul>\n<p>​    innerText不会识别html，而innerHTML会识别</p>\n<p><strong>案例代码</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;body&gt;<br>    &lt;div&gt;&lt;/div&gt;<br>    &lt;p&gt;<br>        我是文字<br>        &lt;span&gt;<span class=\"hljs-number\">123</span>&lt;/span&gt;<br>    &lt;/p&gt;<br>    &lt;script&gt;<br>        <span class=\"hljs-comment\">// innerText 和 innerHTML的区别 </span><br>        <span class=\"hljs-comment\">// 1. innerText 不识别html标签 非标准  去除空格和换行</span><br>        <span class=\"hljs-keyword\">var</span> div = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;div&#x27;</span>);<br>        <span class=\"hljs-comment\">// div.innerText = &#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;;</span><br>        <span class=\"hljs-comment\">// 2. innerHTML 识别html标签 W3C标准 保留空格和换行的</span><br>        div.innerHTML = <span class=\"hljs-string\">&#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;</span>;<br>        <span class=\"hljs-comment\">// 这两个属性是可读写的  可以获取元素里面的内容</span><br>        <span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;p&#x27;</span>);<br>        <span class=\"hljs-built_in\">console</span>.log(p.innerText);<br>        <span class=\"hljs-built_in\">console</span>.log(p.innerHTML);<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"12-常用元素的属性操作\"><a href=\"#12-常用元素的属性操作\" class=\"headerlink\" title=\"12 - 常用元素的属性操作\"></a>12 - 常用元素的属性操作</h2><p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550735556297.png\" alt=\"1550735556297\"></p>\n<p><strong>获取属性的值</strong></p>\n<p>元素对象.属性名</p>\n<p><strong>设置属性的值</strong></p>\n<p>元素对象.属性名 = 值</p>\n<p><strong>案例代码</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;body&gt;<br>    &lt;button id=<span class=\"hljs-string\">&quot;ldh&quot;</span>&gt;刘德华&lt;/button&gt;<br>    &lt;button id=<span class=\"hljs-string\">&quot;zxy&quot;</span>&gt;张学友&lt;/button&gt; <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span></span><br>    &lt;img src=&quot;images/ldh.jpg&quot; alt=&quot;&quot; title=&quot;刘德华&quot;&gt;<br>    &lt;script&gt;<br>        // 修改元素属性  src<br>        // 1. 获取元素<br>        var ldh = document.getElementById(&#x27;ldh&#x27;);<br>        var zxy = document.getElementById(&#x27;zxy&#x27;);<br>        var img = document.querySelector(&#x27;img&#x27;);<br>        // 2. 注册事件  处理程序<br>        zxy.onclick = function() &#123;<br>            img.src = &#x27;images/zxy.jpg&#x27;;<br>            img.title = &#x27;张学友思密达&#x27;;<br>        &#125;<br>        ldh.onclick = function() &#123;<br>            img.src = &#x27;images/ldh.jpg&#x27;;<br>            img.title = &#x27;刘德华&#x27;;<br>        &#125;<br>    &lt;/script&gt;<br><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"12-1-案例：分时问候\"><a href=\"#12-1-案例：分时问候\" class=\"headerlink\" title=\"12.1. 案例：分时问候\"></a>12.1. 案例：分时问候</h4><p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550735858049.png\" alt=\"1550735858049\"></p>\n<p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550735877145.png\" alt=\"1550735877145\"></p>\n<h2 id=\"13-表单元素的属性操作\"><a href=\"#13-表单元素的属性操作\" class=\"headerlink\" title=\"13 - 表单元素的属性操作\"></a>13 - 表单元素的属性操作</h2><p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736039005.png\" alt=\"1550736039005\"></p>\n<p><strong>获取属性的值</strong></p>\n<p>元素对象.属性名</p>\n<p><strong>设置属性的值</strong></p>\n<p>元素对象.属性名 = 值</p>\n<p>表单元素中有一些属性如：disabled、checked、selected，元素对象的这些属性的值是布尔型。</p>\n<p><strong>案例代码</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;body&gt;<br>    &lt;button&gt;按钮&lt;/button&gt;<br>    &lt;input type=<span class=\"hljs-string\">&quot;text&quot;</span> value=<span class=\"hljs-string\">&quot;输入内容&quot;</span>&gt;<br>    &lt;script&gt;<br>        <span class=\"hljs-comment\">// 1. 获取元素</span><br>        <span class=\"hljs-keyword\">var</span> btn = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;button&#x27;</span>);<br>        <span class=\"hljs-keyword\">var</span> input = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;input&#x27;</span>);<br>        <span class=\"hljs-comment\">// 2. 注册事件 处理程序</span><br>        btn.onclick = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>            <span class=\"hljs-comment\">// 表单里面的值 文字内容是通过 value 来修改的</span><br>            input.value = <span class=\"hljs-string\">&#x27;被点击了&#x27;</span>;<br>            <span class=\"hljs-comment\">// 如果想要某个表单被禁用 不能再点击 disabled  我们想要这个按钮 button禁用</span><br>            <span class=\"hljs-comment\">// btn.disabled = true;</span><br>            <span class=\"hljs-built_in\">this</span>.disabled = <span class=\"hljs-literal\">true</span>;<br>            <span class=\"hljs-comment\">// this 指向的是事件函数的调用者 btn</span><br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"13-1-仿京东显示密码\"><a href=\"#13-1-仿京东显示密码\" class=\"headerlink\" title=\"13.1. 仿京东显示密码\"></a>13.1. 仿京东显示密码</h4><p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736330331.png\" alt=\"1550736330331\"></p>\n<p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736346822.png\" alt=\"1550736346822\"></p>\n<h2 id=\"14-点操作符和中括号操作符使用\"><a href=\"#14-点操作符和中括号操作符使用\" class=\"headerlink\" title=\"14 - 点操作符和中括号操作符使用\"></a>14 - 点操作符和中括号操作符使用</h2><ul>\n<li>是某一个具体的属性值是，用点操作符。</li>\n<li>当是某一个变量时，用中括号操作符，中括号里面放这个变量。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;div id=<span class=\"hljs-string\">&quot;box&quot;</span> title=<span class=\"hljs-string\">&quot;优就业&quot;</span>&gt;中公教育&lt;/div&gt;<br>&lt;script&gt;<br><span class=\"hljs-keyword\">var</span> oDiv = <span class=\"hljs-built_in\">document</span>.getElementById(box<span class=\"hljs-string\">&quot;);</span><br><span class=\"hljs-string\">// 1.获取title属性值</span><br><span class=\"hljs-string\">var t= oDiv[&quot;</span>title<span class=\"hljs-string\">&quot;];</span><br><span class=\"hljs-string\">console.log(t);</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">// 2.设置title属性</span><br><span class=\"hljs-string\">oDiv[&quot;</span>title<span class=\"hljs-string\">&quot;] = &quot;</span>web全栈<span class=\"hljs-string\">&quot;;</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">// 3.中括号操作符的正确使用场景</span><br><span class=\"hljs-string\">var tit = ‘title’;</span><br><span class=\"hljs-string\">console.log(oDiv[tit]); // 当是变量时，就只能使用中括号操作符，不能使用点操作符</span><br><span class=\"hljs-string\">&lt;/script&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h6 id=\"注意：当把属性名赋值给一个变量的时候，就可以通过使用中括号-来操作变量，就可以操作这个属性\"><a href=\"#注意：当把属性名赋值给一个变量的时候，就可以通过使用中括号-来操作变量，就可以操作这个属性\" class=\"headerlink\" title=\"注意：当把属性名赋值给一个变量的时候，就可以通过使用中括号  []来操作变量，就可以操作这个属性\"></a>注意：当把属性名赋值给一个变量的时候，就可以通过使用中括号  <code>[]</code>来操作变量，就可以操作这个属性</h6><h2 id=\"15-样式属性操作\"><a href=\"#15-样式属性操作\" class=\"headerlink\" title=\"15 - 样式属性操作\"></a>15 - 样式属性操作</h2><p>元素样式是写在 style 标签或 style 属性中，用来设置元素的外观的。</p>\n<p>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</p>\n<p>js操作的样式全部属于行内样式</p>\n<p><strong>常用方式</strong></p>\n<p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736488634.png\" alt=\"1550736488634\"></p>\n<h4 id=\"方式1：通过操作style属性\"><a href=\"#方式1：通过操作style属性\" class=\"headerlink\" title=\"方式1：通过操作style属性\"></a>方式1：通过操作style属性</h4><p>语法：</p>\n<ul>\n<li>获取元素样式属性：元素.style.样式</li>\n<li>设置元素样式属性：元素.style.样式名 = “样式值”</li>\n</ul>\n<p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736620181.png\" alt=\"1550736620181\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;body&gt;<br>    &lt;div&gt;&lt;/div&gt;<br>    &lt;script&gt;<br>        <span class=\"hljs-comment\">// 1. 获取元素</span><br>        <span class=\"hljs-keyword\">var</span> div = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;div&#x27;</span>);<br>        <span class=\"hljs-comment\">// 2. 注册事件 处理程序</span><br>        div.onclick = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>            <span class=\"hljs-comment\">// div.style里面的属性 采取驼峰命名法 </span><br>            div.style.backgroundColor = <span class=\"hljs-string\">&#x27;purple&#x27;</span>;<br>            div.style.width = <span class=\"hljs-string\">&#x27;250px&#x27;</span>;<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"案例：淘宝点击关闭二维码\"><a href=\"#案例：淘宝点击关闭二维码\" class=\"headerlink\" title=\"案例：淘宝点击关闭二维码\"></a>案例：淘宝点击关闭二维码</h4><p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736843659.png\" alt=\"1550736843659\"></p>\n<p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736881832.png\" alt=\"1550736881832\"></p>\n<h4 id=\"案例：循环精灵图背景\"><a href=\"#案例：循环精灵图背景\" class=\"headerlink\" title=\"案例：循环精灵图背景\"></a>案例：循环精灵图背景</h4><p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736940082.png\" alt=\"1550736940082\"></p>\n<p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550736956754.png\" alt=\"1550736956754\"></p>\n<h4 id=\"案例：显示隐藏文本框内容\"><a href=\"#案例：显示隐藏文本框内容\" class=\"headerlink\" title=\"案例：显示隐藏文本框内容\"></a>案例：显示隐藏文本框内容</h4><p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550737006593.png\" alt=\"1550737006593\"></p>\n<p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550737019729.png\" alt=\"1550737019729\"></p>\n<h4 id=\"方式2：通过操作className属性\"><a href=\"#方式2：通过操作className属性\" class=\"headerlink\" title=\"方式2：通过操作className属性\"></a>方式2：通过操作className属性</h4><p>元素对象.className = 值;</p>\n<p>因为class是关键字，所有使用className。</p>\n<p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550737214510.png\" alt=\"1550737214510\"></p>\n<p><strong>案例代码</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;body&gt;<br>    &lt;div <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">&quot;first&quot;</span>&gt;文本&lt;/div&gt;<br>    &lt;script&gt;<br>        <span class=\"hljs-comment\">// 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用</span><br>        <span class=\"hljs-keyword\">var</span> test = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;div&#x27;</span>);<br>        test.onclick = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>            <span class=\"hljs-comment\">// this.style.backgroundColor = &#x27;purple&#x27;;</span><br>            <span class=\"hljs-comment\">// this.style.color = &#x27;#fff&#x27;;</span><br>            <span class=\"hljs-comment\">// this.style.fontSize = &#x27;25px&#x27;;</span><br>            <span class=\"hljs-comment\">// this.style.marginTop = &#x27;100px&#x27;;</span><br><br>            <span class=\"hljs-comment\">// 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况</span><br>            <span class=\"hljs-comment\">// 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器</span><br>            <span class=\"hljs-comment\">// this.className = &#x27;change&#x27;;</span><br>            <span class=\"hljs-built_in\">this</span>.className = <span class=\"hljs-string\">&#x27;first change&#x27;</span>;<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"案例：密码框格式提示错误信息\"><a href=\"#案例：密码框格式提示错误信息\" class=\"headerlink\" title=\"案例：密码框格式提示错误信息\"></a>案例：密码框格式提示错误信息</h4><p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550737269546.png\" alt=\"1550737269546\"></p>\n<p><img src=\"C:/Users/梁超/Desktop/二阶笔记/笔记/笔记/笔记1/images/1550737284218.png\" alt=\"1550737284218\"></p>\n<h2 id=\"16-cssText\"><a href=\"#16-cssText\" class=\"headerlink\" title=\"16 - cssText\"></a>16 - cssText</h2><h4 id=\"16-1-cssText-本质是什么？\"><a href=\"#16-1-cssText-本质是什么？\" class=\"headerlink\" title=\"16.1 cssText 本质是什么？\"></a>16.1 cssText 本质是什么？</h4><p>cssText 的本质就是设置 HTML 元素的 style 属性值。</p>\n<h4 id=\"16-2-cssText-怎么用？\"><a href=\"#16-2-cssText-怎么用？\" class=\"headerlink\" title=\"16.2 cssText 怎么用？\"></a>16.2 <strong>cssText 怎么用？</strong></h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;d1&quot;</span>).style.cssText = <span class=\"hljs-string\">&quot;color:red; font-size:13px;&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"16-3-cssText-返回值是什么？\"><a href=\"#16-3-cssText-返回值是什么？\" class=\"headerlink\" title=\"16.3 cssText 返回值是什么？\"></a>16.3 <strong>cssText 返回值是什么？</strong></h4><p>在某些浏览器中（比如 Chrome），你给他赋什么值，它就返回什么值。在 IE 中则比较痛苦，它会格式化输出、会把属性大写、会改变属性顺序、会去掉最后一个分号，比如：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;d1&quot;</span>).style.cssText = <span class=\"hljs-string\">&quot;color:red; font-size:13px;&quot;</span>;<br>alert(<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;d1&quot;</span>).style.cssText);<br></code></pre></td></tr></table></figure>\n\n<p>在 IE 中值为：FONT-SIZE: 13px; COLOR: red</p>\n<h4 id=\"16-4-cssText的使用优势\"><a href=\"#16-4-cssText的使用优势\" class=\"headerlink\" title=\"16.4 cssText的使用优势\"></a>16.4 <strong>cssText的使用优势</strong></h4><p>一般情况下我们用js设置元素对象的样式会使用这样的形式：</p>\n<p><code>var element= document.getElementById(“id”); element.style.width=”20px”; element.style.height=”20px”; element.style.border=”solid 1px red”;</code></p>\n<p>样式一多，代码就很多；而且通过JS来覆写对象的样式是比较典型的一种销毁原样式并重建的过程，这种销毁和重建，都会增加浏览器的开销。</p>\n<h4 id=\"16-5-cssText问题\"><a href=\"#16-5-cssText问题\" class=\"headerlink\" title=\"16.5 cssText问题\"></a>16.5 cssText问题</h4><p>语法为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">obj.style.cssText=”样式”;<br><br>element.style.cssText=”width:<span class=\"hljs-number\">20</span>px;height:<span class=\"hljs-number\">20</span>px;border:solid <span class=\"hljs-number\">1</span>px red;”;<br></code></pre></td></tr></table></figure>\n\n<p>这样就可以尽量避免页面reflow，提高页面性能。</p>\n<p>但是，这样会有一个问题，会把原有的cssText清掉，比如原来的style中有’display:none;’，那么执行完上面的JS后，display就被删掉了。</p>\n<h4 id=\"16-6-cssText累加的方法\"><a href=\"#16-6-cssText累加的方法\" class=\"headerlink\" title=\"16.6 cssText累加的方法\"></a>16.6 cssText累加的方法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">Element.style.cssText += ‘width:<span class=\"hljs-number\">100</span>px;height:<span class=\"hljs-number\">100</span>px;top:<span class=\"hljs-number\">100</span>px;left:<span class=\"hljs-number\">100</span>px;’<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"16-7-IE中解决兼容问题\"><a href=\"#16-7-IE中解决兼容问题\" class=\"headerlink\" title=\"16.7 IE中解决兼容问题\"></a>16.7 IE中解决兼容问题</h4><p>上面cssText累加的方法在IE中是无效的。</p>\n<p>可以在前面添加一个分号来解决这个问题</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">Element.style.cssText += ‘;width:<span class=\"hljs-number\">100</span>px;height:<span class=\"hljs-number\">100</span>px;top:<span class=\"hljs-number\">100</span>px;left:<span class=\"hljs-number\">100</span>px;’<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"16-8-内嵌样式不会被覆盖掉\"><a href=\"#16-8-内嵌样式不会被覆盖掉\" class=\"headerlink\" title=\"16.8 内嵌样式不会被覆盖掉\"></a>16.8 内嵌样式不会被覆盖掉</h4><p>如果前面有样式表文件写着 div { text-decoration:underline; }，这个会被覆盖吗？</p>\n<p>不会！因为它不是直接作用于 HTML 元素的 style 属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;style&gt;<br>#outer&#123;width:500px;margin:0 auto;padding:0;text-align:center;&#125;<br>#div1&#123;width:100px;height:100px;background:black;margin:10px auto;display:block;&#125;<br>&lt;/style&gt;<br>&lt;script&gt;<br><span class=\"hljs-keyword\">var</span> changeStyle = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">elem, attr, value</span>)</span><br><span class=\"hljs-function\"></span>&#123;<br>    elem.style[attr] = value<br>&#125;;<br><span class=\"hljs-built_in\">window</span>.onload = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>)</span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">var</span> oBtn = <span class=\"hljs-built_in\">document</span>.getElementsByTagName(<span class=\"hljs-string\">&quot;input&quot;</span>);<br>    <span class=\"hljs-keyword\">var</span> oDiv = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;div1&quot;</span>);<br>    <span class=\"hljs-keyword\">var</span> oAtt = [<span class=\"hljs-string\">&quot;width&quot;</span>,<span class=\"hljs-string\">&quot;height&quot;</span>,<span class=\"hljs-string\">&quot;background&quot;</span>,<span class=\"hljs-string\">&quot;display&quot;</span>,<span class=\"hljs-string\">&quot;display&quot;</span>];<br>    <span class=\"hljs-keyword\">var</span> oVal = [<span class=\"hljs-string\">&quot;200px&quot;</span>,<span class=\"hljs-string\">&quot;200px&quot;</span>,<span class=\"hljs-string\">&quot;red&quot;</span>,<span class=\"hljs-string\">&quot;none&quot;</span>,<span class=\"hljs-string\">&quot;block&quot;</span>];<br> <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; oBtn.length; i++)<br>    &#123;<br>        oBtn[i].index = i;<br>        oBtn[i].onclick = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>)</span><br><span class=\"hljs-function\">        </span>&#123;<br>            <span class=\"hljs-built_in\">this</span>.index == oBtn.length - <span class=\"hljs-number\">1</span> &amp;&amp; (oDiv.style.cssText = <span class=\"hljs-string\">&quot;&quot;</span>);<br>            changeStyle(oDiv, oAtt[<span class=\"hljs-built_in\">this</span>.index], oVal[<span class=\"hljs-built_in\">this</span>.index])<br>        &#125;  <br>    &#125;<br>&#125;;<br>&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div id=<span class=\"hljs-string\">&quot;outer&quot;</span>&gt;<br>&lt;input type=<span class=\"hljs-string\">&quot;button&quot;</span> value=<span class=\"hljs-string\">&quot;变宽&quot;</span> /&gt;<br>&lt;input type=<span class=\"hljs-string\">&quot;button&quot;</span> value=<span class=\"hljs-string\">&quot;变高&quot;</span> /&gt;<br>&lt;input type=<span class=\"hljs-string\">&quot;button&quot;</span> value=<span class=\"hljs-string\">&quot;变色&quot;</span> /&gt;<br>&lt;input type=<span class=\"hljs-string\">&quot;button&quot;</span> value=<span class=\"hljs-string\">&quot;隐藏&quot;</span> /&gt;<br>&lt;input type=<span class=\"hljs-string\">&quot;button&quot;</span> value=<span class=\"hljs-string\">&quot;重置&quot;</span> /&gt;<br>&lt;div id=<span class=\"hljs-string\">&quot;div1&quot;</span>&gt;&lt;/div&gt;<br>&lt;/div&gt;　　<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>\n\n","raw":null,"categories":[],"tags":[{"name":"javascript-1","path":"api/tags/javascript-1.json"}]},{"title":"vue2","slug":"vue","date":"2020-09-18T11:29:18.000Z","updated":"2021-06-02T03:15:13.965Z","comments":true,"top":null,"path":"api/articles/vue.json","excerpt":null,"keywords":null,"cover":null,"content":"<h4 id=\"vue-介绍\"><a href=\"#vue-介绍\" class=\"headerlink\" title=\"vue 介绍\"></a>vue 介绍</h4><ul>\n<li>渐进式javascript框架</li>\n</ul>\n<p>渐进式：主张最少</p>\n<p>模块：数据请求：axios  UI：elementUI  路由：vue-router状态层：vuex。。</p>\n<ul>\n<li>优点</li>\n</ul>\n<p>模块化友好  易用 灵活 高效 SPA  用户体验好</p>\n<p>SPA ：sing page  application 单页面应用</p>\n<p>1个url ——&gt;1个html文件，多个html文件  多页面的应用：优点：利于SEO优化，缺点：白屏，用户体验不好</p>\n<p>1个url ——&gt;1个html文件，多个html文件 单页面的应用：优点：用户体验好  缺点：首屏加载慢，不利于SEO的优化</p>\n<p>VUE缺点：</p>\n<ul>\n<li>兼容性不好，首屏加载慢。不利于SEO优化</li>\n</ul>\n<p>4.核心</p>\n<p>数据驱动  组件系统</p>\n<p>js 绑定事件 样式操作  event阻止默认事件 阻止冒泡事件。。</p>\n<p>jq  获取节点  取值 赋值  样式  绑定事件   event阻止默认事件  阻止冒泡事件  ajax..</p>\n<p>vue  获取节点  赋值  取值  绑定事件  event 阻止默认事件  阻止冒泡事件  ajax 自己的内容。。</p>\n<h5 id=\"节点赋值\"><a href=\"#节点赋值\" class=\"headerlink\" title=\"节点赋值\"></a>节点赋值</h5><ul>\n<li><p>非表单元素：div  span等..  js：innerHTML     jq：html（）</p>\n</li>\n<li><p>表单元素： input textarea   select-option..  js:value  jq:val()</p>\n</li>\n<li><p>媒体元素：img  video。  js：src    jq：img.attr(src,1.jpg)</p>\n</li>\n</ul>\n<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1.安装\"></a>1.安装</h2><p>官网：<a href=\"https://cn.vuejs.org/\">https://cn.vuejs.org/</a></p>\n<p>兼容性：vue不支持ie8及以下的版本</p>\n<p>安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">1.cdn<br><br>&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br><br>2.npm <br>npm install vue<br><br>3.vue脚手架 vue-cli ：工作中使用的方式  5天<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>    <span class=\"hljs-comment\">&lt;!-- 1.安装 npm i vue  --&gt;</span><br>    <span class=\"hljs-comment\">&lt;!-- 2.引入 --&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-comment\">&lt;!-- 3.控制范围 --&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>        &#123;&#123;1+1&#125;&#125;<br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"javascript\">        <span class=\"hljs-comment\">// 4.实例化vue对象</span></span><br><span class=\"javascript\">        <span class=\"hljs-keyword\">new</span> Vue(&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//element</span></span><br><span class=\"javascript\">            el:<span class=\"hljs-string\">&quot;div&quot;</span></span><br>        &#125;)<br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h5 id=\"el挂载点\"><a href=\"#el挂载点\" class=\"headerlink\" title=\"el挂载点\"></a>el挂载点</h5><ol>\n<li>不能挂载到body  html ，要 挂载到正常的元素上</li>\n<li>一个vue实列只能挂载到一个节点上，所以一般情况使用id选择器</li>\n<li>如果有多个元素都满足el的选择，vue实列挂载到满足条件的第一个节点上</li>\n</ol>\n<h5 id=\"data：先声明-后使用\"><a href=\"#data：先声明-后使用\" class=\"headerlink\" title=\"data：先声明 后使用\"></a>data：先声明 后使用</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">new Vue(&#123;<br>\tel:&quot;#app&quot;,//挂载点<br>\tdata:&#123;\t//属性-变量<br>\t\t\tx:10,<br>     arr:[]<br>\t&#125;,<br>\tmethods:&#123;//方法-函数<br>\t\t fn:function()&#123;&#125;,<br>     changeArr:function()&#123;&#125;<br>\t&#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据绑定-指令\"><a href=\"#数据绑定-指令\" class=\"headerlink\" title=\"数据绑定 指令\"></a>数据绑定 指令</h2><h5 id=\"1-非表单元素：div-span-…\"><a href=\"#1-非表单元素：div-span-…\" class=\"headerlink\" title=\"1.非表单元素：div  span …\"></a>1.非表单元素：div  span …</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#123;&#123;&#125;&#125; 模板语法  优点：简单 方便   缺点：不能解析标签，首屏会出现闪屏问题<br>v-html       优点：可以解析标签  缺点：不方便<br>v-text       优点：可以解决首闪屏问题  缺点：不方便，不能解析标签<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"2-表单元素：input-textarea\"><a href=\"#2-表单元素：input-textarea\" class=\"headerlink\" title=\"2.表单元素：input  textarea\"></a>2.表单元素：input  textarea</h5><p>v-model</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;name&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h5 id=\"3-属性绑定：媒体元素：img-video\"><a href=\"#3-属性绑定：媒体元素：img-video\" class=\"headerlink\" title=\"3.属性绑定：媒体元素：img  video\"></a>3.属性绑定：媒体元素：img  video</h5><p>v-bind简写  ：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-bind:href</span>=<span class=\"hljs-string\">&quot;company.url&quot;</span> <span class=\"hljs-attr\">v-bind:title</span>=<span class=\"hljs-string\">&quot;company.name&quot;</span>&gt;</span><br>   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">v-bind:src</span>=<span class=\"hljs-string\">&quot;company.logo&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><br><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">:href</span>=<span class=\"hljs-string\">&quot;company.url&quot;</span> <span class=\"hljs-attr\">:title</span>=<span class=\"hljs-string\">&quot;company.name&quot;</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">&quot;10&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">:src</span>=<span class=\"hljs-string\">&quot;company.logo&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h5 id=\"4-条件渲染\"><a href=\"#4-条件渲染\" class=\"headerlink\" title=\"4.条件渲染\"></a>4.条件渲染</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">相同点：<br>v-if 和v-show 都是true显示，false 消失<br><br><br>不同点：<br>\tv-if false 不加载节点-惰性加载<br>\tV-show false 加了display:none；<br>\t<br>使用：<br>\t频繁切换，建议使用v-show,不频繁切换，建议使用v-if.<br></code></pre></td></tr></table></figure>\n\n<p>v-else 必须和它一对的v-if挨着</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;comment.length==0&quot;</span>&gt;</span>暂无数据<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>有数据<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h5 id=\"5-列表渲染\"><a href=\"#5-列表渲染\" class=\"headerlink\" title=\"5.列表渲染\"></a>5.列表渲染</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">&quot;(item,index) in arr&quot;</span>&gt;</span><br>  <br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"1-for-key\"><a href=\"#1-for-key\" class=\"headerlink\" title=\"1.for key\"></a>1.for key</h4><p>vue 的for更新的时候采用的是“就地更新”的原则，如果更新的时候想要提高更新的性能，我们就需要给vue一个标识，作为对比条件，这个标识必须是唯一的。所以一般用id</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span><br>           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">&quot;(a,b) in people&quot;</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">&quot;a.id&quot;</span>&gt;</span><br>               <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>&#123;&#123;b&#125;&#125;姓名：&#123;&#123;a.name&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span><br>               <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>金额：<br>                   <br>                &#123;&#123;a.money&#125;&#125; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">&quot;add(b)&quot;</span>&gt;</span>++<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span> <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>           <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>           <br>       <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h5 id=\"2-样式\"><a href=\"#2-样式\" class=\"headerlink\" title=\"2.样式\"></a>2.样式</h5><ul>\n<li><h4 id=\"动态行间样式\"><a href=\"#动态行间样式\" class=\"headerlink\" title=\"动态行间样式\"></a>动态行间样式</h4></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">&quot;json&quot;</span>&gt;</span><br>    <br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><h5 id=\"动态的类名\"><a href=\"#动态的类名\" class=\"headerlink\" title=\"动态的类名\"></a>动态的类名</h5></li>\n</ul>\n<p>1.:class=”变量”</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 1. v-bind:class=&quot;变量&quot;  --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;box&quot;</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">&quot;selectName&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>2.:class=”[三元]”</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 2.v-bind:class=&quot;[三元]&quot; --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;box&quot;</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">&quot;[isRed?&#x27;red&#x27;:&#x27;blue&#x27;]&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>3.:class=”{class1:true,class2:false,…}</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"> <span class=\"hljs-comment\">&lt;!-- 3. :class=&quot;&#123;class1:true,class2:false,...&#125;--&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">&quot;&#123;&#x27;red&#x27;:true,&#x27;blue&#x27;:true,&#x27;black&#x27;:true&#125;&quot;</span>&gt;</span>商道酬信<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-表单\"><a href=\"#4-表单\" class=\"headerlink\" title=\"4.表单\"></a>4.表单</h4><ul>\n<li>1  定义变量为一个json，key和后端要求的字段保持一致；</li>\n<li>2   所有表单元素通过v-model绑定数据</li>\n<li>3   单选框  准备value：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>性别：<br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;radio&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;sex&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;user.sex&quot;</span>&gt;</span> 男<br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;radio&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;sex&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;1&quot;</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;user.sex&quot;</span>&gt;</span> 女<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>4  下拉菜单  option-value</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>           专业：<br>           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;user.job&quot;</span>&gt;</span><br>               <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;web&quot;</span>&gt;</span>web工程师<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>               <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;php&quot;</span>&gt;</span>php工程师<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>               <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;java&quot;</span>&gt;</span>java工程师<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>           <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span><br>       <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>           社团：<br>           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">multiple</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;user.org&quot;</span>&gt;</span><br>               <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">:value</span>=<span class=\"hljs-string\">&quot;1&quot;</span>&gt;</span>篮球<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>               <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">:value</span>=<span class=\"hljs-string\">&quot;2&quot;</span>&gt;</span>足球<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>               <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">:value</span>=<span class=\"hljs-string\">&quot;3&quot;</span>&gt;</span>排球<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>           <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span><br>       <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> <br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>5  多选框：对于多选框来说，如果初始值是数组，那么结果就是数组；如果初始值不是数组，那么结果就是boolean</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>爱好：<br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;user.hobbies&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;sing&quot;</span>&gt;</span>唱歌<br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;user.hobbies&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;dancing&quot;</span>&gt;</span>跳舞<br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;user.hobbies&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;codding&quot;</span>&gt;</span>写代码<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;user.isAgree&quot;</span>&gt;</span>我同意<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>6  表单修饰符</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- .lazy 失去光标才修改模型数据，优化 --&gt;</span><br>      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">v-model.lazy</span>=<span class=\"hljs-string\">&quot;name&quot;</span>&gt;</span><br><br>      <span class=\"hljs-comment\">&lt;!-- .number 将绑定的数据 的数据类型转换为number --&gt;</span><br>      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">&quot;age&quot;</span> <span class=\"hljs-attr\">v-on:blur</span>=<span class=\"hljs-string\">&quot;blur()&quot;</span>&gt;</span><br><br>      <span class=\"hljs-comment\">&lt;!-- .trim 去空格 --&gt;</span><br>      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">v-model.trim</span>=<span class=\"hljs-string\">&quot;name&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"5-事件绑定\"><a href=\"#5-事件绑定\" class=\"headerlink\" title=\"5.事件绑定\"></a>5.事件绑定</h4><h2 id=\"5-事件绑定-1\"><a href=\"#5-事件绑定-1\" class=\"headerlink\" title=\"5.事件绑定\"></a>5.事件绑定</h2><ul>\n<li><p>1.如何绑定事件？</p>\n</li>\n<li><p>2.传参</p>\n</li>\n<li><p>3.event</p>\n</li>\n<li><p>4.阻止默认事件 阻止事件传播</p>\n</li>\n<li><p>5.本框架自带哪些事件特征</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">.prevent 阻止默认事件<br>.stop 阻止事件传播<br>.self 触发的目标元素是自身，才执行<br>.left .right .up .down .enter .13 <br>.capture  捕获<br>.native native 解决组件绑定不上事件<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"1-生命周期\"><a href=\"#1-生命周期\" class=\"headerlink\" title=\"1.生命周期\"></a>1.生命周期</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">beforeCreate  创建之前：什么都是undefined<br>created 创建完成：vue实列数据初始化完成，el还是undefined<br>&#x2F;&#x2F;如果有挂载点：了&#x2F;&#x2F;如果有挂载点：el $mount()<br>beforeMount 挂载之前 ：找到了要挂载的节点，但是&#123;&#123;&#125;&#125;、指令等等还没有被解析<br>mounted 挂载完成 *****<br>\t页面初始化完成。开启计时器、轮播图、ajax、操作DOM 节点、给window | docuemnt添加事件、<br><br>beforeUpdate 页面更新之前：不是数据变化之前，而是数据已经变了，页面重新渲染之前<br>updated 页面更新完成 <br><br>&#x2F;&#x2F; vm.$dstrory()<br>beforeDestroy 销毁之前：善后工作 ***<br>\t 清除计时器、轮播图、window|document置空<br>destroyed 销毁完成<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<p>![1](D:\\梁超\\梁超 第四阶段\\day03\\老师代码\\笔记/1.png)</p>\n<h2 id=\"2-watch\"><a href=\"#2-watch\" class=\"headerlink\" title=\"2.watch\"></a>2.watch</h2><p>目的：监听属性的改变</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;<br>\twatch:&#123;<br>\t\tkw(newV,oldV)&#123;<br>\t\t\t<span class=\"hljs-comment\">//逻辑</span><br>\t\t&#125;，<br>        <span class=\"hljs-comment\">//深度监听不建议使用，因为会造成页面卡顿，如果要使用的话，建议转换成简单类型使用</span><br>        json:&#123;<br>        \thandler()&#123;<br>    \t\t\t<span class=\"hljs-comment\">//逻辑</span><br>\t\t\t&#125;，<br>        \tdeep:<span class=\"hljs-literal\">true</span><br>    \t&#125;<br>\t&#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"jsonp\"><a href=\"#jsonp\" class=\"headerlink\" title=\"jsonp\"></a>jsonp</h5><p>ajax  不能跨域  get   post</p>\n<p>jsonp 可以跨域get</p>\n<p>使用jsonp条件：1.跨域  2.有一个参数需要是回调函数，大部分情况下叫cb  |   callback</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-number\">1.</span>创建一个script标签<br>\t<span class=\"hljs-keyword\">var</span> os=<span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">&quot;script&quot;</span>)<br><span class=\"hljs-number\">2.</span>给他src<br>\tos.src=<span class=\"hljs-string\">&quot;url&quot;</span><br><span class=\"hljs-number\">3.</span>插入到页面<br>\t<span class=\"hljs-built_in\">document</span>.body.appendChild(os)<br><span class=\"hljs-number\">4.</span>回调函数中处理数据<br>\t<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"3-filter\"><a href=\"#3-filter\" class=\"headerlink\" title=\"3.filter\"></a>3.filter</h2><p>目的：转换数据</p>\n<p>使用：|  管道符</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>    &#123;&#123;price | filterPrice&#125;&#125;<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>定义：推荐全局定义</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//全局定义</span><br>Vue.filter(<span class=\"hljs-string\">&quot;过滤器名称&quot;</span>,<span class=\"hljs-function\">(<span class=\"hljs-params\">过滤对象</span>)=&gt;</span>&#123;<br>    <span class=\"hljs-comment\">//逻辑 </span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;你要的结果&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//局部定义</span><br><span class=\"hljs-keyword\">new</span> Vue(&#123;<br>    filters:&#123;<br>        <span class=\"hljs-comment\">//全局定义</span><br>\t\t过滤器名称(过滤对象)&#123;<br>            <span class=\"hljs-comment\">//逻辑 </span><br>    \t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;你要的结果&quot;</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"4-computed计算属性\"><a href=\"#4-computed计算属性\" class=\"headerlink\" title=\"4.computed计算属性\"></a>4.computed计算属性</h2><p>计算属性：经过计算得到的属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;<br>\tcomputed:&#123;<span class=\"hljs-comment\">//计算属性</span><br>        a()&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">10</span><br>        &#125;,<br>        ava()&#123;<br>            <span class=\"hljs-keyword\">var</span> sum=<span class=\"hljs-number\">0</span><br>            <span class=\"hljs-built_in\">this</span>.students.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span>=&gt;</span>&#123;<br>                sum+=item.score<br>            &#125;)<br>            <span class=\"hljs-keyword\">return</span> (sum/<span class=\"hljs-built_in\">this</span>.students.length).toFixed(<span class=\"hljs-number\">2</span>);<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5-vue常见的bug有哪些？怎么解决？\"><a href=\"#5-vue常见的bug有哪些？怎么解决？\" class=\"headerlink\" title=\"5.vue常见的bug有哪些？怎么解决？\"></a>5.vue常见的bug有哪些？怎么解决？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">1.&#123;&#123;&#125;&#125;闪屏问题。 v-text解决<br>2.组件绑定事件绑定不上。 .native解决<br>3.watch深度监听卡顿。 换成简单类型，浅监听。<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"1-计算属性补充\"><a href=\"#1-计算属性补充\" class=\"headerlink\" title=\"1.计算属性补充\"></a>1.计算属性补充</h2><p>1.v-for和v-if同时作用在一个标签上的时候，不合法。需要所使用的的计算属性解决。</p>\n<p>2.如果出现数组变了，页面不渲染问题，采用下面3种方式结解决：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//1.this.goods.splice(&#x27;下标&#x27;,1,&#x27;新值&#x27;)</span><br><span class=\"hljs-built_in\">this</span>.goods.splice(index,<span class=\"hljs-number\">1</span>,obj)<br><br><span class=\"hljs-comment\">//2.vm.$set(数组，下标，新值)</span><br><span class=\"hljs-built_in\">this</span>.$set(<span class=\"hljs-built_in\">this</span>.goods,inds,obj)<br><br><span class=\"hljs-comment\">//3.vue.set(数组，下标，新值)</span><br>vue.set(<span class=\"hljs-built_in\">this</span>.goods,indes,obj)<br></code></pre></td></tr></table></figure>\n\n<p>3.如果是json发生了改变，页面不渲染</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//vm.set(obj,key,value)</span><br><span class=\"hljs-built_in\">this</span>.$set(<span class=\"hljs-built_in\">this</span>.json,<span class=\"hljs-string\">&#x27;y&#x27;</span>,<span class=\"hljs-number\">30</span>)<br>vue.set(<span class=\"hljs-built_in\">this</span>.json,<span class=\"hljs-string\">&#x27;y&#x27;</span>,<span class=\"hljs-number\">40</span>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-动画\"><a href=\"#2-动画\" class=\"headerlink\" title=\"2.动画\"></a>2.动画</h2><h4 id=\"使用场景：\"><a href=\"#使用场景：\" class=\"headerlink\" title=\"使用场景：\"></a>使用场景：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">v-if<br>v-show<br>动态组件<br>路由<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"状态：\"><a href=\"#状态：\" class=\"headerlink\" title=\"状态：\"></a>状态：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">进来之前 enter<br>进来过程 enter-active<br>进来完成 enter-to<br>离开之前 leave<br>离开过程 leave-active<br>离开完成 leave-to<br></code></pre></td></tr></table></figure>\n\n<p>animate.css</p>\n<p>1.官网：<a href=\"https://animate.style/\">https://animate.style/</a></p>\n<p>2.安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">npm i animate.css --save<br></code></pre></td></tr></table></figure>\n\n<p>3.使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;link rel=<span class=\"hljs-string\">&quot;stylesheet&quot;</span> href=<span class=\"hljs-string\">&quot;./node_modules/animate.css/animate.css&quot;</span>&gt;<br>&lt;transition <br>            enter-active-<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">&quot;animate__animated animate__flipInX&quot;</span><br>            leave-active-<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">&quot;animate__animated animate__rotateOutDownRight&quot;</span><br>            &gt;<br>    &lt;div <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">&quot;box&quot;</span> v-<span class=\"hljs-keyword\">if</span>=<span class=\"hljs-string\">&quot;isshow&quot;</span>&gt;&lt;/div&gt;<br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"建议：\"><a href=\"#建议：\" class=\"headerlink\" title=\"建议：\"></a>建议：</h5><p>只写进来|离开的动画，如果都写了，太花里胡哨。一般情况下写进来。</p>\n<h2 id=\"3-组件\"><a href=\"#3-组件\" class=\"headerlink\" title=\"3.组件\"></a>3.组件</h2><h5 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h5><p>可复用的vue实列</p>\n<h5 id=\"目的：\"><a href=\"#目的：\" class=\"headerlink\" title=\"目的：\"></a>目的：</h5><p>重复调用</p>\n<h5 id=\"注册：推荐局部\"><a href=\"#注册：推荐局部\" class=\"headerlink\" title=\"注册：推荐局部\"></a>注册：推荐局部</h5><p>1.全局注册：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">Vue.component（<span class=\"hljs-string\">&#x27;组件名&#x27;</span>，&#123;<br>    <span class=\"hljs-comment\">//配置项</span><br>&#125;）<br></code></pre></td></tr></table></figure>\n\n<p>2.局部注册：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;<br>    components:&#123;<br>        组件名:&#123;<br>            <span class=\"hljs-comment\">//配置项</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"组件命名\"><a href=\"#组件命名\" class=\"headerlink\" title=\"组件命名\"></a>组件命名</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//1.不要以现有的标签命名 eg：div span</span><br><span class=\"hljs-comment\">//2.不能以现有的标签的大写命名 eg Input   Div</span><br><span class=\"hljs-comment\">//3.如果组件名称中间包含了大写字母，调用改成  —小写  烤串写法</span><br><span class=\"hljs-comment\">//4.建议组件取名的时候中间包含一个大写字母，方便调用</span><br></code></pre></td></tr></table></figure>\n\n<h5 id=\"template\"><a href=\"#template\" class=\"headerlink\" title=\"template\"></a>template</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">1.一个vue实列只能挂载到一个节点上，所以template只能有一个元素<br>2.借助template 标签来实现template 配置顶<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">1.data是一个返回对象的函数<br>2.组件希望模板是一样的，但是数据是隔离的。如果直接使用json，json引用类型，<br>一个变全都变<br>3.一个vue实例只能使用自己的data、methods、watch、filters、mounted、computed,components ....<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"4-脚手架\"><a href=\"#4-脚手架\" class=\"headerlink\" title=\"4.脚手架\"></a>4.脚手架</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//安装webpack</span><br>npm i webpack -g<br><br><span class=\"hljs-comment\">//安装vue的脚手架</span><br>npm i vue-cli -g<br><br><span class=\"hljs-comment\">//创建项目</span><br>vue init webpack 项目名称<br><br><span class=\"hljs-comment\">//进入项目</span><br>cd 创建的项目<br><br><span class=\"hljs-comment\">//启动项目</span><br>npm run dev  <span class=\"hljs-comment\">//http://localhost:8080</span><br></code></pre></td></tr></table></figure>\n\n<h5 id=\"项目目录\"><a href=\"#项目目录\" class=\"headerlink\" title=\"项目目录\"></a>项目目录</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">- 项目<br>    -build webpack所有配置<br>\t-config 启动配置文件<br>\t-node_modules 依赖包<br>\t-dist 打包生成的文件夹<br>\t-static 静态资源：reset.css 图片 rem.js<br>\t.babelrc ES6-》ES5<br>\t-editorconfig 编辑器配置文件<br>\t.gitignore 上传到github不用上传的文件<br>\t.postcssrc.js 处理css<br>\t index.html 页面<br>\t package.json 记录项目命令和依赖包<br>\t README.md 项目说明<br>\t<br>\t -src 你的代码<br>\tmain.js 入口文件<br>\tApp.vue 根组件<br>\t\t<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"组件进阶\"><a href=\"#组件进阶\" class=\"headerlink\" title=\"组件进阶\"></a>组件进阶</h2><h4 id=\"1-组件通信\"><a href=\"#1-组件通信\" class=\"headerlink\" title=\"1.组件通信\"></a>1.组件通信</h4><ul>\n<li><h6 id=\"父传子\"><a href=\"#父传子\" class=\"headerlink\" title=\"父传子\"></a>父传子</h6></li>\n</ul>\n<p>父传子：父组件将要传递的数据通过自定义属性传递给子组件，子组件通过props、接收</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;!--父组件--&gt;<br>&lt;v-child :a&#x3D;&quot;name&quot;&gt;&lt;&#x2F;v-child&gt;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//子组件</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;   <br>    props:[<span class=\"hljs-string\">&quot;a&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>扩展：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">1.在子组件js使用父组件传递过来的数据，用this.age<br>2.对于一个组件来说，模板中可以使用的变量只能是自己的props  data computed，能直接修改的只有data和computed<br>3.父组件传递过来的数据，子组间不允许修改，按标准来做，应该使用子传父，实现子组件修改父组件的数据<br>4.如果子组件直接修改父组件传递过来的值子变 父不变 还报错<br>5.父变，子变；子变，父变.可以传递json数据解决。<br></code></pre></td></tr></table></figure>\n\n<p>props验证</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span>&#123;<br>    props:&#123;<br>        <span class=\"hljs-comment\">//约束传递过来的数据类型</span><br>        type:<span class=\"hljs-built_in\">Number</span>,<br>        <br>        <span class=\"hljs-comment\">//必传</span><br>        required:ture<br>    &#125;,<br>    arr:&#123;<br>        <span class=\"hljs-comment\">//默认值</span><br>        <span class=\"hljs-keyword\">default</span>()&#123;<br>            <span class=\"hljs-keyword\">return</span>[<span class=\"hljs-string\">&#x27;7&#x27;</span>,<span class=\"hljs-string\">&#x27;8&#x27;</span>,<span class=\"hljs-string\">&#x27;9&#x27;</span>]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"2-子传父\"><a href=\"#2-子传父\" class=\"headerlink\" title=\"2.子传父\"></a>2.子传父</h5><p>目的:</p>\n<p>子组件要修改父组件的值</p>\n<p>在父组件上绑定自定义事件，子组件通过$emit()触发自定义事件，携带的参数，在event上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;!--父组件--&gt;<br>&lt;v-child2 @changwang&#x3D;&#39;change&#39; @change&#x3D;&#39;changename(&#39;$event&#39;)&gt;&lt;&#x2F;v-child2&gt;<br></code></pre></td></tr></table></figure>\n\n<p>子组件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//子组件</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;<br>    methods:&#123;<br>        changeWang()&#123;<br>            <span class=\"hljs-comment\">//通知父组件 修改他自己的name </span><br>            <span class=\"hljs-built_in\">this</span>.$emit(<span class=\"hljs-string\">&quot;changewang&quot;</span>)<br>        &#125;,<br>        change(name)&#123;<br>            <span class=\"hljs-comment\">//通知父组件，把父组件的name改成功 name</span><br>            <span class=\"hljs-built_in\">this</span>.$emit(<span class=\"hljs-string\">&quot;change&quot;</span>,name)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"3-非父子传值\"><a href=\"#3-非父子传值\" class=\"headerlink\" title=\"3.非父子传值\"></a>3.非父子传值</h5><h6 id=\"1-单一事件管理：基本不会用到\"><a href=\"#1-单一事件管理：基本不会用到\" class=\"headerlink\" title=\"1.单一事件管理：基本不会用到\"></a>1.单一事件管理：基本不会用到</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//1. main.js</span><br>Vue.prototype.Event=<span class=\"hljs-keyword\">new</span> Vue();<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//2.想要接受数据的组件，绑定自定义事件</span><br> mounted()&#123;<br>     <span class=\"hljs-built_in\">this</span>.Event.$on(<span class=\"hljs-string\">&quot;sendA&quot;</span>,<span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>)=&gt;</span>&#123;<br>         <span class=\"hljs-built_in\">console</span>.log(e);<br>         <span class=\"hljs-built_in\">this</span>.a=e;<br>     &#125;)<br> &#125;,<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//3.触发事件</span><br><span class=\"hljs-built_in\">this</span>.Event.$emit(<span class=\"hljs-string\">&quot;sendA&quot;</span>,<span class=\"hljs-string\">&quot;王昭君&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-非父子传值-1\"><a href=\"#3-非父子传值-1\" class=\"headerlink\" title=\"3.非父子传值\"></a>3.非父子传值</h4><h5 id=\"1-单一事件管理-：永远不会用到\"><a href=\"#1-单一事件管理-：永远不会用到\" class=\"headerlink\" title=\"1.单一事件管理 ：永远不会用到\"></a>1.单一事件管理 ：永远不会用到</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//1. main.js</span><br>Vue.prototype.Event=<span class=\"hljs-keyword\">new</span> Vue();<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//2.想要接受数据的组件，绑定自定义事件</span><br> mounted()&#123;<br>     <span class=\"hljs-built_in\">this</span>.Event.$on(<span class=\"hljs-string\">&quot;sendA&quot;</span>,<span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>)=&gt;</span>&#123;<br>         <span class=\"hljs-built_in\">console</span>.log(e);<br>         <span class=\"hljs-built_in\">this</span>.a=e;<br>     &#125;)<br> &#125;,<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//3.触发事件</span><br><span class=\"hljs-built_in\">this</span>.Event.$emit(<span class=\"hljs-string\">&quot;sendA&quot;</span>,<span class=\"hljs-string\">&quot;王昭君&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2-vuex状态层\"><a href=\"#2-vuex状态层\" class=\"headerlink\" title=\"2.vuex状态层\"></a>2.vuex状态层</h5><h5 id=\"3-本地存储-localstorage-sessionStorage\"><a href=\"#3-本地存储-localstorage-sessionStorage\" class=\"headerlink\" title=\"3.本地存储 localstorage sessionStorage\"></a>3.本地存储 localstorage sessionStorage</h5><h2 id=\"2-is\"><a href=\"#2-is\" class=\"headerlink\" title=\"2.is\"></a>2.is</h2><h5 id=\"1-is-解决标签固定搭配问题\"><a href=\"#1-is-解决标签固定搭配问题\" class=\"headerlink\" title=\"1.is 解决标签固定搭配问题\"></a>1.is 解决标签固定搭配问题</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;ul&gt;<br>     &lt;li is&#x3D;&quot;v-one&quot;&gt;&lt;&#x2F;li&gt;<br>   &lt;&#x2F;ul&gt;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"2-动态组件\"><a href=\"#2-动态组件\" class=\"headerlink\" title=\"2.动态组件\"></a>2.动态组件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;button @click&#x3D;&quot;com&#x3D;&#39;v-one&#39;&quot;&gt;one&lt;&#x2F;button&gt;<br>&lt;button @click&#x3D;&quot;com&#x3D;&#39;v-two&#39;&quot;&gt;two&lt;&#x2F;button&gt;<br>&lt;!--2. 动态组件 --&gt;<br>&lt;div :is&#x3D;&quot;com&quot;&gt;&lt;&#x2F;div&gt;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"3-动态组件使用动画\"><a href=\"#3-动态组件使用动画\" class=\"headerlink\" title=\"3.动态组件使用动画\"></a>3.动态组件使用动画</h5><p>1.安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">cnpm i animate.css --save<br></code></pre></td></tr></table></figure>\n\n<p>2.main.js引入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//引入animate.css</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;animate.css&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>3.transition 嵌套</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;button @click&#x3D;&quot;obj&#x3D;&#39;v-ui&#39;&quot;&gt;ui&lt;&#x2F;button&gt;<br>   &lt;button @click&#x3D;&quot;obj&#x3D;&#39;v-java&#39;&quot;&gt;java&lt;&#x2F;button&gt;<br>   &lt;transition<br>   \tenter-active-class&#x3D;&quot;animate__animated animate__rotateInDownLeft&quot;<br>   &gt;<br>     \t&lt;div :is&#x3D;&quot;obj&quot;&gt;&lt;&#x2F;div&gt;<br>   &lt;&#x2F;transition&gt;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"3-slot插槽\"><a href=\"#3-slot插槽\" class=\"headerlink\" title=\"3.slot插槽\"></a>3.slot插槽</h2><p>目的：组件嵌套内容，不希望内容消失</p>\n<h6 id=\"1-匿名插槽\"><a href=\"#1-匿名插槽\" class=\"headerlink\" title=\"1.匿名插槽\"></a>1.匿名插槽</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;!-------组件---------&gt;\t<br>&lt;div class&#x3D;&quot;right&quot;&gt;<br>    &lt;!-- 匿名插槽 --&gt;<br>  &lt;slot&gt;&lt;&#x2F;slot&gt;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\"> &lt;v-one&gt;<br>     &lt;div&gt;天道酬勤&lt;&#x2F;div&gt;<br>&lt;&#x2F;v-one&gt;<br><br>&lt;v-one&gt;<br>    &lt;div&gt;人道酬善&lt;&#x2F;div&gt;<br>    &lt;div&gt;商道酬信&lt;&#x2F;div&gt;<br>&lt;&#x2F;v-one&gt;<br><br>&lt;v-one&gt;&lt;&#x2F;v-one&gt;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"4-scoped\"><a href=\"#4-scoped\" class=\"headerlink\" title=\"4.scoped\"></a>4.scoped</h2><p>样式局部作用，都要局部作用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;style scoped&gt;<br>h2 &#123;<br>  color: red;<br>&#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5-jquery\"><a href=\"#5-jquery\" class=\"headerlink\" title=\"5.jquery\"></a>5.jquery</h2><p>1.安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">npm i jquery --save<br></code></pre></td></tr></table></figure>\n\n<p>2引入 挂到vue的原型链上</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//main.js</span><br><span class=\"hljs-keyword\">import</span> $ <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;jquery&quot;</span><br>Vue.prototype.$=$<br><br></code></pre></td></tr></table></figure>\n\n<p>3.使用 ：注意在mounted之后使用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">mounted() &#123;<br>    <span class=\"hljs-built_in\">this</span>.$(<span class=\"hljs-string\">&quot;button&quot;</span>).eq(<span class=\"hljs-number\">0</span>).click(<span class=\"hljs-function\">()=&gt;</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.$(<span class=\"hljs-string\">&quot;.red&quot;</span>).slideDown(<span class=\"hljs-number\">400</span>);<br>      &#125;);<br>     <span class=\"hljs-built_in\">this</span>.$(<span class=\"hljs-string\">&quot;button&quot;</span>).eq(<span class=\"hljs-number\">1</span>).click(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.$(<span class=\"hljs-string\">&quot;.red&quot;</span>).slideUp(<span class=\"hljs-number\">400</span>);<br>      &#125;);<br>  &#125;,<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"6-ref\"><a href=\"#6-ref\" class=\"headerlink\" title=\"6.ref\"></a>6.ref</h2><p>是vue安全访问DOM和子组件的句柄！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;template&gt;<br>  &lt;div class&#x3D;&quot;box&quot;&gt;<br>    &lt;h1 ref&#x3D;&quot;h1&quot;&gt;ref&lt;&#x2F;h1&gt;<br>    &lt;button @click&#x3D;&quot;getWidth&quot;&gt;点击获取下面元素的宽度&lt;&#x2F;button&gt;<br>      <br>    &lt;!-- ref 访问了DOM --&gt;<br>    &lt;div class&#x3D;&quot;red&quot; ref&#x3D;&quot;red&quot;&gt;&lt;&#x2F;div&gt;<br><br>    &lt;button @click&#x3D;&quot;change&quot;&gt;哈哈哈&lt;&#x2F;button&gt;<br>    &lt;!-- ref 访问子组件 --&gt;<br>    &lt;v-child ref&#x3D;&quot;child&quot;&gt;&lt;&#x2F;v-child&gt;<br><br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import vChild from &quot;.&#x2F;child&quot;<br>export default &#123;<br>    components:&#123;<br>        vChild<br>    &#125;,<br>  methods: &#123;<br>    getWidth() &#123;<br>        console.log(this.$refs.red.clientWidth);<br>        var div&#x3D;this.$refs.red<br>        div.innerHTML&#x3D;&quot;哈哈哈&quot;<br>        div.style.background&#x3D;&quot;red&quot;<br>    &#125;,<br>    change()&#123;<br>        console.log(this.$refs.child);<br>        this.$refs.child.change()<br>    &#125;<br>  &#125;,<br>&#125;;<br>&lt;&#x2F;script&gt;<br><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"使用情景：\"><a href=\"#使用情景：\" class=\"headerlink\" title=\"使用情景：\"></a>使用情景：</h4><p>1.媒体元素</p>\n<p>2.DOM属性：offsetLeft clientWidth  scrollTop 、children</p>\n<p>3.父组件要调用子组件的数据和方法</p>\n<p>注意：ref必须在mounted之后</p>\n","raw":null,"categories":[],"tags":[{"name":"vue2","path":"api/tags/vue2.json"}]},{"title":"vue源码理解——变化侦测篇","slug":"vue源码理解1","date":"2021-03-18T11:29:18.000Z","updated":"2021-04-25T06:23:32.575Z","comments":true,"top":null,"path":"api/articles/vue源码理解1.json","excerpt":null,"keywords":null,"cover":"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210421145548907.png","content":"<h3 id=\"1-变化侦测篇\"><a href=\"#1-变化侦测篇\" class=\"headerlink\" title=\"1.变化侦测篇\"></a>1.变化侦测篇</h3><p><code>Vue</code>中如何实现数据的响应式系统，从而达到数据驱动视图。</p>\n<h5 id=\"变化侦测\"><a href=\"#变化侦测\" class=\"headerlink\" title=\"变化侦测\"></a>变化侦测</h5><p>vue最大的特点之一就是数据驱动视图</p>\n<p>什么是数据驱动视图？我们可以把数据理解成状态，而视图就是用户可以直观看到的，页面不是一层不变的，它是动态变化的，它可能是用户操作引起变化，也可能因为后台数据引起变化的，不管它尤什么引起的，我们统称状态变了由前一个状态变到了后一个状态，页面也就应该随之而变化，所以我们就可以得到如下一个公式：**<em>UI = render(state)**</em></p>\n<p>公式中：状态<code>state</code>是输入，页面<code>UI</code>输出，状态输入一旦变化了，页面输出也随之而变化。我们把这种特性称之为数据驱动视图。</p>\n<p>OK，有了基本概念以后，我们再把上述公式拆成三部分：<code>state</code>、<code>render()</code>以及<code>UI</code>。我们知道<code>state</code>和<code>UI</code>都是用户定的，而不变的是这个<code>render()</code>。所以<code>Vue</code>就扮演了<code>render()</code>这个角色，当<code>Vue</code>发现<code>state</code>变化之后，经过一系列加工，最终将变化反应在<code>UI</code>上。</p>\n<h5 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h5><h5 id=\"Object的变化侦测\"><a href=\"#Object的变化侦测\" class=\"headerlink\" title=\"Object的变化侦测\"></a>Object的变化侦测</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> car = &#123;&#125;<br>        <span class=\"hljs-keyword\">let</span> val = <span class=\"hljs-number\">3000</span><br>        <span class=\"hljs-built_in\">Object</span>.defineProperty(car, <span class=\"hljs-string\">&#x27;price&#x27;</span>, &#123;<br>            enumerable: <span class=\"hljs-literal\">true</span>,<br>            configurable: <span class=\"hljs-literal\">true</span>,<br>            get() &#123;<br>                <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;price 的属性被读取了&#x27;</span>)<br>                <span class=\"hljs-keyword\">return</span> val<br>            &#125;,<br>            set(newval) &#123;<br>                <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;price的属性被修改了&#x27;</span>)<br>                val = newval<br>            &#125;<br>        &#125;)<br><span class=\"hljs-comment\">//通过Object.defineProperty()方法给car定义了一个price属性，并把这个属性的读和写分别使用get()和set()进行拦截，每当该属性进行读或写操作的时候就会触发get()和set()  如下图</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210421145548907.png\" alt=\"image-20210421145548907\"></p>\n<p>注：enumerable控制是否可以删除</p>\n<p>​         configurable控制是否可以枚举（循环遍历）</p>\n<p>怎么把<code>car</code>的所有属性都变得可观测？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Observer</span> </span>&#123;<br>            <span class=\"hljs-keyword\">constructor</span>(value) &#123;<br>                <span class=\"hljs-built_in\">this</span>.value = value<br><span class=\"hljs-comment\">// 给value新增一个__ob__属性，值为该value的Observer实例</span><br><span class=\"hljs-comment\">// 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作</span><br>                def(value, <span class=\"hljs-string\">&#x27;__ob__&#x27;</span>, <span class=\"hljs-built_in\">this</span>)<br>                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Array</span>.isArray(value)) &#123;<br>                    <span class=\"hljs-comment\">// 当value为数组时的逻辑</span><br>                    <span class=\"hljs-comment\">// ...</span><br>                &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                    <span class=\"hljs-built_in\">this</span>.walk(value)<br>                &#125;<br>            &#125;<br><br>            walk(obj:<span class=\"hljs-built_in\">Object</span>) &#123;<br>                <span class=\"hljs-keyword\">const</span> keys = <span class=\"hljs-built_in\">Object</span>.keys(obj)<br>                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; keys.length; i++) &#123;<br>                    defineReactive(obj, keys[i])<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">         * 使一个对象转化成可观测对象</span><br><span class=\"hljs-comment\">         * @param &#123; Object &#125; obj 对象</span><br><span class=\"hljs-comment\">         * @param &#123; String &#125; key 对象的key</span><br><span class=\"hljs-comment\">         * @param &#123; Any &#125; val 对象的某个key的值</span><br><span class=\"hljs-comment\">         */</span><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">defineReactive</span>(<span class=\"hljs-params\">obj, key, val</span>) </span>&#123;<br>            <span class=\"hljs-comment\">// 如果只传了obj和key，那么val = obj[key]</span><br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">arguments</span>.length === <span class=\"hljs-number\">2</span>) &#123;<br>                val = obj[key]<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> val === <span class=\"hljs-string\">&#x27;object&#x27;</span>) &#123;<br>                <span class=\"hljs-keyword\">new</span> Observer(val)<br>            &#125;<br>            <span class=\"hljs-built_in\">Object</span>.defineProperty(obj, key, &#123;<br>                enumerable: <span class=\"hljs-literal\">true</span>,<br>                configurable: <span class=\"hljs-literal\">true</span>,<br>                get() &#123;<br>                    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>属性被读取了`</span>);<br>                    <span class=\"hljs-keyword\">return</span> val;<br>                &#125;,<br>                set(newVal) &#123;<br>                    <span class=\"hljs-keyword\">if</span> (val === newVal) &#123;<br>                        <span class=\"hljs-keyword\">return</span><br>                    &#125;<br>                    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>属性被修改了`</span>);<br>                    val = newVal;<br>                &#125;<br>            &#125;)<br>        &#125;<br>        <span class=\"hljs-keyword\">let</span> car = <span class=\"hljs-keyword\">new</span> Observer(&#123;<br>            <span class=\"hljs-string\">&#x27;brand&#x27;</span>: <span class=\"hljs-string\">&#x27;BMW&#x27;</span>,<br>            <span class=\"hljs-string\">&#x27;price&#x27;</span>: <span class=\"hljs-number\">3000</span><br>        &#125;)<br></code></pre></td></tr></table></figure>\n\n<p>​             在上面的代码中，我们定义了<code>observer</code>类，它用来将一个正常的<code>object</code>转换成可观测的<code>object</code>。</p>\n<p>并且给<code>value</code>新增一个<code>__ob__</code>属性，值为该<code>value</code>的<code>Observer</code>实例。这个操作相当于为<code>value</code>打上标记，表示它已经被转化成响应式了，避免重复操作</p>\n<p>然后判断数据的类型，只有<code>object</code>类型的数据才会调用<code>walk</code>将每一个属性转换成<code>getter/setter</code>的形式来侦测变化。 最后，在<code>defineReactive</code>中当传入的属性值还是一个<code>object</code>时使用<code>new observer（val）</code>来递归子属性，这样我们就可以把<code>obj</code>中的所有属性（包括子属性）都转换成<code>getter/seter</code>的形式来侦测变化。 也就是说，只要我们将一个<code>object</code>传到<code>observer</code>中，那么这个<code>object</code>就会变成可观测的、响应式的<code>object</code>。</p>\n<h6 id=\"依赖收集\"><a href=\"#依赖收集\" class=\"headerlink\" title=\"依赖收集\"></a>依赖收集</h6><p>什么是依赖收集？</p>\n<p>如上，我们可以做到数据可观测性，这样我们就可以知道什么时候发生了什么变化，当数据发生变化后，我们去通知视图去更新就好了，但是视图有好多，到底去通知谁去变化？肯定不能一个数据变了然后去刷新所有视图，所以要做到：视图里谁用到了这个数据就更新谁</p>\n<p>视图里谁用到了这个数据就更新谁，换个说法就是我们把”谁用到了这个数据”称为”谁依赖了这个数据”,我们给每个数据都建一个依赖数组(因为一个数据可能被多处使用)，谁依赖了这个数据(即谁用到了这个数据)我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们：”你们依赖的数据变啦，你们该更新啦！”。这个过程就是<code>依赖收集</code></p>\n<p>谁用到了这个数据，其实就是谁获取了这个数据，而可观测的数据被获取时会触发<code>getter</code>属性，那么我们就可以在<code>getter</code>中收集这个依赖。同样，当这个数据变化时会触发<code>setter</code>属性，那么我们就可以在<code>setter</code>中通知依赖更新。</p>\n<p>总结一句话就是：<strong>在getter中收集依赖，在setter中通知依赖更新</strong></p>\n<h6 id=\"把依赖收集到哪？？？\"><a href=\"#把依赖收集到哪？？？\" class=\"headerlink\" title=\"把依赖收集到哪？？？\"></a>把依赖收集到哪？？？</h6><p>我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中。单单用一个数组来存放依赖的话，功能好像有点欠缺并且代码过于耦合。我们应该将依赖数组的功能扩展一下，更好的做法是我们应该为每一个数据都建立一个依赖管理器，把这个数据所有的依赖都管理起来。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dep</span> </span>&#123;<br>  <span class=\"hljs-keyword\">constructor</span> () &#123;<br>    <span class=\"hljs-built_in\">this</span>.subs = []<br>  &#125;<br><br>  addSub (sub) &#123;<br>    <span class=\"hljs-built_in\">this</span>.subs.push(sub)<br>  &#125;<br>  <span class=\"hljs-comment\">// 删除一个依赖</span><br>  removeSub (sub) &#123;<br>    remove(<span class=\"hljs-built_in\">this</span>.subs, sub)<br>  &#125;<br>  <span class=\"hljs-comment\">// 添加一个依赖</span><br>  depend () &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">window</span>.target) &#123;<br>      <span class=\"hljs-built_in\">this</span>.addSub(<span class=\"hljs-built_in\">window</span>.target)<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-comment\">// 通知所有依赖更新</span><br>  notify () &#123;<br>    <span class=\"hljs-keyword\">const</span> subs = <span class=\"hljs-built_in\">this</span>.subs.slice()<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, l = subs.length; i &lt; l; i++) &#123;<br>      subs[i].update()<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Remove an item from an array</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">remove</span> (<span class=\"hljs-params\">arr, item</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (arr.length) &#123;<br>    <span class=\"hljs-keyword\">const</span> index = arr.indexOf(item)<br>    <span class=\"hljs-keyword\">if</span> (index &gt; <span class=\"hljs-number\">-1</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> arr.splice(index, <span class=\"hljs-number\">1</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的依赖管理器<code>Dep</code>类中，我们先初始化了一个<code>subs</code>数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作</p>\n<p>有了依赖管理器后，我们就可以在getter中收集依赖，在setter中通知依赖更新了，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">defineReactive</span>(<span class=\"hljs-params\">obj, key, val</span>) </span>&#123;<br>           <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">arguments</span>.length === <span class=\"hljs-number\">2</span>) &#123;<br>               val = obj[key]<br>           &#125;<br>           <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> val === <span class=\"hljs-string\">&#x27;object&#x27;</span>) &#123;<br>               <span class=\"hljs-keyword\">new</span> Observer(val)<br>           &#125;<br>           <span class=\"hljs-keyword\">const</span> dep = <span class=\"hljs-keyword\">new</span> Dep() <span class=\"hljs-comment\">//实例化一个依赖管理器，生成一个依赖管理数组dep</span><br>           <span class=\"hljs-built_in\">Object</span>.defineProperty(obj, key, &#123;<br>               enumerable: <span class=\"hljs-literal\">true</span>,<br>               configurable: <span class=\"hljs-literal\">true</span>,<br>               get() &#123;<br>                   dep.depend() <span class=\"hljs-comment\">// 在getter中收集依赖</span><br>                   <span class=\"hljs-keyword\">return</span> val;<br>               &#125;,<br>               set(newVal) &#123;<br>                   <span class=\"hljs-keyword\">if</span> (val === newVal) &#123;<br>                       <span class=\"hljs-keyword\">return</span><br>                   &#125;<br>                   val = newVal;<br>                   dep.notify() <span class=\"hljs-comment\">// 在setter中通知依赖更新</span><br>               &#125;<br>           &#125;)<br>       &#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述代码中，我们在<code>getter</code>中调用了<code>dep.depend()</code>方法收集依赖，在<code>setter</code>中调用<code>dep.notify()</code>方法通知所有依赖更新。</p>\n<h6 id=\"依赖是谁？？？\"><a href=\"#依赖是谁？？？\" class=\"headerlink\" title=\"依赖是谁？？？\"></a>依赖是谁？？？</h6><p>通过上一章节，我们明白了什么是依赖？何时收集依赖？以及收集的依赖存放到何处？那么我们收集的依赖到底是谁？</p>\n<p>虽然我们一直在说”谁用到了这个数据谁就是依赖“，但是这仅仅是在口语层面上，那么反应在代码上该如何来描述这个”谁“呢？</p>\n<p>其实在<code>Vue</code>中还实现了一个叫做<code>Watcher</code>的类，而<code>Watcher</code>类的实例就是我们上面所说的那个”谁”。换句话说就是：谁用到了数据，谁就是依赖，我们就为谁创建一个<code>Watcher</code>实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的<code>Watch</code>实例，由<code>Watcher</code>实例去通知真正的视图。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Watcher</span> </span>&#123;<br>  <span class=\"hljs-keyword\">constructor</span> (vm,expOrFn,cb) &#123;<br>    <span class=\"hljs-built_in\">this</span>.vm = vm;<br>    <span class=\"hljs-built_in\">this</span>.cb = cb;<br>    <span class=\"hljs-built_in\">this</span>.getter = parsePath(expOrFn)<br>    <span class=\"hljs-built_in\">this</span>.value = <span class=\"hljs-built_in\">this</span>.get()<br>  &#125;<br>  get () &#123;<br>    <span class=\"hljs-built_in\">window</span>.target = <span class=\"hljs-built_in\">this</span>;<br>    <span class=\"hljs-keyword\">const</span> vm = <span class=\"hljs-built_in\">this</span>.vm<br>    <span class=\"hljs-keyword\">let</span> value = <span class=\"hljs-built_in\">this</span>.getter.call(vm, vm)<br>    <span class=\"hljs-built_in\">window</span>.target = <span class=\"hljs-literal\">undefined</span>;<br>    <span class=\"hljs-keyword\">return</span> value<br>  &#125;<br>  update () &#123;<br>    <span class=\"hljs-keyword\">const</span> oldValue = <span class=\"hljs-built_in\">this</span>.value<br>    <span class=\"hljs-built_in\">this</span>.value = <span class=\"hljs-built_in\">this</span>.get()<br>    <span class=\"hljs-built_in\">this</span>.cb.call(<span class=\"hljs-built_in\">this</span>.vm, <span class=\"hljs-built_in\">this</span>.value, oldValue)<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Parse simple path.</span><br><span class=\"hljs-comment\"> * 把一个形如&#x27;data.a.b.c&#x27;的字符串路径所表示的值，从真实的data对象中取出来</span><br><span class=\"hljs-comment\"> * 例如：</span><br><span class=\"hljs-comment\"> * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125;</span><br><span class=\"hljs-comment\"> * parsePath(&#x27;a.b.c&#x27;)(data)  // 2</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">const</span> bailRE = <span class=\"hljs-regexp\">/[^\\w.$]/</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">parsePath</span> (<span class=\"hljs-params\">path</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (bailRE.test(path)) &#123;<br>    <span class=\"hljs-keyword\">return</span><br>  &#125;<br>  <span class=\"hljs-keyword\">const</span> segments = path.split(<span class=\"hljs-string\">&#x27;.&#x27;</span>)<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">obj</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; segments.length; i++) &#123;<br>      <span class=\"hljs-keyword\">if</span> (!obj) <span class=\"hljs-keyword\">return</span><br>      obj = obj[segments[i]]<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> obj<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>当实例化<code>Watcher</code>类时，会先执行其构造函数；</li>\n<li>在构造函数中调用了<code>this.get()</code>实例方法；</li>\n<li>在<code>get()</code>方法中，首先通过<code>window.target = this</code>把实例自身赋给了全局的一个唯一对象<code>window.target</code>上，然后通过<code>let value = this.getter.call(vm, vm)</code>获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的<code>getter</code>，上文我们说过，在<code>getter</code>里会调用<code>dep.depend()</code>收集依赖，而在<code>dep.depend()</code>中取到挂载<code>window.target</code>上的值并将其存入依赖数组中，在<code>get()</code>方法最后将<code>window.target</code>释放掉。</li>\n<li>而当数据变化时，会触发数据的<code>setter</code>，在<code>setter</code>中调用了<code>dep.notify()</code>方法，在<code>dep.notify()</code>方法中，遍历所有依赖(即watcher实例)，执行依赖的<code>update()</code>方法，也就是<code>Watcher</code>类中的<code>update()</code>实例方法，在<code>update()</code>方法中调用数据变化的更新回调函数，从而更新视图。</li>\n</ol>\n<p>简单总结一下就是：<code>Watcher</code>先把自己设置到全局唯一的指定位置（<code>window.target</code>），然后读取数据。因为读取了数据，所以会触发这个数据的<code>getter</code>。接着，在<code>getter</code>中就会从全局唯一的那个位置读取当前正在读取数据的<code>Watcher</code>，并把这个<code>watcher</code>收集到<code>Dep</code>中去。收集好之后，当数据发生变化时，会向<code>Dep</code>中的每个<code>Watcher</code>发送通知。通过这样的方式，<code>Watcher</code>可以主动去订阅任意一个数据的变化。</p>\n<h6 id=\"不足：\"><a href=\"#不足：\" class=\"headerlink\" title=\"不足：\"></a>不足：</h6><p>虽然我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，但是这个方法仅仅只能观测到<code>object</code>数据的取值及设置值，当我们向<code>object</code>数据里添加一对新的<code>key/value</code>或删除一对已有的<code>key/value</code>时，它是无法观测到的，导致当我们对<code>object</code>数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。</p>\n<p>当然，<code>Vue</code>也注意到了这一点，为了解决这一问题，<code>Vue</code>增加了两个全局API:<code>Vue.set</code>和<code>Vue.delete</code>，这两个API的实现原理将会在后面学习全局API的时候说到</p>\n<h6 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h6><p>首先，我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，并且封装了<code>Observer</code>类，让我们能够方便的把<code>object</code>数据中的所有属性（包括子属性）都转换成<code>getter/seter</code>的形式来侦测变化。</p>\n<p>接着，我们学习了什么是依赖收集？并且知道了在<code>getter</code>中收集依赖，在<code>setter</code>中通知依赖更新，以及封装了依赖管理器<code>Dep</code>，用于存储收集到的依赖。</p>\n<p>最后，我们为每一个依赖都创建了一个<code>Watcher</code>实例，当数据发生变化时，通知<code>Watcher</code>实例，由<code>Watcher</code>实例去做真实的更新操作。</p>\n<p>其整个流程大致如下：</p>\n<ol>\n<li><code>Data</code>通过<code>observer</code>转换成了<code>getter/setter</code>的形式来追踪变化。</li>\n<li>当外界通过<code>Watcher</code>读取数据时，会触发<code>getter</code>从而将<code>Watcher</code>添加到依赖中。</li>\n<li>当数据发生了变化时，会触发<code>setter</code>，从而向<code>Dep</code>中的依赖（即Watcher）发送通知。</li>\n<li><code>Watcher</code>接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</li>\n</ol>\n<h5 id=\"Array的变化侦测\"><a href=\"#Array的变化侦测\" class=\"headerlink\" title=\"Array的变化侦测\"></a>Array的变化侦测</h5><p>上一篇文章中我们介绍了<code>Object</code>数据的变化侦测方式，本篇文章我们来看一下对<code>Array</code>型数据的变化<code>Vue</code>是如何进行侦测的。</p>\n<p>为什么<code>Object</code>数据和<code>Array</code>型数据会有两种不同的变化侦测方式？</p>\n<p>这是因为对于<code>Object</code>数据我们使用的是<code>JS</code>提供的对象原型上的方法<code>Object.defineProperty</code>，而这个方法是对象原型上的，所以<code>Array</code>无法使用这个方法，所以我们需要对<code>Array</code>型数据设计一套另外的变化侦测机制。</p>\n<p>万变不离其宗，虽然对<code>Array</code>型数据设计了新的变化侦测机制，但是其根本思路还是不变的。那就是：还是在获取数据时收集依赖，数据变化时通知依赖更新。</p>\n<p>下面我们就通过源码来看看<code>Vue</code>对<code>Array</code>型数据到底是如何进行变化侦测的。</p>\n<p>大同小异思路同object一样还是先把用到<code>Array</code>型数据的地方作为依赖收集起来。</p>\n<p>那么如何收集呢？？？</p>\n<p>其实<code>Array</code>型数据的依赖收集方式和<code>Object</code>数据的依赖收集方式相同，都是在<code>getter</code>中收集。那么问题就来了，不是说<code>Array</code>无法使用<code>Object.defineProperty</code>方法吗？无法使用怎么还在<code>getter</code>中收集依赖呢？</p>\n<p>那么我们回想一下平常在开发的时候，在组件的<code>data</code>中是不是都这么写的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">data()&#123;<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    arr:[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>arr</code>这个数据始终都存在于一个<code>object</code>数据对象中，而且我们也说了，谁用到了数据谁就是依赖，那么要用到<code>arr</code>这个数据，是不是得先从<code>object</code>数据对象中获取一下<code>arr</code>数据，而从<code>object</code>数据对象中获取<code>arr</code>数据自然就会触发<code>arr</code>的<code>getter</code>，所以我们就可以在<code>getter</code>中收集依赖。</p>\n<p>总结一句话就是：<strong>Array型数据还是在getter中收集依赖。</strong></p>\n<p>如何使Array数据成为可观测性呢？？？</p>\n<p><code>Object</code>数据变化侦测的时候，我们先让<code>Object</code>数据变的可观测，即我们能够知道数据什么时候被读取了、什么时候发生变化了。同理，对于<code>Array</code>型数据我们也得让它变的可观测，目前我们已经完成了一半可观测，即我们只知道了<code>Array</code>型数据何时被读取了，而何时发生变化我们无法知道，那么接下来我们就来解决这一问题：当<code>Array</code>型数据发生变化时我们如何得知？</p>\n<p>分析：</p>\n<p><code>Object</code>的变化时通过<code>setter</code>来追踪的，只有某个数据发生了变化，就一定会触发这个数据上的<code>setter</code>。但是<code>Array</code>型数据没有<code>setter</code>，怎么办？</p>\n<p>我们试想一下，要想让<code>Array</code>型数据发生变化，那必然是操作了<code>Array</code>，而<code>JS</code>中提供的操作数组的方法就那么几种，我们可以把这些方法都重写一遍，在不改变原有功能的前提下，我们为其新增一些其他功能，例如下面这个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]<br>        arr.push(<span class=\"hljs-number\">4</span>)<br>        <span class=\"hljs-built_in\">Array</span>.prototype.newPush=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">val</span>)</span>&#123;<br>            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;arr 被修改了&#x27;</span>)<br>            <span class=\"hljs-built_in\">this</span>.push(val)<br>        &#125;<br>        arr.newPush(<span class=\"hljs-number\">4</span>)<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"C:\\Users\\梁超\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210422103153864.png\" alt=\"image-20210422103153864\"></p>\n<p>在上面这个例子中，我们针对数组的原生<code>push</code>方法定义个一个新的<code>newPush</code>方法，这个<code>newPush</code>方法内部调用了原生<code>push</code>方法，这样就保证了新的<code>newPush</code>方法跟原生<code>push</code>方法具有相同的功能，而且我们还可以在新的<code>newPush</code>方法内部干一些别的事情，比如通知变化。</p>\n<p>是不是很巧妙？<code>Vue</code>内部就是这么干的。</p>\n<p>数组方法拦截器：</p>\n<p>在<code>Vue</code>中创建了一个数组方法拦截器，它拦截在数组实例与<code>Array.prototype</code>之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用<code>Array.prototype</code>上的原生方法。</p>\n<p>经过整理，<code>Array</code>原型中可以改变数组自身内容的方法有7个，分别是：<code>push</code>,<code>pop</code>,<code>shift</code>,<code>unshift</code>,<code>splice</code>,<code>sort</code>,<code>reverse</code>。那么源码中的拦截器代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arrayProto = <span class=\"hljs-built_in\">Array</span>.prototype<br><span class=\"hljs-comment\">// 创建一个对象作为拦截器</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> arrayMethods = <span class=\"hljs-built_in\">Object</span>.create(arrayProto)<br><br><span class=\"hljs-comment\">// 改变数组自身内容的7个方法</span><br><span class=\"hljs-keyword\">const</span> methodsToPatch = [<br>  <span class=\"hljs-string\">&#x27;push&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;pop&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;shift&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;unshift&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;splice&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;sort&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;reverse&#x27;</span><br>]<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Intercept mutating methods and emit events</span><br><span class=\"hljs-comment\"> */</span><br>methodsToPatch.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">method</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> original = arrayProto[method]      <span class=\"hljs-comment\">// 缓存原生方法</span><br>  <span class=\"hljs-built_in\">Object</span>.defineProperty(arrayMethods, method, &#123;<br>    enumerable: <span class=\"hljs-literal\">false</span>,<br>    configurable: <span class=\"hljs-literal\">true</span>,<br>    writable: <span class=\"hljs-literal\">true</span>,<br>    value:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mutator</span>(<span class=\"hljs-params\">...args</span>)</span>&#123;<br>      <span class=\"hljs-keyword\">const</span> result = original.apply(<span class=\"hljs-built_in\">this</span>, args)<br>      <span class=\"hljs-keyword\">return</span> result<br>    &#125;<br>  &#125;)<br>&#125;)<br><br></code></pre></td></tr></table></figure>\n\n<p>在上面的代码中，首先创建了继承自<code>Array</code>原型的空对象<code>arrayMethods</code>，接着在<code>arrayMethods</code>上使用<code>object.defineProperty</code>方法将那些可以改变数组自身的7个方法遍历逐个进行封装。最后，当我们使用<code>push</code>方法的时候，其实用的是<code>arrayMethods.push</code>，而<code>arrayMethods.push</code>就是封装的新函数<code>mutator</code>，也就后说，实标上执行的是函数<code>mutator</code>，而<code>mutator</code>函数内部执行了<code>original</code>函数，这个<code>original</code>函数就是<code>Array.prototype</code>上对应的原生方法。 那么，接下来我们就可以在<code>mutato</code>r函数中做一些其他的事，比如说发送变化通知。</p>\n<p>使用拦截器：</p>\n<p>上一小节的图中，我们把拦截器做好还不够，还要把它挂载到数组实例与<code>Array.prototype</code>之间，这样拦截器才能够生效。</p>\n<p>其实挂载不难，我们只需把数据的<code>__proto__</code>属性设置为拦截器<code>arrayMethods</code>即可，源码实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Observer</span> </span>&#123;<br>  <span class=\"hljs-keyword\">constructor</span> (value) &#123;<br>    <span class=\"hljs-built_in\">this</span>.value = value<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Array</span>.isArray(value)) &#123;<br>      <span class=\"hljs-keyword\">const</span> augment = hasProto<br>        ? protoAugment<br>        : copyAugment<br>      augment(value, arrayMethods, arrayKeys)<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-built_in\">this</span>.walk(value)<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> hasProto = <span class=\"hljs-string\">&#x27;__proto__&#x27;</span> <span class=\"hljs-keyword\">in</span> &#123;&#125;<br><br><span class=\"hljs-keyword\">const</span> arrayKeys = <span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames(arrayMethods)<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Augment an target Object or Array by intercepting</span><br><span class=\"hljs-comment\"> * the prototype chain using __proto__</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">protoAugment</span> (<span class=\"hljs-params\">target, src: Object, keys: any</span>) </span>&#123;<br>  target.__proto__ = src<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Augment an target Object or Array by defining</span><br><span class=\"hljs-comment\"> * hidden properties.</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-comment\">/* istanbul ignore next */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">copyAugment</span> (<span class=\"hljs-params\">target: Object, src: Object, keys: Array&lt;string&gt;</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, l = keys.length; i &lt; l; i++) &#123;<br>    <span class=\"hljs-keyword\">const</span> key = keys[i]<br>    def(target, key, src[key])<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中首先判断了浏览器是否支持<code>__proto__</code>，如果支持，则调用<code>protoAugment</code>函数把<code>value.__proto__ = arrayMethods</code>；如果不支持，则调用<code>copyAugment</code>函数把拦截器中重写的7个方法循环加入到<code>value</code>上。</p>\n<p>拦截器生效以后，当数组数据再发生变化时，我们就可以在拦截器中通知变化了，也就是说现在我们就可以知道数组数据何时发生变化了，OK，以上我们就完成了对<code>Array</code>型数据的可观测。</p>\n<p>收集依赖：</p>\n<p>把依赖收集到哪里？？？</p>\n<p>我们说了，数组数据的依赖也在<code>getter</code>中收集，而给数组数据添加<code>getter/setter</code>都是在<code>Observer</code>类中完成的，所以我们也应该在<code>Observer</code>类中收集依赖，源码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Observer</span> </span>&#123;<br>  <span class=\"hljs-keyword\">constructor</span> (value) &#123;<br>    <span class=\"hljs-built_in\">this</span>.value = value<br>    <span class=\"hljs-built_in\">this</span>.dep = <span class=\"hljs-keyword\">new</span> Dep()    <span class=\"hljs-comment\">// 实例化一个依赖管理器，用来收集数组依赖</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Array</span>.isArray(value)) &#123;<br>      <span class=\"hljs-keyword\">const</span> augment = hasProto<br>        ? protoAugment<br>        : copyAugment<br>      augment(value, arrayMethods, arrayKeys)<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-built_in\">this</span>.walk(value)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，在<code>Observer</code>类中实例化了一个依赖管理器，用来收集数组依赖</p>\n<p>如何收集依赖？？？</p>\n<p>，数组的依赖也在<code>getter</code>中收集，那么在<code>getter</code>中到底该如何收集呢？这里有一个需要注意的点，那就是依赖管理器定义在<code>Observer</code>类中，而我们需要在<code>getter</code>中收集依赖，也就是说我们必须在<code>getter</code>中能够访问到<code>Observer</code>类中的依赖管理器，才能把依赖存进去。源码是这么做的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">defineReactive</span> (<span class=\"hljs-params\">obj,key,val</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> childOb = observe(val)<br>  <span class=\"hljs-built_in\">Object</span>.defineProperty(obj, key, &#123;<br>    enumerable: <span class=\"hljs-literal\">true</span>,<br>    configurable: <span class=\"hljs-literal\">true</span>,<br>    get()&#123;<br>      <span class=\"hljs-keyword\">if</span> (childOb) &#123;<br>        childOb.dep.depend()<br>      &#125;<br>      <span class=\"hljs-keyword\">return</span> val;<br>    &#125;,<br>    set(newVal)&#123;<br>      <span class=\"hljs-keyword\">if</span>(val === newVal)&#123;<br>        <span class=\"hljs-keyword\">return</span><br>      &#125;<br>      val = newVal;<br>      dep.notify()   <span class=\"hljs-comment\">// 在setter中通知依赖更新</span><br>    &#125;<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Attempt to create an observer instance for a value,</span><br><span class=\"hljs-comment\"> * returns the new observer if successfully observed,</span><br><span class=\"hljs-comment\"> * or the existing observer if the value already has one.</span><br><span class=\"hljs-comment\"> * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。</span><br><span class=\"hljs-comment\"> * 如果 Value 已经存在一个Observer实例，则直接返回它</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">observe</span> (<span class=\"hljs-params\">value, asRootData</span>)</span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (!isObject(value) || value <span class=\"hljs-keyword\">instanceof</span> VNode) &#123;<br>    <span class=\"hljs-keyword\">return</span><br>  &#125;<br>  <span class=\"hljs-keyword\">let</span> ob<br>  <span class=\"hljs-keyword\">if</span> (hasOwn(value, <span class=\"hljs-string\">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class=\"hljs-keyword\">instanceof</span> Observer) &#123;<br>    ob = value.__ob__<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    ob = <span class=\"hljs-keyword\">new</span> Observer(value)<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> ob<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面代码中，我们首先通过<code>observe</code>函数为被获取的数据<code>arr</code>尝试创建一个<code>Observer</code>实例，在<code>observe</code>函数内部，先判断当前传入的数据上是否有<code>__ob__</code>属性，因为在上篇文章中说了，如果数据有<code>__ob__</code>属性，表示它已经被转化成响应式的了，如果没有则表示该数据还不是响应式的，那么就调用<code>new Observer(value)</code>将其转化成响应式的，并把数据对应的<code>Observer</code>实例返回。</p>\n<p>而在<code>defineReactive</code>函数中，首先获取数据对应的<code>Observer</code>实例<code>childOb</code>，然后在<code>getter</code>中调用<code>Observer</code>实例上依赖管理器，从而将依赖收集起来。</p>\n<p>到现在为止，依赖已经收集好了，并且也已经存放好了，那么我们该如何通知依赖呢？</p>\n<p>其实不难，在前文说过，我们应该在拦截器里通知依赖，要想通知依赖，首先要能访问到依赖。要访问到依赖也不难，因为我们只要能访问到被转化成响应式的数据<code>value</code>即可，因为<code>vaule</code>上的<code>__ob__</code>就是其对应的<code>Observer</code>类实例，有了<code>Observer</code>类实例我们就能访问到它上面的依赖管理器，然后只需调用依赖管理器的<code>dep.notify()</code>方法，让它去通知依赖更新即可。源码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Intercept mutating methods and emit events</span><br><span class=\"hljs-comment\"> */</span><br>methodsToPatch.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">method</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> original = arrayProto[method]<br>  def(arrayMethods, method, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mutator</span> (<span class=\"hljs-params\">...args</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">const</span> result = original.apply(<span class=\"hljs-built_in\">this</span>, args)<br>    <span class=\"hljs-keyword\">const</span> ob = <span class=\"hljs-built_in\">this</span>.__ob__<br>    <span class=\"hljs-comment\">// notify change</span><br>    ob.dep.notify()<br>    <span class=\"hljs-keyword\">return</span> result<br>  &#125;)<br>&#125;)<br><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，由于我们的拦截器是挂载到数组数据的原型上的，所以拦截器中的<code>this</code>就是数据<code>value</code>，拿到<code>value</code>上的<code>Observer</code>类实例，从而你就可以调用<code>Observer</code>类实例上面依赖管理器的<code>dep.notify()</code>方法，以达到通知依赖的目的。</p>\n<p>OK，以上就基本完成了<code>Array</code>数据的变化侦测。</p>\n<h5 id=\"深度侦测：\"><a href=\"#深度侦测：\" class=\"headerlink\" title=\"深度侦测：\"></a>深度侦测：</h5><p>在前文所有讲的<code>Array</code>型数据的变化侦测都仅仅说的是数组自身变化的侦测，比如给数组新增一个元素或删除数组中一个元素，而在<code>Vue</code>中，不论是<code>Object</code>型数据还是<code>Array</code>型数据所实现的数据变化侦测都是深度侦测，所谓深度侦测就是不但要侦测数据自身的变化，还要侦测数据中所有子数据的变化。举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<br>  &#123;<br>    name:<span class=\"hljs-string\">&#x27;NLRX&#x27;</span>，<br>    age:<span class=\"hljs-string\">&#x27;18&#x27;</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure>\n\n<p>数组中包含了一个对象，如果该对象的某个属性发生了变化也应该被侦测到，这就是深度侦测。</p>\n<p>这个实现起来比较简单，源码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Observer</span> </span>&#123;<br>  value: any;<br>  dep: Dep;<br><br>  <span class=\"hljs-keyword\">constructor</span> (value: any) &#123;<br>    <span class=\"hljs-built_in\">this</span>.value = value<br>    <span class=\"hljs-built_in\">this</span>.dep = <span class=\"hljs-keyword\">new</span> Dep()<br>    def(value, <span class=\"hljs-string\">&#x27;__ob__&#x27;</span>, <span class=\"hljs-built_in\">this</span>)<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Array</span>.isArray(value)) &#123;<br>      <span class=\"hljs-keyword\">const</span> augment = hasProto<br>        ? protoAugment<br>        : copyAugment<br>      augment(value, arrayMethods, arrayKeys)<br>      <span class=\"hljs-built_in\">this</span>.observeArray(value)   <span class=\"hljs-comment\">// 将数组中的所有元素都转化为可被侦测的响应式</span><br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-built_in\">this</span>.walk(value)<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * Observe a list of Array items.</span><br><span class=\"hljs-comment\">   */</span><br>  observeArray (items: <span class=\"hljs-built_in\">Array</span>&lt;any&gt;) &#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, l = items.length; i &lt; l; i++) &#123;<br>      observe(items[i])<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">observe</span> (<span class=\"hljs-params\">value, asRootData</span>)</span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (!isObject(value) || value <span class=\"hljs-keyword\">instanceof</span> VNode) &#123;<br>    <span class=\"hljs-keyword\">return</span><br>  &#125;<br>  <span class=\"hljs-keyword\">let</span> ob<br>  <span class=\"hljs-keyword\">if</span> (hasOwn(value, <span class=\"hljs-string\">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class=\"hljs-keyword\">instanceof</span> Observer) &#123;<br>    ob = value.__ob__<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    ob = <span class=\"hljs-keyword\">new</span> Observer(value)<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> ob<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面代码中，对于<code>Array</code>型数据，调用了<code>observeArray()</code>方法，该方法内部会遍历数组中的每一个元素，然后通过调用<code>observe</code>函数将每一个元素都转化成可侦测的响应式数据。</p>\n<p>而对应<code>object</code>数据，在上一篇文章中我们已经在<code>defineReactive</code>函数中进行了递归操作。</p>\n<h5 id=\"数组新增元素的侦测\"><a href=\"#数组新增元素的侦测\" class=\"headerlink\" title=\"数组新增元素的侦测\"></a>数组新增元素的侦测</h5><p>对于数组中已有的元素我们已经可以将其全部转化成可侦测的响应式数据了，但是如果向数组里新增一个元素的话，我们也需要将新增的这个元素转化成可侦测的响应式数据。</p>\n<p>这个实现起来也很容易，我们只需拿到新增的这个元素，然后调用<code>observe</code>函数将其转化即可。我们知道，可以向数组内新增元素的方法有3个，分别是：<code>push</code>、<code>unshift</code>、<code>splice</code>。我们只需对这3中方法分别处理，拿到新增的元素，再将其转化即可。源码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">methodsToPatch.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">method</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// cache original method</span><br>  <span class=\"hljs-keyword\">const</span> original = arrayProto[method]<br>  def(arrayMethods, method, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mutator</span> (<span class=\"hljs-params\">...args</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">const</span> result = original.apply(<span class=\"hljs-built_in\">this</span>, args)<br>    <span class=\"hljs-keyword\">const</span> ob = <span class=\"hljs-built_in\">this</span>.__ob__<br>    <span class=\"hljs-keyword\">let</span> inserted<br>    <span class=\"hljs-keyword\">switch</span> (method) &#123;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;push&#x27;</span>:<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;unshift&#x27;</span>:<br>        inserted = args   <span class=\"hljs-comment\">// 如果是push或unshift方法，那么传入参数就是新增的元素</span><br>        <span class=\"hljs-keyword\">break</span><br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;splice&#x27;</span>:<br>        inserted = args.slice(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 如果是splice方法，那么传入参数列表中下标为2的就是新增的元素</span><br>        <span class=\"hljs-keyword\">break</span><br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (inserted) ob.observeArray(inserted) <span class=\"hljs-comment\">// 调用observe函数将新增的元素转化成响应式</span><br>    <span class=\"hljs-comment\">// notify change</span><br>    ob.dep.notify()<br>    <span class=\"hljs-keyword\">return</span> result<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>不足：</p>\n<p>前文中我们说过，对于数组变化侦测是通过拦截器实现的，也就是说只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是别忘了，我们在日常开发中，还可以通过数组的下标来操作数据，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]<br>arr[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">5</span>;       <span class=\"hljs-comment\">// 通过数组下标修改数组中的数据</span><br>arr.length = <span class=\"hljs-number\">0</span>    <span class=\"hljs-comment\">// 通过修改数组长度清空数组</span><br></code></pre></td></tr></table></figure>\n\n<p>而使用上述例子中的操作方式来修改数组是无法侦测到的。 同样，<code>Vue</code>也注意到了这个问题， 为了解决这一问题，<code>Vue</code>增加了两个全局API:<code>Vue.set</code>和<code>Vue.delete</code>，这两个API的实现原理将会在后面学习全局API的时候说到</p>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><p>在本篇文章中，首先我们分析了对于<code>Array</code>型数据也在<code>getter</code>中进行依赖收集；其次我们发现，当数组数据被访问时我们轻而易举可以知道，但是被修改时我们却很难知道，为了解决这一问题，我们创建了数组方法拦截器，从而成功的将数组数据变的可观测。接着我们对数组的依赖收集及数据变化如何通知依赖进行了深入分析；最后我们发现<code>Vue</code>不但对数组自身进行了变化侦测，还对数组中的每一个元素以及新增的元素都进行了变化侦测，我们也分析了其实现原理。</p>\n<p>以上就是对<code>Array</code>型数据的变化侦测分析。</p>\n<p>撸码一时爽，一直撸码一直爽！！！</p>\n","raw":null,"categories":[],"tags":[{"name":"vue源码理解——变化侦测篇","path":"api/tags/vue源码理解——变化侦测篇.json"}]},{"title":"浅析webpack原理","slug":"浅析webpack原理","date":"2021-03-18T11:29:18.000Z","updated":"2021-09-13T04:01:48.813Z","comments":true,"top":null,"path":"api/articles/浅析webpack原理.json","excerpt":null,"keywords":null,"cover":"https://images.weserv.nl/?url=https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1624457798984-be18a7212fad.jpg","content":"<p><img src=\"https://images.weserv.nl/?url=https://gitee.com/cocacolalc/imgs-hexo/raw/master/img/photo-1624457798984-be18a7212fad.jpg\" alt=\"img\"></p>\n<p>现在随着前端开发的复杂度和规模越来越大，鹰不能抛开工程化来独立开发，比如：react的jsx代码必须编译后才能在浏览器中使用，比如sass和less代码浏览器是不支持的。如果摒弃这些开发框架，开发效率会大幅下降。</p>\n<p>在众多前端工程化工具中，webpack脱颖而出成为了当今最流行的前端构建工具。</p>\n<h4 id=\"webpack的原理\"><a href=\"#webpack的原理\" class=\"headerlink\" title=\"webpack的原理\"></a>webpack的原理</h4><h5 id=\"1、核心概念\"><a href=\"#1、核心概念\" class=\"headerlink\" title=\"1、核心概念\"></a>1、核心概念</h5><p>（1）entry：一个可执行模块或者库的入口</p>\n<p>（2）chunk：多个文件组成一个代码块，可以将可执行的模块和他所依赖的模块组成一个chunk，这是打包</p>\n<p>（3）loader：文件转换器。比如：sass转成css</p>\n<p>（4）plugin：扩展webpack功能的插件。在webpack构建的生命周期节点上加入扩展hook，添加功能。</p>\n<h4 id=\"2、webpack构建流程（原理）\"><a href=\"#2、webpack构建流程（原理）\" class=\"headerlink\" title=\"2、webpack构建流程（原理）\"></a>2、webpack构建流程（原理）</h4><p>从启动构建到输出结果一系列过程：</p>\n<p>（1）初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。</p>\n<p>（2）开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。</p>\n<p>（3）确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。</p>\n<p>（4）编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</p>\n<p>（5）完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry配置生成代码块chunk。</p>\n<p>（6）输出完成：输出所有的chunk到文件系统。</p>\n<p>注意：在构建生命周期中有一系列插件在做合适的时机做合适事情，比如UglifyPlugin会在loader转换递归完对结果使用UglifyJs压缩覆盖之前的结果。</p>\n<p><strong>三、业务场景和对应解决方案</strong></p>\n<p><strong>1、单页应用</strong></p>\n<p>一个单页应用需要配置一个entry指明执行入口，<a href=\"https://github.com/gwuhaolin/web-webpack-plugin\">web-webpack-plugin</a>里的<code>WebPlugin</code>可以自动的完成这些工作：webpack会为entry生成一个包含这个入口的所有依赖文件的chunk，但是还需要一个html来加载chunk生成的js，如果还提取出css需要HTML文件中引入提取的css。</p>\n<p>一个简单的webpack配置文件栗子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> &#123; WebPlugin &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;web-webpack-plugin&#x27;</span>);<br><span class=\"hljs-built_in\">module</span>.exports = &#123;<br>  entry: &#123;<br>    app: <span class=\"hljs-string\">&#x27;./src/doc/index.js&#x27;</span>,<br>    home: <span class=\"hljs-string\">&#x27;./src/doc/home.js&#x27;</span><br>  &#125;,<br>  plugins: [<br>    <span class=\"hljs-comment\">// 一个WebPlugin对应生成一个html文件</span><br>    <span class=\"hljs-keyword\">new</span> WebPlugin(&#123;<br>      <span class=\"hljs-comment\">//输出的html文件名称</span><br>      filename: <span class=\"hljs-string\">&#x27;index.html&#x27;</span>,<br>      <span class=\"hljs-comment\">//这个html依赖的`entry`</span><br>      requires: [<span class=\"hljs-string\">&#x27;app&#x27;</span>,<span class=\"hljs-string\">&#x27;home&#x27;</span>],<br>    &#125;),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>说明：require: [‘app’, ‘home’]指明这个html依赖哪些entry，entry生成的js和css会自动注入到html中。</p>\n<p>还支持配置这些资源注入方式，支持如下属性：</p>\n<p>（1）_dist只有在生产环境中才引入的资源；</p>\n<p>（2）_dev只有在开发环境中才引入的资源；</p>\n<p>（3）_inline把资源的内容潜入到html中；</p>\n<p>（4）_ie只有IE浏览器才需要引入的资源。</p>\n<p>这些属性可以通过在js里配置，看个简单例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> WebPlugin(&#123;<br>    filename: <span class=\"hljs-string\">&#x27;index.html&#x27;</span>,<br>    requires: &#123;<br>         app:&#123;<br>              _dist:<span class=\"hljs-literal\">true</span>,<br>              _inline:<span class=\"hljs-literal\">false</span>,<br>         &#125;<br>    &#125;,<br>&#125;),<br></code></pre></td></tr></table></figure>\n\n<p>这些属性还可以在模板中设置，使用模板好处就是可以灵活的控制资源的注入点。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">new WebPlugin(&#123;<br>      filename: &#x27;index.html&#x27;,<br>      template: &#x27;./template.html&#x27;,<br>&#125;),<br><br>//template模板<br><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh-cn&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">&quot;stylesheet&quot;</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;app?_inline&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;ie-polyfill?_ie&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;react-body&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><code>WebPlugin</code>插件借鉴了<code>fis3</code>的思想，<strong>补足了webpack缺失的以HTML为入口的功能</strong>。想了解<code>WebPlugin</code>的更多功能，见<a href=\"https://github.com/gwuhaolin/web-webpack-plugin/blob/master/readme_zh.md#%E8%BE%93%E5%87%BAhtml%E6%96%87%E4%BB%B6-demo\">文档</a>。</p>\n<p><strong>2、一个项目管理多个单页面</strong></p>\n<p>一个项目中会包含多个单页应用，虽然多个单页面应用可以合成一个，但是这样做会导致用户没有访问的部分也加载了，如果项目中有很多的单页应用。为每一个单页应用配置一个entry和WebPlugin？如果又新增，又要新增webpack配置，这样做麻烦，这时候有一个插件web-webpack-plugin里的AutoWebPlugin方法可以解决这些问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">module</span>.exports = &#123;<br>    plugins: [<br>        <span class=\"hljs-comment\">// 所有页面的入口目录</span><br>        <span class=\"hljs-keyword\">new</span> AutoWebPlugin(<span class=\"hljs-string\">&#x27;./src/&#x27;</span>),<br>    ]<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>分析：1、<code>AutoWebPlugin</code>会把<code>./src/</code>目录下所有每个文件夹作为一个单页页面的入口，自动为所有的页面入口配置一个WebPlugin输出对应的html。</p>\n<p>2、要新增一个页面就在<code>./src/</code>下新建一个文件夹包含这个单页应用所依赖的代码，<code>AutoWebPlugin</code>自动生成一个名叫文件夹名称的html文件。</p>\n<p><strong>3、代码分隔优化</strong></p>\n<p>一个好的代码分割对浏览器首屏效果提升很大。</p>\n<p>最常见的react体系：</p>\n<p><strong>（1）先抽出基础库</strong><code>react</code> <code>react-dom</code> <code>redux</code> <code>react-redux</code>到一个单独的文件而不是和其它文件放在一起打包为一个文件，这样做的好处是只要你不升级他们的版本这个文件永远不会被刷新。如果你把这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致文件hash值变化从而导致缓存失效浏览器重复下载这些包含基础库的代码。所以把<strong>基础库打包成一个文件</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// vender.js 文件抽离基础库到单独的一个文件里防止跟随业务代码被刷新</span><br><span class=\"hljs-comment\">// 所有页面都依赖的第三方库</span><br><span class=\"hljs-comment\">// react基础</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;react-redux&#x27;</span>;<br><span class=\"hljs-comment\">// redux基础</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;redux&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;redux-thunk&#x27;</span>;<br><span class=\"hljs-comment\">// webpack配置</span><br>&#123;<br>  entry: &#123;<br>    vendor: <span class=\"hljs-string\">&#x27;./path/to/vendor.js&#x27;</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>（2）通过<a href=\"https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin\">CommonsChunkPlugin</a>可以提取出多个代码块都依赖的代码形成一个单独的<code>chunk</code>。在应用有多个页面的场景下提取出所有页面公共的代码减少单个页面的代码，在不同页面之间切换时所有页面公共的代码之前被加载过而不必重新加载。所以<strong>通过<a href=\"https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin\">CommonsChunkPlugin</a>可以提取出多个代码块都依赖的代码形成一个单独的<code>chunk。</code></strong></p>\n<p><strong>4、构建服务端渲染</strong></p>\n<p>服务端渲染的代码要运行在nodejs环境，和浏览器不同的是，服务端渲染代码需要采用commonjs规范同时不应该包含除js之外的文件比如css。</p>\n<p>webpack配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">module</span>.exports = &#123;<br>  target: <span class=\"hljs-string\">&#x27;node&#x27;</span>,<br>  entry: &#123;<br>    <span class=\"hljs-string\">&#x27;server_render&#x27;</span>: <span class=\"hljs-string\">&#x27;./src/server_render&#x27;</span>,<br>  &#125;,<br>  output: &#123;<br>    filename: <span class=\"hljs-string\">&#x27;./dist/server/[name].js&#x27;</span>,<br>    libraryTarget: <span class=\"hljs-string\">&#x27;commonjs2&#x27;</span>,<br>  &#125;,<br>  <span class=\"hljs-built_in\">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class=\"hljs-regexp\">/\\.js$/</span>,<br>        loader: <span class=\"hljs-string\">&#x27;babel-loader&#x27;</span>,<br>      &#125;,<br>      &#123;<br>        test: <span class=\"hljs-regexp\">/\\.(scss|css|pdf)$/</span>,<br>        loader: <span class=\"hljs-string\">&#x27;ignore-loader&#x27;</span>,<br>      &#125;,<br>    ]<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>分析一下：</p>\n<p>（1）target: ‘node’指明构建出代码要运行在node环境中。</p>\n<p>（2）libraryTarget: ‘commonjs2’ 指明输出的代码要是commonjs规范。</p>\n<p>（3）{test: /.(scss|css|pdf)$/,loader: ‘ignore-loader’} 是为了防止不能在node里执行服务端渲染也用不上的文件被打包进去。</p>\n<p><strong>5、fis3迁移到webpack</strong></p>\n<p>fis3和webpack有很多相似地方也有不同的地方，相似地方：都采用commonjs规范，不同地方：导入css这些非js资源的方式。</p>\n<p>fis3通过@require ‘./index.scss’，而webpack是通过require(‘./index.scss’)。</p>\n<p>如果想把fis3平滑迁移到webpack，可以使用comment-require-loader。</p>\n<p>比如：你想在webpack构建是使用采用了fis3方式的<code>imui</code>模块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">loaders:[&#123;<br>     test: <span class=\"hljs-regexp\">/\\.js$/</span>,<br>     loaders: [<span class=\"hljs-string\">&#x27;comment-require-loader&#x27;</span>],<br>     include: [path.resolve(__dirname, <span class=\"hljs-string\">&#x27;node_modules/imui&#x27;</span>),]<br>&#125;]<br></code></pre></td></tr></table></figure>\n\n\n\n<p><strong>四、自定义webpack扩展</strong></p>\n<p>如果你在社区找不到你的应用场景的解决方案，那就需要自己动手了写loader或者plugin了。<br>在你编写自定义webpack扩展前你需要想明白到底是要做一个<code>loader</code>还是<code>plugin</code>呢？可以这样判断：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">如果你的扩展是想对一个个单独的文件进行转换那么就编写loader剩下的都是plugin。<br></code></pre></td></tr></table></figure>\n\n<p>其中对文件进行转换可以是像：</p>\n<p>1、babel-loader把es6转为es5；</p>\n<p>2、file-loader把文件替换成对应的url；</p>\n<p>3、raw-loader注入文本文件内容到代码中。</p>\n<p><strong>1、编写webpack loader</strong></p>\n<p>编写<code>loader</code>非常简单，以comment-require-loader为例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">content</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> replace(content);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><code>loader</code>的入口需要导出一个函数，这个函数要干的事情就是转换一个文件的内容。<br>函数接收的参数<code>content</code>是一个文件在转换前的字符串形式内容，需要返回一个新的字符串形式内容作为转换后的结果，所有通过模块化倒入的文件都会经过<code>loader</code>。从这里可以看出<code>loader</code>只能处理一个个单独的文件而不能处理代码块。可以参考<a href=\"https://webpack.js.org/concepts/loaders\">官方文档</a></p>\n<p><strong>2、编写webpack plugin</strong></p>\n<p><code>plugin</code>应用场景广泛，所以稍微复杂点。以end-webpack-plugin为例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">EndWebpackPlugin</span> </span>&#123;<br><br>    <span class=\"hljs-keyword\">constructor</span>(doneCallback, failCallback) &#123;<br>        <span class=\"hljs-built_in\">this</span>.doneCallback = doneCallback;<br>        <span class=\"hljs-built_in\">this</span>.failCallback = failCallback;<br>    &#125;<br><br>    apply(compiler) &#123;<br>        <span class=\"hljs-comment\">// 监听webpack生命周期里的事件，做相应的处理</span><br>        compiler.plugin(<span class=\"hljs-string\">&#x27;done&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">stats</span>) =&gt;</span> &#123;<br>            <span class=\"hljs-built_in\">this</span>.doneCallback(stats);<br>        &#125;);<br>        compiler.plugin(<span class=\"hljs-string\">&#x27;failed&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> &#123;<br>            <span class=\"hljs-built_in\">this</span>.failCallback(err);<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-built_in\">module</span>.exports = EndWebpackPlugin;<br></code></pre></td></tr></table></figure>\n\n<p>loader的入口需要导出一个class，在new EndWebpackPlugin()的时候通过构造函数传入这个插件需要的参数，在webpack启动的时候会先实例化plugin，再调用plugin的apply方法，插件在apply函数里监听webpack生命周期里的事件，做相应的处理。</p>\n<p>webpack plugin的两个核心概念：</p>\n<p>（1）compiler：从webpack启动到退出只存在一个Compiler，compiler存放着webpack的配置。</p>\n<p>（2）compilation：由于webpack的监听文件变化自动编译机制，compilation代表一次编译。</p>\n<p><code>Compiler</code> 和 <code>Compilation</code> 都会广播一系列事件。webpack生命周期里有非常多的事件</p>\n<p>以上只是一个最简单的demo，更复杂的可以查看 <a href=\"https://github.com/webpack/docs/wiki/how-to-write-a-plugin\">how to write a plugin</a>或参考<a href=\"https://github.com/gwuhaolin/web-webpack-plugin\">web-webpack-plugin</a>。</p>\n<p><strong>五、总结</strong></p>\n<p>webpack其实比较简单，用一句话概括本质：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">webpack是一个打包模块化js的工具，可以通过loader转换文件，通过plugin扩展功能。<br></code></pre></td></tr></table></figure>\n\n<p>如果webpack让你感到复杂，一定是各种loader和plugin的原因。</p>\n<p><strong>六、一些问题</strong></p>\n<p><strong>1、webpack与grunt、gulp的不同？</strong></p>\n<p>三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。</p>\n<p>grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。</p>\n<p>webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。</p>\n<p>总结：（1）从构建思路来说：gulp和grunt需要开发者将整个前端构建过程拆分成多个<code>Task</code>，并合理控制所有<code>Task</code>的调用关系 webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工；</p>\n<p>（2）对于知识背景：gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路。</p>\n<p><strong>2、 与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？</strong></p>\n<p>同样是基于入口的打包工具还有以下几个主流的：webpack，rollup，parcel。</p>\n<p>从应用场景上来看：（1）webpack适合大型复杂的前端站点构建；（2）rollup适合基础库的打包，比如vue，react；（3）parcel适用于简单的实验室项目，但是打包出错很难调试。</p>\n<p><strong>3、有哪些常见的Loader？他们是解决什么问题的？</strong></p>\n<p>（1）babel-loader：把es6转成es5；</p>\n<p>（2）css-loader：加载css，支持模块化，压缩，文件导入等特性；</p>\n<p>（3）style-loader：把css代码注入到js中，通过dom操作去加载css；</p>\n<p>（4）eslint-loader：通过Eslint检查js代码；</p>\n<p>（5）image-loader：加载并且压缩图片晚间；</p>\n<p>（6）file-loader：文件输出到一个文件夹中，在代码中通过相对url去引用输出的文件；</p>\n<p>（7）url-loader：和file-loader类似，文件很小的时候可以base64方式吧文件内容注入到代码中。</p>\n<p>（8）source-map-loader：加载额外的source map文件，方便调试。</p>\n<p><strong>4、有哪些常见的Plugin？他们是解决什么问题的？</strong></p>\n<p>（1）uglifyjs-webpack-plugin：通过UglifyJS去压缩js代码；</p>\n<p>（2）commons-chunk-plugin：提取公共代码；</p>\n<p>（3）define-plugin：定义环境变量。</p>\n<p><strong>5、loader和plugin的不同</strong></p>\n<p>作用不同：（1）loader让webpack有加载和解析非js的能力；（2）plugin可以扩展webpack功能，在webpack运行周期中会广播很多事件，Plugin可以监听一些事件，通过webpack的api改变结果。</p>\n<p>用法不同：（1）loader在module.rule中配置。类型为数组，每一项都是Object；（2）plugin是单独配置的，类型为数组，每一项都是plugin实例，参数通过构造函数传入。</p>\n<p><strong>6、webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全</strong></p>\n<p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>\n<p>（1）初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</p>\n<p>（2）开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</p>\n<p>（3）确定入口：根据配置中的 entry 找出所有的入口文件；</p>\n<p>（4）编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</p>\n<p>（5）完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</p>\n<p>（6）输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</p>\n<p>（7）输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p>\n<p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p>\n<p><strong>7、是否写过Loader和Plugin？描述一下编写loader或plugin的思路？</strong></p>\n<p>编写Loader时要遵循单一原则，每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。</p>\n<p>Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>\n<p><strong>8、webpack的热更新是如何做到的？说明其原理？</strong></p>\n<p>webpack的热更新又称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到<strong>不用刷新浏览器而将新变更的模块替换掉旧的模块</strong>。</p>\n<p>原理：</p>\n<p><img src=\"https://www.mwcxs.top/static/upload/pics/2019/2/28FRQimjwzfPAJnjuwHaXYHTyO.png\" alt=\"img\"></p>\n<p>分析：</p>\n<p>（1）第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</p>\n<p>（2）第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。</p>\n<p>（3）第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。</p>\n<p>（4）第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在<strong>浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端</strong>，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。</p>\n<p>（5）webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，<strong>webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新</strong>。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。</p>\n<p>（6）HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。</p>\n<p>（7）而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。</p>\n<p>（8）最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。</p>\n<p><strong>9、如何利用webpack来优化前端性能？（提高性能和体验）</strong></p>\n<p>用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。</p>\n<p>（1）压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css。使用webpack4，打包项目使用production模式，会自动开启代码压缩。</p>\n<p>（2）利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径</p>\n<p>（3）删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现或者使用<strong>es6模块开启删除死代码</strong>。</p>\n<p>（4）优化图片，对于小图可以使用 base64 的方式写入文件中</p>\n<p>（5）按照路由拆分代码，实现按需加载，提取公共代码。</p>\n<p>（6）给打包出来的文件名添加哈希，实现浏览器缓存文件</p>\n<p><strong>10、如何提高webpack的构建速度？</strong></p>\n<p>（1）多入口的情况下，使用commonsChunkPlugin来提取公共代码；</p>\n<p>（2）通过externals配置来提取常用库；</p>\n<p>（3）使用happypack实现多线程加速编译；</p>\n<p>（4）使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。原理上webpack-uglify-parallel采用多核并行压缩来提升压缩速度；</p>\n<p>（5）使用tree-shaking和scope hoisting来剔除多余代码。</p>\n<p><strong>11、怎么配置单页应用？怎么配置多页应用？</strong></p>\n<p>单页应用可以理解为<strong>webpack的标准模式</strong>，直接在entry中指定单页应用的入口即可。</p>\n<p>多页应用的话，可以使用webpack的 <strong>AutoWebPlugin来完成简单自动化的构建</strong>，但是前提是项目的目录结构必须遵守他预设的规范。</p>\n<p><strong>12、npm打包时需要注意哪些？如何利用webpack来更好的构建？</strong></p>\n<p>NPM模块需要注意以下问题：</p>\n<p>（1）要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则</p>\n<p>（2）Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以<strong>打包的最后结果应该是采用ES5编写的</strong>。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。</p>\n<p>（3）Npm包大小应该是尽量小（有些仓库会限制包大小）</p>\n<p>（4）<strong>发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装</strong>。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。</p>\n<p>（5）UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。</p>\n<p>基于以上需要注意的问题，我们可以对于webpack配置做以下扩展和优化：</p>\n<p>（1）CommonJS模块化规范的解决方案： **设置output.libraryTarget=’commonjs2’**使输出的代码符合CommonJS2 模块化规范，以供给其它模块导入使用；</p>\n<p>（2）输出ES5代码的解决方案：<strong>使用babel-loader把 ES6 代码转换成 ES5 的代码</strong>。再通过开启devtool: ‘source-map’输出SourceMap以发布调试。</p>\n<p>（3）Npm包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是<strong>修改.babelrc文件，为其加入transform-runtime插件</strong></p>\n<p>（4）不能将依赖模块打包到NPM模块中的解决方案：<strong>使用externals配置项来告诉webpack哪些模块不需要打包</strong>。</p>\n<p>（5）对于依赖的资源文件打包的解决方案：通过css-loader和extract-text-webpack-plugin来实现，配置如下：</p>\n<p><img src=\"https://www.mwcxs.top/static/upload/pics/2019/2/28IN5rUsvjZdD-j1y65yZ0zpOz.png\" alt=\"img\"></p>\n<p><strong>13、如何在vue项目中实现按需加载？</strong></p>\n<p>经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。</p>\n<p>不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，<strong>在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了</strong>。</p>\n<p><img src=\"https://www.mwcxs.top/static/upload/pics/2019/2/28ay2qKVM8pK9YUkX9Ccm7GT8U.png\" alt=\"img\"></p>\n<p>单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。</p>\n","raw":null,"categories":[],"tags":[{"name":"浅析webpack原理","path":"api/tags/浅析webpack原理.json"}]},{"title":"React","slug":"recat","date":"2021-03-18T11:29:18.000Z","updated":"2021-06-29T09:51:48.355Z","comments":true,"top":null,"path":"api/articles/recat.json","excerpt":null,"keywords":null,"cover":"https://upload-images.jianshu.io/upload_images/8646214-f35c42e6276e7a16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/453/format/webp","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"$ 前言\"></a>$ 前言</h3><p>  最近在考虑框架转型，鉴于作为一名JSer，要时时刻刻保持对新技术和流行技术的敏感性，而 React、Vue、Angular 已基本占领现前端市场，React作为领头大哥，建议年轻的JSer们都要学习使用或至少了解这门技术。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8646214-f35c42e6276e7a16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/453/format/webp\" alt=\"img\"></p>\n<h3 id=\"版本声明\"><a href=\"#版本声明\" class=\"headerlink\" title=\"$ 版本声明\"></a>$ 版本声明</h3><p>  本文使用版本 <strong>React  v16.2.0</strong></p>\n<h3 id=\"什么是-React\"><a href=\"#什么是-React\" class=\"headerlink\" title=\"$ 什么是 React ?\"></a>$ 什么是 React ?</h3><p>  React是一个声明式的，高效的，并且灵活的<strong>用于构建用户界面的 JavaScript 库</strong></p>\n<p>  一个最简单的React例子</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\">ReactDom.render(<br>    &lt;h1&gt;Hello World&lt;/h1&gt;,<br>    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>\n\n<p>  <code>ReactDom.render</code>接受两个参数，第一个是要被插入的内容，第二个是插入到DOM或者说<code>index.html</code>的位置</p>\n<h3 id=\"一个与Html对比的简单组件\"><a href=\"#一个与Html对比的简单组件\" class=\"headerlink\" title=\"$ 一个与Html对比的简单组件\"></a>$ 一个与Html对比的简单组件</h3><p>  如下是一个 <code>React 组件</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ShoppingList</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Componnet</span> </span>&#123;<br>    render() &#123;<br>        <span class=\"hljs-keyword\">return</span> (<br>            &lt;div className=<span class=\"hljs-string\">&quot;shopping-list&quot;</span>&gt;<br>                &lt;h1&gt;Shoping List <span class=\"hljs-keyword\">for</span> &#123;<span class=\"hljs-built_in\">this</span>.props.name&#125;&lt;/h1&gt;<br>                &lt;ul&gt;<br>                    &lt;li&gt;Instagram&lt;/li&gt;<br>                    &lt;li&gt;WhatApp&lt;/li&gt;<br>                    &lt;li&gt;Oculus&lt;/li&gt;<br>                &lt;/ul&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// Example usage:  &lt;ShoppingList name=&quot;Mark&quot; /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>  在这里，ShoppingList是一个 React组件类，或 React组件类型。组件接受参数，称为属性 <code>props</code>, 并通过 <code>render</code>方法返回一个现实的视图层次结构。</p>\n<p>  <code>render</code> 方法返回您要渲染的内容描述，然后React接受该描述并将其渲染到屏幕上，特别是，<code>render</code> 返回一个React 元素，这是一个渲染内容的轻量级的描述。大多数<br> React 开发人员使用 <code>JSX</code> 语法，也是上述案例写到的语法。</p>\n<p>   <code>JSX</code> 语法的转换规则为： <code>&lt;div /&gt;</code> 语法在构建是被转换为 <code>React.createElement(&#39;div&#39;)</code>。因此，上面的例子等价于：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">return</span> React.createElement(<span class=\"hljs-string\">&#x27;div&#x27;</span>, &#123;className: <span class=\"hljs-string\">&#x27;shopping-list&#x27;</span>&#125;,<br>    React.createElement(<span class=\"hljs-string\">&#x27;h1&#x27;</span>, <span class=\"hljs-comment\">/* h1 children ... */</span>),<br>    React.createElement(<span class=\"hljs-string\">&#x27;ul&#x27;</span>, <span class=\"hljs-comment\">/* ul children ... */</span>)<br>);<br></code></pre></td></tr></table></figure>\n\n<p>  既然 <code>JSX</code> 在 React 开发者中这么流行，那 <code>JSX</code> 又是什么呢？</p>\n<h3 id=\"JSX-语法\"><a href=\"#JSX-语法\" class=\"headerlink\" title=\"$ JSX 语法\"></a>$ JSX 语法</h3><p>  <code>JSX</code> 它是 <code>Javascript</code> 的一种拓展语法，能够让你的 <code>Javascript</code> 中和正常描述 HTML一样编写 HTML。</p>\n<p>  你可以用 <code>花括号</code> 将任意 <code>Javascript</code> 表达式嵌入到 <code>JSX</code> 中。例如：表达式 <code>1 + 2</code>, 变量 <code>user.firstName</code>, 和函数 <code>formatName(User)</code> 等都可以嵌入使用</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">formatName</span>(<span class=\"hljs-params\">user</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> user.firstName + <span class=\"hljs-string\">&#x27; &#x27;</span> + user.lastName;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> user = &#123;<br>    firstName: <span class=\"hljs-string\">&#x27;harper&#x27;</span>,<br>    lastName: <span class=\"hljs-string\">&#x27;Perez&#x27;</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> element = &#123;<br>    &lt;h1&gt; Hello, &#123;formatName(user)&#125;! &lt;/h1&gt;<br>&#125;<br><br>ReactDOM.render (<br>    element,<br>    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>\n\n<p>  请注意，为了方便阅读开发者们常将 <code>JSX</code>分割成多行包裹起来，因为这可以避免<a href=\"!%5Bimage.png%5D(https://upload-images.jianshu.io/upload_images/8646214-7743ed84018f8ac7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\">分号自动插入</a>的陷阱，如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&#123; <span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">2</span> &#125; <span class=\"hljs-number\">3</span><br><span class=\"hljs-comment\">// is transformed to</span><br>&#123; <span class=\"hljs-number\">1</span><br>;<span class=\"hljs-number\">2</span> ;&#125; <span class=\"hljs-number\">3</span>;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"JSX-也是一个表达式\"><a href=\"#JSX-也是一个表达式\" class=\"headerlink\" title=\"JSX 也是一个表达式\"></a>JSX 也是一个表达式</h5><p>  编译之后， <code>JSX</code> 表达式也就成了一个常规的 <code>javascript</code> 对象</p>\n<p>  也正因为如此，我们可以在 <code>if</code> 语句或这是 <code>for</code> 循环语句中使用 <code>JSX</code>，用它给变量赋值，当做参数接受，或者作为函数的返回值</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getGreeting</span>(<span class=\"hljs-params\">user</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (user) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello. &#123;formatName(User&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, Stranger<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"用-JSX-指定属性值\"><a href=\"#用-JSX-指定属性值\" class=\"headerlink\" title=\"用  JSX 指定属性值\"></a>用  JSX 指定属性值</h5><p>  你可以用花括号嵌入一个 JavaScript 表达式作为属性值</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// 用引号形式</span><br><span class=\"hljs-keyword\">const</span> element = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">tableIndex</span>=<span class=\"hljs-string\">&quot;0&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;<br><span class=\"hljs-comment\">// 用表达式，并且表达式用花括号包裹</span><br><span class=\"hljs-keyword\">const</span> element = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&#123;user.avatarUrl&#125;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">img</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"用-JSX-指定子元素\"><a href=\"#用-JSX-指定子元素\" class=\"headerlink\" title=\"用 JSX 指定子元素\"></a>用 JSX 指定子元素</h5><p>  如果是空标签，可以直接用 <code>/&gt;</code> 闭合</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> element = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&#123;user.avatarUrl&#125;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>  如果包含子标签：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>Good to see you here.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>比起 <code>HTML</code>，<code>JSX</code> 更接近于<code>Javascript</code>，所以<code>React DOM</code>规范使用驼峰（camelCase）属性命名约定，而不是HTML属性名称，当然，html的部分属性名称也作为保留字，不可使用，例如 <code>class</code>；<br> 因此，<code>class</code> 在 JSX 中 变为 <code>className</code>,  <code>tableindex</code> 变为 <code>tableIndex</code>。</p>\n</blockquote>\n<h5 id=\"用-JSX-防止注入攻击\"><a href=\"#用-JSX-防止注入攻击\" class=\"headerlink\" title=\"用 JSX 防止注入攻击\"></a>用 JSX 防止注入攻击</h5><p>  在JSX 中嵌入用户输入是安全的:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> title = response.potentiallyMaliciousInput;<br><span class=\"hljs-comment\">// 这样是安全的</span><br><span class=\"hljs-keyword\">const</span> element  = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;title&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>  默认情况下， 在渲染之前, React DOM 会格式化(<a href=\"http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html\">escapes</a>) JSX中的所有值. 从而保证用户无法注入任何应用之外的代码. 在被渲染之前，所有的数据都被转义成为了字符串处理。 以避免 <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\">XSS(跨站脚本)</a> 攻击。</p>\n<h3 id=\"元素渲染到DOM\"><a href=\"#元素渲染到DOM\" class=\"headerlink\" title=\"$ 元素渲染到DOM\"></a>$ 元素渲染到DOM</h3><p>  正常情况下，你的 <code>index.html</code> 文件下会有这么一个<code>div</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&#x27;root&#x27;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>  这个<code>root</code> DOM 节点挂在所有React DOM的位置。正常情况下，对于一个React单页面应用构建，只需要一个单独的根DOM节点即可。但如果要把React整合到现有的APP中，则可能会使用到多个DOM节点。</p>\n<p>  React利用<code>render</code>方法将React元素渲染到DOM上，一旦元素被渲染到页面了之后，就不能在修改器子元素或任何元素的属性，就像电影里的一帧，在某以特定的时间点的UI效果，那元素的更新呢？没错，就是重新 <code>render</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">tick</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    cosnt element = &#123;<br>        &lt;div&gt;<br>            &lt;h1&gt;Hello, world&lt;/h1&gt;<br>            &lt;h2&gt;It is &#123;<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().toLocaleTimeString()&#125;.&lt;/h2&gt;<br>        &lt;/div&gt;<br>    &#125;；<br>    ReactDom.render (<br>        element,<br>        <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;root&#x27;</span>)<br>    )<br>&#125;<br><br><span class=\"hljs-built_in\">setInterval</span>(tick, <span class=\"hljs-number\">1000</span>);<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>实际上，大多数 React 应用只会调用一次ReactDom.render()，而实现组件更新的办法就是将代码封装在<strong>有状态的组件</strong>中。</p>\n</blockquote>\n<h5 id=\"React-只更新必须更新的部分\"><a href=\"#React-只更新必须更新的部分\" class=\"headerlink\" title=\"React 只更新必须更新的部分\"></a>React 只更新必须更新的部分</h5><p>  这正是 React 的强大之处。React DOM 会将元素及其子元素与之前版本逐一对比，并只对有必要更新的 DOM 进行更新, 以达到 DOM 所需的状态。</p>\n<p>  开发过程中，更应该每个时间点UI的表现, 而不是关注随着时间不断更新UI的状态, 可以减少很多奇怪的 bug</p>\n<h3 id=\"组件和属性\"><a href=\"#组件和属性\" class=\"headerlink\" title=\"$ 组件和属性\"></a>$ 组件和属性</h3><p>  组件 <code>components</code> 和属性 <code>props</code>，其中，属性是单词 <code>property</code> 的代码简写。</p>\n<h5 id=\"定义组件的两种办法\"><a href=\"#定义组件的两种办法\" class=\"headerlink\" title=\"定义组件的两种办法\"></a>定义组件的两种办法</h5><p>   定义组件有两种方式</p>\n<ol>\n<li><strong>函数式组件定义</strong></li>\n<li><strong>类组件定义</strong><br>  最简单的定义组件的方法就是写一个 <code>Javascript</code> 函数</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Welcome</span>(<span class=\"hljs-params\">props</span>)  </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, props.name<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>  这就是一个有效的组件，它接首了一个 <code>props</code> 参数，并返回了一个React元素，这是一个函数式组件，表面上看，他就是一个 <code>Javascript</code>函数。</p>\n<p>  类组件的定义则依赖ES6 的 <code>class</code> 来定义，下面这种定义方法和上方是等效的;</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Welcome</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>    render() &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"渲染一个组件\"><a href=\"#渲染一个组件\" class=\"headerlink\" title=\"渲染一个组件\"></a>渲染一个组件</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// DOM标签作为组件</span><br><span class=\"hljs-keyword\">const</span> element = &lt;div /&gt;;<br><span class=\"hljs-comment\">// React 元素作为组件</span><br><span class=\"hljs-keyword\">const</span> element = &lt;Welcome name=<span class=\"hljs-string\">&quot;Sara&quot;</span> /&gt;;<br></code></pre></td></tr></table></figure>\n\n<p>  当React 遇到一个代表用户定义组件的元素时，它将 <code>JSX</code> 属性以一个单独对象即<br> <code>props对象</code> 的形式传递给相应的组件，例如</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Welcome</span>(<span class=\"hljs-params\">props</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, &#123;props.mname] <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;<br>&#125;<br><span class=\"hljs-keyword\">const</span> element = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Wlecome</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;Sara&quot;</span> /&gt;</span></span>;<br>ReactDOM.render(<br>    element,<br>    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>\n\n<p>【<strong>理解</strong>】</p>\n<ol>\n<li>调用 <code>ReactDOM.render()</code> 方法并向其传入了<code>&lt;Welcome name=&quot;Sara&quot; /&gt;</code>元素</li>\n<li>Raect 调用 <code>Welcome</code> 组件，并向其传入了 <code>&#123;name： ‘Sara’&#125;</code> 作为 <code>props对象</code></li>\n<li><code>Welcome</code> 组件返回 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code></li>\n<li>React DOM 迅速更新 DOM，使其显示为 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code></li>\n</ol>\n<blockquote>\n<p>组件名称总是以大写字母开始， 如本例子中 <code>&lt;Welcome /&gt;</code>, 而不是 <code>&lt;welcome /&gt;</code></p>\n</blockquote>\n<h5 id=\"构成组件\"><a href=\"#构成组件\" class=\"headerlink\" title=\"构成组件\"></a>构成组件</h5><p>  既然组件是单独的一个React元素，那他能单独工作，因此我们能在一个React 元素中多次引用到相同的组件, 举个例子：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Welcome</span>(<span class=\"hljs-params\">props</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> (<br>        &lt;Welcome name=<span class=\"hljs-string\">&quot;Sara&quot;</span> /&gt;<br>        &lt;Welcome name=<span class=\"hljs-string\">&quot;Lucy&quot;</span> /&gt;<br>        &lt;Welcome name=<span class=\"hljs-string\">&quot;Edite&quot;</span> /&gt;<br>    )<br>&#125;<br><br>ReactDOM.render(<br>    &lt;App /&gt;,<br>    document.getElementBuId(<span class=\"hljs-string\">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>\n\n<p>  通常情况下， React apps 都有一个单独的顶层的 <code>App</code> 组件。如果是在已有的应用中整合React，也需要由下至上的从小的组件开始逐步整合到视图顶层的组件中。</p>\n<blockquote>\n<p>组件必须返回一个单独的根元素，这就是为什么我们要添加一个 <code>&lt;div&gt;</code>来包裹所有的<code>&lt;Welcome /&gt;</code> 元素的原因</p>\n</blockquote>\n<h5 id=\"提取组件\"><a href=\"#提取组件\" class=\"headerlink\" title=\"提取组件\"></a>提取组件</h5><p>  对于一个React 元素，如果其中含有可复用或可能会重复使用的内容，不要害怕把它单拿出来多个更小的组件。</p>\n<p>  提取组件可能看起来是一个繁琐的工作，但是在大型的 <code>App</code> 中可以回报给我们的是大量的可复用组件。一个好的经验准则是如果你 UI 的一部分需要用多次 (<code>Button</code>，<code>Panel</code>，<code>Avatar</code>)，或者本身足够复杂(<code>App</code>，<code>FeedStory</code>，<code>Comment</code>)，最好的做法是使其成为可复用组件。</p>\n<h5 id=\"Props-是只读的\"><a href=\"#Props-是只读的\" class=\"headerlink\" title=\"Props 是只读的\"></a>Props 是只读的</h5><p>  无论你用<a href=\"http://www.css88.com/react/docs/components-and-props.html#functional-and-class-components\">函数或类</a>的方法来声明组件,</p>\n<p>  虽然 React 很灵活，但是它有一条严格的规则：**所有 React 组件都必须是纯函数，并禁止修改其自身 props **。所谓的纯函数就是：传入函数参数不会在函数执行过程中发生改变，比如自增操作 <code>a++</code>。</p>\n<p>  如果<code>props</code>是只读的，那传递给子元素（子组件）的参数岂不是不能修改了？那子元素如何与父元素做交互呢？React还给我们提供了状态属性 <code>state</code>供我们在子组件内部修改值</p>\n<h3 id=\"状态和生命周期\"><a href=\"#状态和生命周期\" class=\"headerlink\" title=\"状态和生命周期\"></a>状态和生命周期</h3><p>  状态<code>state</code>, 生命周期 <code>liftcircle</code>.<br>  之前说过，一旦元素被渲染了之后就不可改变了，但我们可以通过重新渲染的方法使页面得以刷新，同样我们提到过最常用的方法是编写一个可复用的具有状态的组件，这里的状态，就是我们将要说的 <code>state</code></p>\n<p>  我们对上述提过的计时器<code>tick</code> 中的计时功能封装成一个函数式组件如下：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Clock</span>(<span class=\"hljs-params\">props</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> (<br>        &lt;div&gt;<br>            &lt;h1&gt;Hello, world!&lt;/h1&gt;<br>            &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;<br>        &lt;/div&gt;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>  然后把他当做一个元素放入 <code>tick</code> 中进行渲染</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tsx\">function tick() &#123;<br>    ReactDOM.render(<br>        &lt;Clock date&#x3D;&#123;new Date()&#125; &#x2F;&gt;,<br>        document.getElementById(&#39;root&#39;)<br>    )<br>&#125;<br><br>setInterval(tick, 1000);<br></code></pre></td></tr></table></figure>\n\n<p>  在这个例子中，我们将计时功能代码封装成了一个独立的可复用的组件，并通过属性date的方式将参数传入，但还不能到达我们想要的结果，那就是不能再组件内部修改参数值，组件中显示的数据依旧受控于父组件中<code>date</code>属性传递过来的值，那如果我们把这个<code>date</code>属性也添加到<code>Clock</code>内部呢？来看下</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dart\">ReactDOM.render(<br>    &lt;Clock /&gt;,<br>    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>\n\n<p>  这时父组件中只保留了对计时组件<code>Clock</code>的一个单纯的引用。剩下的事情全部依托以组件<code>Clock</code>自己去实现。要怎么实现这个需求？这里React提出了另一个数据对象，即<code>state</code>，它用来保存组件内部的数据，与<code>props</code>类似，不同的是<code>state</code>是组件私有的，并且由组件本身完全控制。它能实现数据在组件内部的修改和更新。怎么使用这个<code>state</code>？继续往下讲之前我们先拓展一个知识</p>\n<p>  我们知道组件有两种定义方式，即函数式组件和类组件，虽然函数式组件更加简洁更加接近原生 <code>javascript</code>，但类组件却拥有一些额外的属性，这个<strong>类组件专有特性</strong>，就是<strong>状态</strong>和<strong>生命周期钩子</strong>，到这里也能清楚知道状态的关键作用，然而函数式组件没有这两个特性，因此，在需要使用到状态<code>state</code>情况下，我们需要将函数式组件转换成类组件</p>\n<h5 id=\"函数式组件转化成类组件\"><a href=\"#函数式组件转化成类组件\" class=\"headerlink\" title=\"函数式组件转化成类组件\"></a>函数式组件转化成类组件</h5><p>  尝试把一个函数式组件转化成类组件，官网给出了以下步骤，以<code>Clock</code>组件为例</p>\n<ol>\n<li>创建一个继承自 <code>React.Component</code> 类的 <code>ES6 class</code> 同名类</li>\n<li>添加一个名为 <code>render()</code> 的空方法</li>\n<li>把原函数中的所有内容移至 <code>render()</code> 中</li>\n<li>在 <code>render()</code> 方法中使用 <code>this.props</code> 替代 <code>props</code></li>\n<li>删除保留的空函数声明</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Clock</span> <span class=\"hljs-title\">extents</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>    render() &#123;<br>        <span class=\"hljs-keyword\">return</span> (<br>            &lt;div&gt;<br>                &lt;h1&gt;Hello, world&lt;/h1&gt;<br>                &lt;h2&gt;It is &#123;<span class=\"hljs-built_in\">this</span>.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>  到此，<code>Clock</code> 组件已经成功被我们修改成了一个类组件，我们便可以在其中添加本地状态<code>state</code>和生命周期钩子</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Clock</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 用类构造函数constructor初始化 this.state</span><br>    <span class=\"hljs-keyword\">constructor</span>(props) &#123;<br>        <span class=\"hljs-comment\">// 使用super()将props传递给基础构造函数</span><br>        <span class=\"hljs-built_in\">super</span>(props);<br>        <span class=\"hljs-built_in\">this</span>.state = &#123;<span class=\"hljs-attr\">date</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()&#125;;<br>    &#125;<br><br>    render() &#123;<br>        <span class=\"hljs-keyword\">return</span> (<br>            &lt;div&gt;<br>                &lt;h1&gt;Hello, world&lt;/h1&gt;<br>                &lt;h2&gt;It is &#123;<span class=\"hljs-built_in\">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>  这样，我们的类组件<code>Clock</code> 就拥有了自己的属性 <code>this.state.date</code>，也就不需要引用组件向其传递值了，因此，我么可以把组件引用中的<code>date</code>属性删掉，最终，我们将其渲染到DOM上，只使用组件引用，其他都交给组件<code>Clock</code>自己去实现</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dart\">ReactDOM.render(<br>    &lt;Clock /&gt;,<br>    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>\n\n<p>  到这里就结束了？细心的你会发现，组件<code>Clock</code>只是实现了当前时间的显示，而我们要改装的功能是一个计时器，计时功能去哪里了？没实现啊？我们需要在组件<code>Clock</code>中找到一个合适的时机去实现这个功能，为此，React团队引入了 声明周期方法，也叫生命周期钩子</p>\n<h5 id=\"在类组件中添加生命周期方法\"><a href=\"#在类组件中添加生命周期方法\" class=\"headerlink\" title=\"在类组件中添加生命周期方法\"></a>在类组件中添加生命周期方法</h5><p>  在一个具有许多组件的应用程序中，在组件被销毁时释放所占用的资源是非常重要的。就像浏览器的垃圾回收机制，近期内不需要再用的资源，应该及时清除。</p>\n<p>  当 <code>Clock</code> 第一次渲染到DOM时，我们要<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval\">设置一个定时器</a> 。 这在 React 中称为 “挂载(mounting)” 。它有一个生命钩子<code>componentDidMount()</code></p>\n<p>当 <code>Clock</code> 产生的 DOM 被销毁时，我们也想<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval\">清除该计时器</a>。 这在 React 中称为 “卸载(unmounting)” 。它的生命钩子是<code>componentWillUnmount()</code></p>\n<p>  我们的计时器是在页面加载之后，页面生成初始化状态，然后由计时器去触发状态的刷新，因此，在挂载完成是去设置计时器是个非常不错的选择</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\">componentDidMount() &#123;<br>    <span class=\"hljs-built_in\">this</span>.timerID = <span class=\"hljs-built_in\">setInterval</span>(<br>        () =&gt; <span class=\"hljs-built_in\">this</span>.tick(), <span class=\"hljs-number\">1000</span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>  这样我们就实现了组件计时功能，或许你注意到了，在该例中，我们把<code>timerID</code>存放在<code>this</code>中而不是<code>this.state</code>中。</p>\n<p>  其实，<code>this.props</code>和<code>this.state</code>也是数据对象与普通对象一样用来存放数据，只是他们被React团队赋予了新的职能， <code>this.props</code>由React本身设定，用来存放在组件引用时的属性键值对对象集，不允许Coder们自己去修改；而<code>this.state</code>也具有特殊的含义，即存放组件本身的、用于视觉输出的数据，但也不是说在编写React程序的时候就必须用用这两个，我们依然可以自己定义普通的数据结构。</p>\n<p>  既然<code>state</code>是用于存放组件视觉输出的数据，那在<code>render()</code>方法中没有被引用的，就不应该出现在<code>state</code>中了。</p>\n<p>  养成良好的编码习惯，编写好计时器时，及时的编写卸载事件。卸载时我们清除的数据也是从<code>this</code>中拿的。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\">componentWillUnmount() &#123;<br>    clearInterval(<span class=\"hljs-keyword\">this</span>.timerID);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>  挂载时我们声明了一个<code>tick()</code>方法，接下来我们就要实现这个方法，是用来触发UI更新。嗯哼？UI更新？我们的页面状态<code>state</code>不是已经更新了吗？为啥还要UI更新？</p>\n<p>  这里有一个非常重要的方法：<code>setState()</code>。我们先把代码补充完整再说明</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\">componentDidMount() &#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br>tick() &#123;<br>    <span class=\"hljs-built_in\">this</span>.setState(&#123;<br>        date: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()<br>    &#125;)<br>&#125;<br><br>componentWillUnmount() &#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>  <code>setState()</code>是React触发页面更新的第二个办法，第一个办法开篇即说过，即<code>render()</code>方法。<code>setState</code>作用就是通知React检查带状态的组件中是否含有脏值。此时react会生成一个虚拟DOM与之前的版本进行对比，只有有必要更新时才会更新。关于 <a href=\"https://www.jianshu.com/p/54a8a0688197\">state 与 setState过程</a> 在我的另一篇文章中有详细说明，有兴趣的可以翻过去看看。</p>\n<p>  为什么不把<code>tick()</code>方法写到<code>componentDidMount()</code>中？因为<code>tick()</code>只是一个普通方法，他不需要在生命周期中触发，也不用自动触发。只要谁调用了触发即可。因此不需要也不能放在生命周期钩子函数中。</p>\n<p>  现在这个时钟每秒都会走了。整理一下，我们整个计时器代码如下：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Clock</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>  <span class=\"hljs-keyword\">constructor</span>(props) &#123;<br>    <span class=\"hljs-built_in\">super</span>(props);<br>    <span class=\"hljs-built_in\">this</span>.state = &#123;<span class=\"hljs-attr\">date</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()&#125;;<br>  &#125;<br><br>  componentDidMount() &#123;<br>    <span class=\"hljs-built_in\">this</span>.timerID = <span class=\"hljs-built_in\">setInterval</span>(<br>      () =&gt; <span class=\"hljs-built_in\">this</span>.tick(),<br>      <span class=\"hljs-number\">1000</span><br>    );<br>  &#125;<br><br>  componentWillUnmount() &#123;<br>    <span class=\"hljs-built_in\">clearInterval</span>(<span class=\"hljs-built_in\">this</span>.timerID);<br>  &#125;<br><br>  tick() &#123;<br>    <span class=\"hljs-built_in\">this</span>.setState(&#123;<br>      date: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()<br>    &#125;);<br>  &#125;<br><br>  render() &#123;<br>    <span class=\"hljs-keyword\">return</span> (<br>      &lt;div&gt;<br>        &lt;h1&gt;Hello, world!&lt;/h1&gt;<br>        &lt;h2&gt;It is &#123;<span class=\"hljs-built_in\">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br><br>ReactDOM.render(<br>  &lt;Clock /&gt;,<br>  <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>\n\n<p>整个流程的执行过程是这样的：</p>\n<ol>\n<li>当 <code>&lt;Clock /&gt;</code> 被传入<code>ReactDOM.render()</code> 时,  React 会调用 <code>Clock</code>组件的构造函数。 因为 <code>Clock</code> 要显示的是当前时间，所以它将使用包含当前时间的对象来初始化 <code>this.state</code>。我们稍后会更新此状态。</li>\n<li>然后 React 调用了 <code>Clock</code> 组件的 <code>render()</code> 方法。 React 从该方法返回内容中得到要显示在屏幕上的内容。然后，React 然后更新 DOM 以匹配 <code>Clock</code> 的渲染输出。</li>\n<li>当 <code>Clock</code> 输出被插入到 DOM 中时，React 调用 <code>componentDidMount()</code> 生命周期钩子。在该方法中，<code>Clock</code> 组件请求浏览器设置一个定时器来一次调用 <code>tick()</code>。</li>\n<li>浏览器会每隔一秒调用一次 <code>tick()</code>方法。在该方法中， <code>Clock</code> 组件通过 <code>setState()</code> 方法并传递一个包含当前时间的对象来安排一个 UI 的更新。通过 <code>setState()</code>, React 得知了组件 <code>state</code>(状态)的变化, 随即再次调用 <code>render()</code> 方法，获取了当前应该显示的内容。 这次，<code>render()</code> 方法中的 <code>this.state.date</code> 的值已经发生了改变， 从而，其输出的内容也随之改变。React 于是据此对 DOM 进行更新。</li>\n<li>如果通过其他操作将 <code>Clock</code> 组件从 DOM 中移除了, React 会调用 <code>componentWillUnmount()</code> 生命周期钩子, 所以计时器也会被停止。</li>\n</ol>\n<h5 id=\"正确的使用State（状态）\"><a href=\"#正确的使用State（状态）\" class=\"headerlink\" title=\"正确的使用State（状态）\"></a>正确的使用State（状态）</h5><p>  对于<code>setState()</code> 有三件事情是我们应该要知道的</p>\n<p><strong>（1）不要直接修改state</strong><br>  真正触发React对比不同版本的虚拟DOM是<code>setState()</code> 方法，直接修改<code>state</code>页面不会刷新，这一点与原生<code>javascript</code>区别较大，需要理解。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-comment\">// 这么做不会触发React更新页面</span><br><span class=\"hljs-keyword\">this</span>.state.comment = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br><span class=\"hljs-comment\">// 使用 setState() 代替</span><br><span class=\"hljs-keyword\">this</span>.setState(&#123; comment: <span class=\"hljs-string\">&#x27;hello&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure>\n\n<p>  【注意】在组件中，唯一可以初始化分配<code>this.state</code>的地方就是构造函数<code>constructor()&#123;&#125;</code></p>\n<p><strong>（2）state（状态）更新可能是异步的</strong><br>  React为了优化性能，有可能会将多个<code>setState()</code> 调用合并为一次更新。这就导致 <code>this.props</code> 和<code>this.state</code> 可能是异步更新的，你不能依赖他们的值计算下一个<code>state(状态)</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-comment\">// counter 计数更新会失败</span><br><span class=\"hljs-keyword\">this</span>.setState(&#123;<br>    counter: <span class=\"hljs-keyword\">this</span>.state.counter <span class=\"hljs-keyword\">this</span>.props.increment<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>  如果我们有这种需求，可以使用以下<code>setState()</code>办法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// ES6 箭头函数法</span><br><span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevState, props</span>) =&gt;</span> (&#123;<br>    counter: prevState.counter + props.increment<br>&#125;));<br><span class=\"hljs-comment\">// 常规函数法</span><br><span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">prevState, props</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>        counter: prevState.counter + props.increment<br>    &#125;;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p><strong>（3）state（状态）更新会被合并</strong><br> 当你调用<code>setState()</code>, React将合并你提供的对象到当前状态中。例如，你的状态可能包含几个独立的变量，然后你用几个独立的setState方法去调用更新，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tsx\">constructor(props) &#123;<br>    super(props);<br>    this.state &#x3D; &#123;<br>        posts: [],<br>        comments: []<br>    &#125;;<br>&#125;<br><br>componentDidMount() &#123;<br>    fetchPosts().then(response &#x3D;&gt; &#123;<br>        this.setState(&#123;<br>            posts: response.posts<br>        &#125;);<br>    &#125;);<br><br>    fetchComments().then(response &#x3D;&gt; &#123;<br>        this.setState(&#123;<br>            comments: response.comments<br>        &#125;);<br>    &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>  合并是<strong>浅合并</strong>，所以，<code>this.setState(&#123;comments&#125;)</code>在合并过程中不会改变<code>this.state.posts</code>的值，但是会完全替换<code>this.state.comments</code> 的值</p>\n<h5 id=\"数据向下流动\"><a href=\"#数据向下流动\" class=\"headerlink\" title=\"数据向下流动\"></a>数据向下流动</h5><p>  无论是作为父组件还是子组件，它都无法或者一个组件是否有状体，同时也不需要关心另一个组件是定义为函数组件还是类组件。这就是为什么<code>state</code>经常被称为 <strong>本地状态</strong>  或 <strong>封装状态</strong>  的原因， 他不能被拥有并设置它的组件以外的任何组件访问。那如果需要访问怎么处理？<br> <strong>（1）作为其子组件的props（属性）</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-comment\">// 在组件中使用</span><br>&lt;h2&gt;It <span class=\"hljs-keyword\">is</span> &#123;<span class=\"hljs-keyword\">this</span>.state.date.toLocaleTimeString()&#125;&lt;/h2&gt;<br><span class=\"hljs-comment\">// 传递给子组件作为props</span><br>&lt;FormattedDate date=&#123;<span class=\"hljs-keyword\">this</span>.state.date&#125; /&gt;<br></code></pre></td></tr></table></figure>\n\n<p>  虽然<code>FormattedDate</code>组件通过<code>props</code>接收了<code>date</code>的值，但它仍然不能获知该值是来自于<code>Clock</code>的<code>state</code>, 还是 <code>Clock</code>的<code>props</code>, 或者一个手动创建的变量.</p>\n<p>  这种数据关系，一般称为”从上到下”或”单向”的数据流。任何<code>state(状态)</code>始终由某个特定组件所有，并且从该<code>state</code>导出的任何数据 或 UI 只能影响树”下方”的组件</p>\n<p>  如果把组件树想像为 <code>props(属性)</code> 的瀑布，所有组件的 <code>state(状态)</code> 就如同一个额外的水源汇入主流，且只能随着主流的方向向下流动。</p>\n<h5 id=\"各组件完全独立\"><a href=\"#各组件完全独立\" class=\"headerlink\" title=\"各组件完全独立\"></a>各组件完全独立</h5><p>  借用上文的<code>Clock</code>组件，我们创建一个<code>App</code>组件，并在其中渲染三个<code>Clock</code>:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"hljs-comment\">// 之前说过组件只能返回一个根节点，所以用&lt;div&gt;包起来</span><br>        &lt;div&gt;<br>            &lt;Clock /&gt;<br>            &lt;Clock /&gt;<br>            &lt;Clock /&gt;<br>        &lt;/div&gt;<br>    );<br>&#125;<br>ReactDOM.render(<br>    &lt;App /&gt;,<br>    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>\n\n<p>  每个<code>Clock</code>都设立它自己的计时器并独立更新，如果<code>App</code>中有一个数据变量，也能被三个<code>Clock</code>相互独立修改。</p>\n<p>  至于何时使用有状态组件，何时使用无状态组件，被认为是组件的一个实现细节，取决于你当时的需求，你可以在有状态组件中使用无状态组件，也可以在无状态组件中使用有状态组件</p>\n<h3 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"$ 事件处理\"></a>$ 事件处理</h3><p>  通过 React 元素处理事件跟在 DOM 元素上处理事件非常相似。但是有一些语法上的区别：</p>\n<ol>\n<li>React 事件使用驼峰命名，而不是全部小写</li>\n<li>通过 JSX , 传递一个函数作为事件处理程序，而不是一个字符串</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">// html usage<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onclick</span>=<span class=\"hljs-string\">&quot;todo()&quot;</span>&gt;</span>click me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><br>// React usage<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;todo&#125;</span>&gt;</span>click me&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>在React中不能通过返回<code>false</code>来阻止默认行为。必须明确的调用<code>preventDefault</code></li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">// html usage<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span> <span class=\"hljs-attr\">onclick</span>=<span class=\"hljs-string\">&quot;console.log(&#x27;clicked&#x27;); return false&quot;</span>&gt;</span><br>    Click me<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// React usage</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ActionLink</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handleClick</span>(<span class=\"hljs-params\">e</span>) </span>&#123;<br>        e.preventDefault();<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;clicked.&#x27;</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> (<br>        &lt;a href=<span class=\"hljs-string\">&quot;#&quot;</span> onClick=&#123;handleClick&#125;&gt;<br>            Click me<br>        &lt;/a&gt;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>  在这里，React团队帮Coder们实现了e事件的跨浏览器兼容问题。当使用React时，我们也不需要调用<code>addEventListener</code>在DOM 元素被创建后添加事件监听器。相反，只要当元素被初始渲染的时候提供一个监听器就可以了。</p>\n<p>  当使用ES6类定义一个组件时，通常的一个事件处理程序就是类上的一个方法，看个例子，<code>Toggle</code> 组件渲染一个按钮，让用户在 “ON” 和 “OFF” 状态之间切换：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Toggle</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>  <span class=\"hljs-keyword\">constructor</span>(props) &#123;<br>    <span class=\"hljs-keyword\">super</span>(props);<br>    <span class=\"hljs-keyword\">this</span>.state = &#123;isToggleOn: <span class=\"hljs-literal\">true</span>&#125;;<br><br>    <span class=\"hljs-comment\">// 这个绑定是必要的，使`this`在回调中起作用</span><br>    <span class=\"hljs-keyword\">this</span>.handleClick = <span class=\"hljs-keyword\">this</span>.handleClick.bind(<span class=\"hljs-keyword\">this</span>);<br>  &#125;<br><br>  handleClick() &#123;<br>    <span class=\"hljs-keyword\">this</span>.setState(prevState =&gt; (&#123;<br>      isToggleOn: !prevState.isToggleOn<br>    &#125;));<br>  &#125;<br><br>  render() &#123;<br>    <span class=\"hljs-keyword\">return</span> (<br>      &lt;button onClick=&#123;<span class=\"hljs-keyword\">this</span>.handleClick&#125;&gt;<br>        &#123;<span class=\"hljs-keyword\">this</span>.state.isToggleOn ? <span class=\"hljs-string\">&#x27;ON&#x27;</span> : <span class=\"hljs-string\">&#x27;OFF&#x27;</span>&#125;<br>      &lt;/button&gt;<br>    );<br>  &#125;<br>&#125;<br><br>ReactDOM.render(<br>  &lt;Toggle /&gt;,<br>  document.getElementById(<span class=\"hljs-string\">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"绑定类方法\"><a href=\"#绑定类方法\" class=\"headerlink\" title=\"绑定类方法\"></a>绑定类方法</h5><p>  在JSX回调中你必须注意 <code>this</code> 的指向。 在 JavaScript 中，类方法默认没有 <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind\">绑定</a> 的。如果你忘记绑定 <code>this.handleClick</code> 并将其传递给<code>onClick</code>，那么在直接调用该函数时，<code>this</code> 会是 <code>undefined</code> 。</p>\n<p> 这不是 React 特有的行为；这是 <code>JavaScript</code> 中的函数如何工作的一部分，可以使用属性初始值设置来正确地 绑定(<code>bind</code>) 回调，但这是实验性做法，不建议使用，以后有可能会废弃，如果你没有使用属性初始化语法<br> （1）可以在回调中使用一个 <code>arrow functions</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LoginButton</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>    handleClick() &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;this is: &#x27;</span>, <span class=\"hljs-built_in\">this</span>)<br>    &#125;<br><br>    render() &#123;<br>        <span class=\"hljs-comment\">// 这个语法确保 `this` 被绑定在 handleClick 中</span><br>        <span class=\"hljs-keyword\">return</span> (<br>            &lt;button onClick=&#123;<span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> <span class=\"hljs-built_in\">this</span>.handleClick(e)&#125;&gt;<br>                Click me<br>            &lt;/button&gt;<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>（2）使用<code>Function.prototype.bind</code> 方法，相对简洁方便</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\">&lt;button onClick=&#123;<span class=\"hljs-keyword\">this</span>.handleClick.bind(<span class=\"hljs-keyword\">this</span>)&#125;&gt;<br>    Click me<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"传递参数给事件处理程序\"><a href=\"#传递参数给事件处理程序\" class=\"headerlink\" title=\"传递参数给事件处理程序\"></a>传递参数给事件处理程序</h5><p>  在循环内部，通常需要将一个额外的参数传递给事件处理程序，常用的有一下两种方案;</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\">&lt;button onClick=&#123;(e)  =&gt; <span class=\"hljs-keyword\">this</span>.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;<br>&lt;button onClick=&#123;<span class=\"hljs-keyword\">this</span>.deleteRow.bind(<span class=\"hljs-keyword\">this</span>.id)&#125;&gt;Delete Row&lt;/button&gt;<br></code></pre></td></tr></table></figure>\n\n<p>  上面两个例子中，参数 <code>e</code> 作为 React 事件对象将会被作为第二个参数进行传递。通过箭头函数的方式，事件对象必须显式的进行传递，但是通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>\n<h3 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"$ 条件渲染\"></a>$ 条件渲染</h3><blockquote>\n<p>在 React 中，你可以创建不同的组件封装你所需要的行为。然后，只渲染它们之中的一些，取决于你的应用的状态。</p>\n</blockquote>\n<h5 id=\"整个组件的条件渲染\"><a href=\"#整个组件的条件渲染\" class=\"headerlink\" title=\"整个组件的条件渲染\"></a>整个组件的条件渲染</h5><p>  React 中的条件渲染就可在JS中的条件语句一样，使用JS操作符如<code>if</code>或者条件控制符来创建渲染当前的元素，并且让React更新匹配的UI。比如我们有一个需求，需要判断用户是否登录，来显示不同组件</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">UserGreeting</span>(<span class=\"hljs-params\">props</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Welcome back!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">GustGrreeting</span>(<span class=\"hljs-params\">props</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Please sign up.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Greeting</span>(<span class=\"hljs-params\">props</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">const</span> isLoggedIn = props.isLoggedIn;<br>    <span class=\"hljs-keyword\">if</span> (isLoggedIn) &#123;<br>        <span class=\"hljs-keyword\">return</span> &lt;UserGreeting /&gt;<br>    &#125; <br>    <span class=\"hljs-keyword\">return</span> &lt;GuestGreeting /&gt;<br>&#125;<br><br>ReactDOM.render(<br>    &lt;Greeting isLoggedIn=&#123;<span class=\"hljs-literal\">false</span>&#125; /&gt;,<br>    document.getElementById(<span class=\"hljs-string\">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"使用元素变量条件渲染部分内容\"><a href=\"#使用元素变量条件渲染部分内容\" class=\"headerlink\" title=\"使用元素变量条件渲染部分内容\"></a>使用元素变量条件渲染部分内容</h5><p>  你可以用变量来存储元素。这可以帮助您有条件地渲染组件的一部分，而输出的其余部分不会更改。下方两个组件用于显示登出和登入按钮</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">LoginButton</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span>(<br>        &lt;button onClick=&#123;props.onClick&#125;&gt;Login&lt;/button&gt;<br>    )<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">LogoutButton</span>(<span class=\"hljs-params\">props</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> (<br>        &lt;button onClick=&#123;props.onclick&#125;&gt;Logout&lt;/button&gt;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>  登入登出按钮已做好，接下来需要实现有切换功能的一个有状态的组件，为了更系统化学习，我们把前面的<code>Greeting</code>组件一起加进来</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LoginControl</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>    <span class=\"hljs-keyword\">constructor</span>(props) &#123;<br>        <span class=\"hljs-keyword\">super</span>(props);<br>        <span class=\"hljs-keyword\">this</span>.state = &#123;<br>            isLoginedIn: <span class=\"hljs-literal\">false</span><br>        &#125;<br>    &#125;<br><br>    handleLoginClick() &#123;<br>        <span class=\"hljs-keyword\">this</span>.setState(&#123;   isLoggedIn: <span class=\"hljs-literal\">true</span> &#125;);<br>    &#125;<br><br>    handleLogoutClick() &#123;<br>        <span class=\"hljs-keyword\">this</span>.setState(&#123; isLoggedIn: <span class=\"hljs-literal\">false</span> &#125;);<br>    &#125;<br><br>    render() &#123;<br>        <span class=\"hljs-keyword\">const</span> isLoggedIn = <span class=\"hljs-keyword\">this</span>.state.isLoggedIn;<br><br>        let button = <span class=\"hljs-literal\">null</span>;<br>        <span class=\"hljs-keyword\">if</span> (isLoggedIn) &#123;<br>            button = &lt;LogoutButton onClick=&#123;<span class=\"hljs-keyword\">this</span>.handleLogoutClick.bind(<span class=\"hljs-keyword\">this</span>)&#125; /&gt;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            button = &lt;LoginButton onclick=&#123;<span class=\"hljs-keyword\">this</span>.handleLoginClick.bind(<span class=\"hljs-keyword\">this</span>)&#125; /&gt;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> (<br>            &lt;div&gt;<br>                &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;&#123;button&#125;&lt;/div&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br><br>reactDOM.render(<br>    &lt;LoginControl /&gt;,<br>    document.getElementById(<span class=\"hljs-string\">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>\n\n<p>  使用<code>if</code>是很常见的一种做法，当然也有一些更简短的语。<code>JSX</code>中有几种内联条件的方法，</p>\n<p><strong>（1）使用逻辑与&amp;&amp;操作符的内联if用法</strong><br>  我们可以在 <code>JSX</code> 中嵌入任何表达式，方法是将其包裹在花括号中，同样适用于JS的逻辑与&amp;&amp;运算符</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Mailbox</span>(<span class=\"hljs-params\">props</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">const</span> unreadMessages = props.unreadMessages;<br>    <span class=\"hljs-keyword\">return</span> (<br>        &lt;div&gt;<br>            &lt;h1&gt;Hello!&lt;/h1&gt;<br>            &#123; unreadMeaasges.length &gt; <span class=\"hljs-number\">0</span> &amp;&amp;<br>                &lt;h2&gt; You have &#123;unreadMessages.length&#125; unread messages.<br>            &#125;<br>        &lt;/div&gt;<br>    )<br>&#125;<br><br>cosnt message = [<span class=\"hljs-string\">&#x27;React&#x27;</span>, <span class=\"hljs-string\">&#x27;Re: React&#x27;</span>, <span class=\"hljs-string\">&#x27;Re:Re: React&#x27;</span>];<br>ReactDOM.render(<br>    &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;,<br>    document.getElementById(<span class=\"hljs-string\">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>\n\n<p>  该案例是可以正常运行的，因为在 <code>JavaScript</code> 中， <code>true &amp;&amp; expression</code> 总是会评估为 <code>expression</code> ，而 <code>false &amp;&amp; expression</code> 总是执行为 <code>false</code> 。并且我们可以在表达式中嵌入表达式</p>\n<p><strong>（2）使用条件操作符的内联If-Else</strong><br>  条件操作符 即三目表达式：<code>condition ？ trueExpression : falseExpression</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-comment\">// 条件渲染字符串</span><br>&lt;div&gt;The user <span class=\"hljs-keyword\">is</span> &#123;isLoggedIn ? <span class=\"hljs-string\">&#x27;currently&#x27;</span> : <span class=\"hljs-string\">&#x27;not&#x27;</span>&#125; logged <span class=\"hljs-keyword\">in</span>.&lt;/div&gt;<br><span class=\"hljs-comment\">// 条件渲染组件</span><br>&lt;div&gt;<br>    &#123;isLoggedIn ? (<br>        &lt;LogoutButton onClick=&#123;<span class=\"hljs-keyword\">this</span>.handleLogoutClick&#125; /&gt;<br>    ) : (<br>        &lt;LoginButton onClick=&#123;<span class=\"hljs-keyword\">this</span>.handleLoginClick&#125; /&gt;<br>    )&#125;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>\n\n<p>  总之，遵循一个原则，哪种方式易于阅读，就选择哪种写法。并且，但条件变得越来越复杂时，可能是提取组件的好时机。</p>\n<h5 id=\"阻止组件渲染\"><a href=\"#阻止组件渲染\" class=\"headerlink\" title=\"阻止组件渲染\"></a>阻止组件渲染</h5><p>  在极少数情况下，您可能希望组件隐藏自身，即使它是由另一个组件渲染的。为此，返回 <code>null</code> 而不是其渲染输出。注意这里是不渲染，不是不显示。</p>\n<p>  在下面的例子中，根据名为<code>warn</code>的 <code>props</code> 值，呈现 <code>&lt;WarningBanner /&gt;</code> 。如果 <code>props</code> 值为 <code>false</code> ，则该组件不渲染：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">WarningBanner</span>(<span class=\"hljs-params\">props</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (props.warn) &#123; <br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> (<br>        &lt;div className=<span class=\"hljs-string\">&quot;warning&quot;</span>&gt;Warning&lt;/div&gt;<br>    )<br>&#125;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Page</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>    <span class=\"hljs-keyword\">constructor</span>(props) &#123;<br>        <span class=\"hljs-built_in\">super</span>(props);<br>        <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">showWarning</span>: <span class=\"hljs-literal\">true</span> &#125;<br>    &#125;<br><br>    handleToggleClick() &#123;<br>        <span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\"><span class=\"hljs-params\">prevState</span> =&gt;</span> (&#123;<br>            showWarning: !prevState.showWarning<br>        &#125;));<br>    &#125;<br><br>    render() &#123;<br>        <span class=\"hljs-keyword\">return</span> (<br>            &lt;div&gt;<br>                &lt;Warningbanner warn=&#123;<span class=\"hljs-built_in\">this</span>.state.showWarning&#125; /&gt;<br>                &lt;button onClick=&#123;<span class=\"hljs-built_in\">this</span>.handleToggleClick.bind(<span class=\"hljs-built_in\">this</span>)&#125;&gt;<br>                    &#123; <span class=\"hljs-built_in\">this</span>.state.showWarning ?   <span class=\"hljs-string\">&#x27;Hide&#x27;</span> : <span class=\"hljs-string\">&#x27;Show&#x27;</span>&#125;<br>                 &lt;/button&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br><br>ReactDOM.render(<br>    &lt;Page /&gt;,<br>    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>\n\n<p>  从组件的 <code>render</code> 方法返回 <code>null</code> 不会影响组件生命周期方法的触发。 例如， <code>componentWillUpdate</code> 和<code>componentDidUpdate</code> 仍将被调用。因此需要组件刚载入时就要判断执行返回<code>null</code></p>\n<h3 id=\"后语\"><a href=\"#后语\" class=\"headerlink\" title=\"$ 后语\"></a>$ 后语</h3><p>  本文为React系统性需学习上半文，下半文主要包括：</p>\n<ol>\n<li>列表(<code>List</code>) 和 键(<code>keys</code>)</li>\n<li>表单(<code>Forms</code>)</li>\n<li>状态提升(<code>Lifting State Up</code>)</li>\n<li>组合 VS 继承 (<code>Composition vs inheritance</code>)</li>\n</ol>\n","raw":null,"categories":[],"tags":[{"name":"React","path":"api/tags/React.json"}]}]}