{"name":"Vue3源码-Proxy","postlist":[{"title":"Vue3源码-Proxy","slug":"vue3源码","date":"2021-03-18T11:29:18.000Z","updated":"2021-08-04T07:01:44.143Z","comments":true,"top":null,"path":"api/articles/vue3源码.json","excerpt":null,"keywords":null,"cover":null,"content":"<h5 id=\"语法：\"><a href=\"#语法：\" class=\"headerlink\" title=\"语法：\"></a>语法：</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(target, handle)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>target 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理</li>\n<li>handler 一个通常以函数作为属性的对象，用来定制拦截行为</li>\n</ul>\n<p>例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> origon=&#123;&#125;<br><br><span class=\"hljs-keyword\">const</span> obj=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(origon,&#123;<br>   get:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target,propkey,receiver</span>)</span>&#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;10&quot;</span><br>   &#125;<br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(obj.b);<span class=\"hljs-comment\">//10</span><br><span class=\"hljs-built_in\">console</span>.log(obj.a);<span class=\"hljs-comment\">//10</span><br><span class=\"hljs-built_in\">console</span>.log(origon.a);<span class=\"hljs-comment\">//undefined</span><br><span class=\"hljs-built_in\">console</span>.log(origon.a);<span class=\"hljs-comment\">//undefined</span><br><br></code></pre></td></tr></table></figure>\n\n<p>上方代码我们给一个空对象的get架设了一层代理，所有<code>get</code>操作都会直接返回我们定制的数字10，需要注意的是，代理只会对<code>proxy</code>对象生效，如上方的<code>origin</code>就没有任何效果</p>\n<h2 id=\"Handler-对象常用的方法\"><a href=\"#Handler-对象常用的方法\" class=\"headerlink\" title=\"Handler 对象常用的方法\"></a>Handler 对象常用的方法</h2><table>\n<thead>\n<tr>\n<th>方法</th>\n<th align=\"left\">描述</th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>handler.has()</td>\n<td align=\"left\">in 操作符的捕捉器。</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>handler.get()</td>\n<td align=\"left\">属性读取操作的捕捉器。</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>handler.set()</td>\n<td align=\"left\">属性设置操作的捕捉器。</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>handler.deleteProperty()</td>\n<td align=\"left\">delete 操作符的捕捉器。</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>handler.ownKeys()</td>\n<td align=\"left\">Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>handler.apply()</td>\n<td align=\"left\">函数调用操作的捕捉器。</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>handler.construct()</td>\n<td align=\"left\">new 操作符的捕捉器</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td align=\"left\"></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>下面挑<code>handler.get</code>重点讲一下，其它方法的使用也都大同小异，不同的是参数的区别</p>\n<h3 id=\"handler-get\"><a href=\"#handler-get\" class=\"headerlink\" title=\"handler.get\"></a>handler.get</h3><p><code>get</code>我们在上面例子已经体验过了，现在详细介绍一下，用于代理目标对象的属性读取操作</p>\n<p>授受三个参数 <code>get(target, propKey, ?receiver)</code></p>\n<ul>\n<li>target 目标对象</li>\n<li>propkey 属性名</li>\n<li>receiver Proxy 实例本身</li>\n</ul>\n<p>例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> preson = &#123;<br>   like: <span class=\"hljs-string\">&#x27;vue.js&#x27;</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(preson, &#123;<br>   get: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, propkey</span>) </span>&#123;<br>      <span class=\"hljs-keyword\">if</span> (propkey <span class=\"hljs-keyword\">in</span> target) &#123;<br>         <span class=\"hljs-keyword\">return</span> target[propkey]<br>      &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>         <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ReferenceError</span>(<span class=\"hljs-string\">&#x27;错误&#x27;</span>)<br>      &#125;<br>   &#125;<br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(obj.like);<span class=\"hljs-comment\">// vuejs</span><br><span class=\"hljs-built_in\">console</span>.log(obj.text);<span class=\"hljs-comment\">//错误</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>注意:</strong></p>\n<ul>\n<li>如果要访问的目标属性是不可写以及不可配置的，则返回的值必须与该目标属性的值相同</li>\n<li>如果要访问的目标属性没有配置访问方法，即get方法是undefined的，则返回值必须为undefined</li>\n</ul>\n<p>如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj = &#123;&#125;;<br><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, <span class=\"hljs-string\">&quot;a&quot;</span>, &#123; <br>  configurable: <span class=\"hljs-literal\">false</span>, <br>  enumerable: <span class=\"hljs-literal\">false</span>, <br>  value: <span class=\"hljs-number\">10</span>, <br>  writable: <span class=\"hljs-literal\">false</span> <br>&#125;)<br><br><span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(obj, &#123;<br>  get: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, prop</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">20</span>;<br>  &#125;<br>&#125;)<br><br>p.a <span class=\"hljs-comment\">// Uncaught TypeError: &#x27;get&#x27; on proxy: property &#x27;a&#x27; is a read-only and non-configurable..</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"可撤消的Proxy\"><a href=\"#可撤消的Proxy\" class=\"headerlink\" title=\"可撤消的Proxy\"></a>可撤消的Proxy</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">proxy&#96;有一个唯一的静态方法，&#96;Proxy.revocable(target, handler)<br></code></pre></td></tr></table></figure>\n\n<p><code>Proxy.revocable()</code>方法可以用来创建一个可撤销的代理对象</p>\n<p>该方法的返回值是一个对象，其结构为： <code>&#123;&quot;proxy&quot;: proxy, &quot;revoke&quot;: revoke&#125;</code></p>\n<ul>\n<li>proxy 表示新生成的代理对象本身，和用一般方式 new Proxy(target, handler) 创建的代理对象没什么不同，只是它可以被撤销掉。</li>\n<li>revoke 撤销方法，调用的时候不需要加任何参数，就可以撤销掉和它一起生成的那个代理对象。</li>\n</ul>\n<p>该方法常用于完全封闭对目标对象的访问, 如下示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> target = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;vuejs&#x27;</span>&#125;<br><span class=\"hljs-keyword\">const</span> &#123;proxy, revoke&#125; = <span class=\"hljs-built_in\">Proxy</span>.revocable(target, handler)<br>proxy.name <span class=\"hljs-comment\">// 正常取值输出 vuejs</span><br>revoke() <span class=\"hljs-comment\">// 取值完成对proxy进行封闭，撤消代理</span><br>proxy.name <span class=\"hljs-comment\">// TypeError: Revoked</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Proxy的应用场景\"><a href=\"#Proxy的应用场景\" class=\"headerlink\" title=\"Proxy的应用场景\"></a>Proxy的应用场景</h2><p><code>Proxy</code>的应用范围很广，下方列举几个典型的应用场景</p>\n<h3 id=\"校验器\"><a href=\"#校验器\" class=\"headerlink\" title=\"#校验器\"></a><a href=\"https://vue3js.cn/es6/#%E6%A0%A1%E9%AA%8C%E5%99%A8\">#</a><strong>校验器</strong></h3><p>想要一个<code>number</code>，拿回来的却是<code>string</code>，惊不惊喜？意不意外？下面我们使用<code>Proxy</code>实现一个逻辑分离的数据格式验证器</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> target = &#123;<br>  _id: <span class=\"hljs-string\">&#x27;1024&#x27;</span>,<br>  name:  <span class=\"hljs-string\">&#x27;vuejs&#x27;</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> validators = &#123;  <br>    name(val) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> val === <span class=\"hljs-string\">&#x27;string&#x27;</span>;<br>    &#125;,<br>    _id(val) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> val === <span class=\"hljs-string\">&#x27;number&#x27;</span> &amp;&amp; val &gt; <span class=\"hljs-number\">1024</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> createValidator = <span class=\"hljs-function\">(<span class=\"hljs-params\">target, validator</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(target, &#123;<br>    _validator: validator,<br>    set(target, propkey, value, proxy)&#123;<br>      <span class=\"hljs-keyword\">let</span> validator = <span class=\"hljs-built_in\">this</span>._validator[propkey](value)<br>      <span class=\"hljs-keyword\">if</span>(validator)&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Reflect</span>.set(target, propkey, value, proxy)<br>      &#125;<span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">`Cannot set <span class=\"hljs-subst\">$&#123;propkey&#125;</span> to <span class=\"hljs-subst\">$&#123;value&#125;</span>. Invalid type.`</span>)<br>      &#125;<br>    &#125;<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> proxy = createValidator(target, validators)<br><br>proxy.name = <span class=\"hljs-string\">&#x27;vue-js.com&#x27;</span> <span class=\"hljs-comment\">// vue-js.com</span><br>proxy.name = <span class=\"hljs-number\">10086</span> <span class=\"hljs-comment\">// Uncaught Error: Cannot set name to 10086. Invalid type.</span><br>proxy._id = <span class=\"hljs-number\">1025</span> <span class=\"hljs-comment\">// 1025</span><br>proxy._id = <span class=\"hljs-number\">22</span>  <span class=\"hljs-comment\">// Uncaught Error: Cannot set _id to 22. Invalid type </span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"私有属性\"><a href=\"#私有属性\" class=\"headerlink\" title=\"私有属性\"></a>私有属性</h3><p>在日常编写代码的过程中，我们想定义一些私有属性，通常是在团队中进行约定，大家按照约定在变量名之前添加下划线 _ 或者其它格式来表明这是一个私有属性，但我们不能保证他能真私‘私有化’，下面使用Proxy轻松实现私有属性拦截</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> target = &#123;<br>   _id: <span class=\"hljs-string\">&#x27;123&#x27;</span>,<br>   name: <span class=\"hljs-string\">&#x27;张三&#x27;</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(target, &#123;<br>   get(target, key, proxy) &#123;<br>      <span class=\"hljs-keyword\">if</span> (key[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">&quot;_&quot;</span>) &#123;<br>         <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;我是私有属性&#x27;</span>)<br>      &#125;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Reflect</span>.get(target, key, proxy)<br>   &#125;,<br>   set(target, key, val, proxy) &#123;<br>      <span class=\"hljs-keyword\">if</span> (key[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">&quot;_&quot;</span>) &#123;<br>         <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;我是私有属性&#x27;</span>)<br>      &#125;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Reflect</span>.set(target, key, val, proxy)<br>   &#125;<br>&#125;)<br><br><span class=\"hljs-built_in\">console</span>.log(proxy.name);<span class=\"hljs-comment\">//张三</span><br><span class=\"hljs-built_in\">console</span>.log(proxy._id);<span class=\"hljs-comment\">//Error: 我是私有属性</span><br><span class=\"hljs-built_in\">console</span>.log(proxy.name = <span class=\"hljs-string\">&#x27;李四&#x27;</span>);<span class=\"hljs-comment\">//李四</span><br><span class=\"hljs-built_in\">console</span>.log(proxy._id = <span class=\"hljs-number\">456</span>);<span class=\"hljs-comment\">//Error: 我是私有属性</span><br><br></code></pre></td></tr></table></figure>\n\n<p><code>Proxy</code> 使用场景还有很多很多，不再一一列举，如果你需要在某一个动作的生命周期内做一些特定的处理，那么<code>Proxy</code> 都是适合的</p>\n<h4 id=\"为什么要用Proxy重构\"><a href=\"#为什么要用Proxy重构\" class=\"headerlink\" title=\"为什么要用Proxy重构\"></a>为什么要用Proxy重构</h4><p>在 <code>Proxy</code> 之前，<code>JavaScript</code> 中就提供过 <code>Object.defineProperty</code>，允许对对象的 <code>getter/setter</code> 进行拦截</p>\n<p>Vue3.0之前的双向绑定是由 <code>defineProperty</code> 实现, 在3.0重构为 <code>Proxy</code>，那么两者的区别究竟在哪里呢？</p>\n<p>首先我们再来回顾一下它的定义</p>\n<blockquote>\n<p>Object.defineProperty() 方法会直接在一个<strong>对象上</strong>定义一个<strong>新属性</strong>，或者修改一个对象的现有属性，并返回此对象</p>\n</blockquote>\n<p>上面给两个词划了重点，<strong>对象上</strong>，<strong>属性</strong>，我们可以理解为是针对对象上的某一个属性做处理的</p>\n<p><strong>语法</strong></p>\n<ul>\n<li>obj 要定义属性的对象</li>\n<li>prop 要定义或修改的属性的名称或 Symbol</li>\n<li>descriptor 要定义或修改的属性描述符</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, prop, descriptor)<br></code></pre></td></tr></table></figure>\n\n<p>举个例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj = &#123;&#125;<br><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, <span class=\"hljs-string\">&quot;a&quot;</span>, &#123;<br>  value : <span class=\"hljs-number\">1</span>,<br>  writable : <span class=\"hljs-literal\">false</span>, <span class=\"hljs-comment\">// 是否可写 </span><br>  configurable : <span class=\"hljs-literal\">false</span>, <span class=\"hljs-comment\">// 是否可配置</span><br>  enumerable : <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// 是否可枚举</span><br>&#125;)<br><br><span class=\"hljs-comment\">// 上面给了三个false, 下面的相关操作就很容易理解了</span><br>obj.a = <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// 无效</span><br><span class=\"hljs-keyword\">delete</span> obj.a <span class=\"hljs-comment\">// 无效</span><br><span class=\"hljs-keyword\">for</span>(key <span class=\"hljs-keyword\">in</span> obj)&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(key) <span class=\"hljs-comment\">// 无效 </span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Vue中的defineProperty\"><a href=\"#Vue中的defineProperty\" class=\"headerlink\" title=\"#Vue中的defineProperty\"></a><a href=\"https://vue3js.cn/es6/#vue%E4%B8%AD%E7%9A%84defineproperty\">#</a><strong>Vue中的defineProperty</strong></h3><p>Vue3之前的双向绑定都是通过 <code>defineProperty</code> 的 <code>getter,setter</code> 来实现的，我们先来体验一下 <code>getter,setter</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj = &#123;&#125;;<br><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, <span class=\"hljs-string\">&#x27;a&#x27;</span>, &#123;<br>  set(val) &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`开始设置新值: <span class=\"hljs-subst\">$&#123;val&#125;</span>`</span>)<br>  &#125;,<br>  get() &#123; <br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`开始读取属性`</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>; <br>  &#125;,<br>  writable : <span class=\"hljs-literal\">true</span><br>&#125;)<br><br>obj.a = <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// 开始设置新值: 2</span><br>obj.a <span class=\"hljs-comment\">// 开始获取属性 </span><br></code></pre></td></tr></table></figure>\n\n<p>看到这里，我相信有些同学已经想到了实现双向绑定背后的流程了，其实很简单嘛，只要我们观察到对象属性的变更，再去通知更新视图就好了</p>\n<p>我们摘抄一段 Vue 源码中的核心实现验证一下，这一部分一笔代过，不是本文重点</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 源码位置：https://github.com/vuejs/vue/blob/ef56410a2c/src/core/observer/index.js#L135</span><br><span class=\"hljs-comment\">// ...</span><br><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, key, &#123;<br>  enumerable: <span class=\"hljs-literal\">true</span>,<br>  configurable: <span class=\"hljs-literal\">true</span>,<br>  get: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reactiveGetter</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>    <span class=\"hljs-keyword\">if</span> (Dep.target) &#123;<br>      <span class=\"hljs-comment\">// 收集依赖</span><br>      dep.depend()<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> value<br>  &#125;,<br>  set: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reactiveSetter</span> (<span class=\"hljs-params\">newVal</span>) </span>&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>    <span class=\"hljs-comment\">// 通知视图更新</span><br>    dep.notify()<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"对象新增属性为什么不更新\"><a href=\"#对象新增属性为什么不更新\" class=\"headerlink\" title=\"#对象新增属性为什么不更新\"></a><a href=\"https://vue3js.cn/es6/#%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%9B%B4%E6%96%B0\">#</a><strong>对象新增属性为什么不更新</strong></h3><p>这个问题用过Vue的同学应该有超过95%比例遇到过</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">data  () &#123;<br>  <span class=\"hljs-keyword\">return</span>  &#123;<br>    obj: &#123;<br>      a: <span class=\"hljs-number\">1</span><br>    &#125;<br>  &#125;<br>&#125;<br><br>methods: &#123;<br>  update () &#123;<br>    <span class=\"hljs-built_in\">this</span>.obj.b = <span class=\"hljs-number\">2</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的伪代码，当我们执行 <code>update</code> 更新 <code>obj</code> 时，我们预期视图是要随之更新的，实际是并不会</p>\n<p>这个其实很好理解，我们先要明白 <code>vue</code> 中 <code>data init</code> 的时机，<code>data init</code> 是在生命周期 <code>created</code> 之前的操作，会对 <code>data</code> 绑定一个观察者 <code>Observer</code>，之后 <code>data</code> 中的字段更新都会通知依赖收集器<code>Dep</code>触发视图更新</p>\n<p>然后我们回到 <code>defineProperty</code> 本身，是对<strong>对象上的属性</strong>做操作，而非对象本身</p>\n<p>一句话来说就是，在 <code>Observer data</code> 时，新增属性并不存在，自然就不会有 <code>getter, setter</code>，也就解释了为什么新增视图不更新，解决有很多种，<code>Vue</code> 提供的全局<code>$set</code> 本质也是给新增的属性手动 <code>observer</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 源码位置 https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js#L201</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">set</span> (<span class=\"hljs-params\">target: Array&lt;any&gt; | Object, key: any, val: any</span>): <span class=\"hljs-title\">any</span> </span>&#123;<br>  <span class=\"hljs-comment\">// ....</span><br>  <span class=\"hljs-keyword\">if</span> (!ob) &#123;<br>    target[key] = val<br>    <span class=\"hljs-keyword\">return</span> val<br>  &#125;<br>  defineReactive(ob.value, key, val)<br>  ob.dep.notify()<br>  <span class=\"hljs-keyword\">return</span> val<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"数组变异\"><a href=\"#数组变异\" class=\"headerlink\" title=\"#数组变异\"></a><a href=\"https://vue3js.cn/es6/#%E6%95%B0%E7%BB%84%E5%8F%98%E5%BC%82\">#</a>数组变异</h3><blockquote>\n<p>由于 JavaScript 的限制，Vue 不能检测以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</p>\n</blockquote>\n<p>先来看一段代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;<br>  data: &#123;<br>    items: [<span class=\"hljs-string\">&#x27;1&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>, <span class=\"hljs-string\">&#x27;3&#x27;</span>]<br>  &#125;<br>&#125;)<br>vm.items[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">&#x27;4&#x27;</span> <span class=\"hljs-comment\">// 视图并未更新</span><br></code></pre></td></tr></table></figure>\n\n<p>文档已经做出了解释，但并不是<code>defineProperty</code>的锅，而是尤大在设计上对性能的权衡，下面这段代码可以验证</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">defineReactive</span>(<span class=\"hljs-params\">data, key, val</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">Object</span>.defineProperty(data, key, &#123;<br>    enumerable: <span class=\"hljs-literal\">true</span>,<br>    configurable: <span class=\"hljs-literal\">true</span>,<br>      get: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">defineGet</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`get key: <span class=\"hljs-subst\">$&#123;key&#125;</span> val: <span class=\"hljs-subst\">$&#123;val&#125;</span>`</span>);<br>        <span class=\"hljs-keyword\">return</span> val;<br>      &#125;,<br>      set: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">defineSet</span>(<span class=\"hljs-params\">newVal</span>) </span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`set key: <span class=\"hljs-subst\">$&#123;key&#125;</span> val: <span class=\"hljs-subst\">$&#123;newVal&#125;</span>`</span>);<br>        val = newVal;<br>      &#125;<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">observe</span>(<span class=\"hljs-params\">data</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">Object</span>.keys(data).forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key</span>) </span>&#123;<br>    defineReactive(data, key, data[key]);<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> test = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br><br>observe(test);<br><br>test[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">4</span> <span class=\"hljs-comment\">// set key: 0 val: 4</span><br></code></pre></td></tr></table></figure>\n\n<p>虽然说索引变更不是 <code>defineProperty</code> 的锅，但新增索引的确是 <code>defineProperty</code> 做不到的，所以就有了数组的变异方法</p>\n<p>能看到这里，大概也能猜到内部实现了，还是跟<code>$set</code>一样，手动 <code>observer</code>，下面我们验证一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> methodsToPatch = [<br>  <span class=\"hljs-string\">&#x27;push&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;pop&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;shift&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;unshift&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;splice&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;sort&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;reverse&#x27;</span><br>]<br><br>methodsToPatch.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">method</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// 缓存原生数组</span><br>  <span class=\"hljs-keyword\">const</span> original = arrayProto[method]<br>  <span class=\"hljs-comment\">// def使用Object.defineProperty重新定义属性</span><br>  def(arrayMethods, method, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mutator</span> (<span class=\"hljs-params\">...args</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">const</span> result = original.apply(<span class=\"hljs-built_in\">this</span>, args) <span class=\"hljs-comment\">// 调用原生数组的方法</span><br><br>    <span class=\"hljs-keyword\">const</span> ob = <span class=\"hljs-built_in\">this</span>.__ob__  <span class=\"hljs-comment\">// ob就是observe实例observe才能响应式</span><br>    <span class=\"hljs-keyword\">let</span> inserted<br>    <span class=\"hljs-keyword\">switch</span> (method) &#123;<br>      <span class=\"hljs-comment\">// push和unshift方法会增加数组的索引，但是新增的索引位需要手动observe的</span><br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;push&#x27;</span>:<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;unshift&#x27;</span>:<br>        inserted = args<br>        <span class=\"hljs-keyword\">break</span><br>      <span class=\"hljs-comment\">// 同理，splice的第三个参数，为新增的值，也需要手动observe</span><br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;splice&#x27;</span>:<br>        inserted = args.slice(<span class=\"hljs-number\">2</span>)<br>        <span class=\"hljs-keyword\">break</span><br>    &#125;<br>    <span class=\"hljs-comment\">// 其余的方法都是在原有的索引上更新，初始化的时候已经observe过了</span><br>    <span class=\"hljs-keyword\">if</span> (inserted) ob.observeArray(inserted)<br>    <span class=\"hljs-comment\">// dep通知所有的订阅者触发回调</span><br>    ob.dep.notify()<br>    <span class=\"hljs-keyword\">return</span> result<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h4><p>一个优秀的开源框架本身就是一个不断打碎重朔的过程，上面做了些许铺垫，现在我们简要总结一下</p>\n<ul>\n<li><code>Proxy</code> 作为新标准将受到浏览器厂商重点持续的性能优化</li>\n<li><code>Proxy</code> 能观察的类型比 <code>defineProperty</code> 更丰富</li>\n<li><code>Proxy</code> 不兼容IE，也没有 <code>polyfill</code>, <code>defineProperty</code> 能支持到IE9</li>\n<li><code>Object.definedProperty</code> 是劫持对象的属性，新增元素需要再次 <code>definedProperty</code>。而 <code>Proxy</code> 劫持的是整个对象，不需要做特殊处理</li>\n<li>使用 <code>defineProperty</code> 时，我们修改原来的 <code>obj</code> 对象就可以触发拦截，而使用 <code>proxy</code>，就必须修改代理对象，即 <code>Proxy</code> 的实例才可以触发拦截</li>\n</ul>\n","raw":null,"categories":[],"tags":[{"name":"Vue3源码-Proxy","path":"api/tags/Vue3源码-Proxy.json"}]}]}